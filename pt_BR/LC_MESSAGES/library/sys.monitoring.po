# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2023
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-06 14:14+0000\n"
"PO-Revision-Date: 2023-09-08 14:16+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2023\n"
"Language-Team: Portuguese (Brazil) (https://app.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"

#: ../../library/sys.monitoring.rst:2
msgid ":mod:`sys.monitoring` --- Execution event monitoring"
msgstr ":mod:`sys.monitoring` --- Monitoramento de eventos de execução"

#: ../../library/sys.monitoring.rst:11
msgid ""
"``sys.monitoring`` is a namespace within the ``sys`` module, not an "
"independent module, so there is no need to ``import sys.monitoring``, simply "
"``import sys`` and then use ``sys.monitoring``."
msgstr ""
"``sys.monitoring`` é um espaço de nomes dentro do módulo ``sys``, não um "
"módulo independente, então não há necessidade de importá-lo com ``import sys."
"monitoring``, bastando usar ``import sys`` e então usar ``sys.monitoring``."

#: ../../library/sys.monitoring.rst:17
msgid ""
"This namespace provides access to the functions and constants necessary to "
"activate and control event monitoring."
msgstr ""
"Esse espaço de nomes fornece acesso às funções e constantes necessárias para "
"ativar e controlar o monitoramento de eventos."

#: ../../library/sys.monitoring.rst:20
msgid ""
"As programs execute, events occur that might be of interest to tools that "
"monitor execution. The :mod:`!sys.monitoring` namespace provides means to "
"receive callbacks when events of interest occur."
msgstr ""
"À medida que os programas são executados, ocorrem eventos que podem ser de "
"interesse para as ferramentas que monitoram a execução. O espaço de nomes :"
"mod:`!sys.monitoring` fornece meios para receber retornos de chamada quando "
"ocorrem eventos de interesse."

#: ../../library/sys.monitoring.rst:24
msgid "The monitoring API consists of three components:"
msgstr "A API de monitoramento consiste em três componentes:"

#: ../../library/sys.monitoring.rst:26 ../../library/sys.monitoring.rst:31
msgid "Tool identifiers"
msgstr "Identificadores de ferramenta"

#: ../../library/sys.monitoring.rst:27 ../../library/sys.monitoring.rst:74
msgid "Events"
msgstr "Eventos"

#: ../../library/sys.monitoring.rst:28
msgid "Callbacks"
msgstr "Funções de retorno"

#: ../../library/sys.monitoring.rst:33
msgid ""
"A tool identifier is an integer and associated name. Tool identifiers are "
"used to discourage tools from interfering with each other and to allow "
"multiple tools to operate at the same time. Currently tools are completely "
"independent and cannot be used to monitor each other. This restriction may "
"be lifted in the future."
msgstr ""
"Um identificador de ferramenta é um número inteiro e um nome associado. Os "
"identificadores de ferramenta são usados para evitar que as ferramentas "
"interfiram umas nas outras e para permitir que várias ferramentas operem ao "
"mesmo tempo. Atualmente, as ferramentas são totalmente independentes e não "
"podem ser usadas para monitorar umas às outras. Essa restrição poderá ser "
"suspensa no futuro."

#: ../../library/sys.monitoring.rst:39
msgid ""
"Before registering or activating events, a tool should choose an identifier. "
"Identifiers are integers in the range 0 to 5."
msgstr ""
"Antes de registrar ou ativar eventos, uma ferramenta deve escolher um "
"identificador. Os identificadores são números inteiros no intervalo de 0 a 5."

#: ../../library/sys.monitoring.rst:43
msgid "Registering and using tools"
msgstr "Registro e uso de ferramentas"

#: ../../library/sys.monitoring.rst:47
msgid ""
"Must be called before ``id`` can be used. ``id`` must be in the range 0 to 5 "
"inclusive. Raises a ``ValueError`` if ``id`` is in use."
msgstr ""
"Deve ser chamado antes que ``id`` possa ser usado. ``id`` deve estar no "
"intervalo de 0 a 5, inclusive. Levanta um ``ValueError`` se ``id`` estiver "
"em uso."

#: ../../library/sys.monitoring.rst:53
msgid "Should be called once a tool no longer requires ``id``."
msgstr ""
"Deve ser chamado quando uma ferramenta não precisar mais do endereço ``id``."

#: ../../library/sys.monitoring.rst:57
msgid ""
"Returns the name of the tool if ``id`` is in use, otherwise it returns "
"``None``. ``id`` must be in the range 0 to 5 inclusive."
msgstr ""
"Retorna o nome da ferramenta se ``id`` estiver em uso; caso contrário, "
"retorna ``None``. ``id`` deve estar no intervalo de 0 a 5, inclusive."

#: ../../library/sys.monitoring.rst:61
msgid ""
"All IDs are treated the same by the VM with regard to events, but the "
"following IDs are pre-defined to make co-operation of tools easier::"
msgstr ""
"Todas as IDs são tratadas da mesma forma pela VM com relação aos eventos, "
"mas as seguintes IDs são predefinidas para facilitar a cooperação entre as "
"ferramentas::"

#: ../../library/sys.monitoring.rst:69
msgid ""
"There is no obligation to set an ID, nor is there anything preventing a tool "
"from using an ID even it is already in use. However, tools are encouraged to "
"use a unique ID and respect other tools."
msgstr ""
"Não há obrigação de definir uma ID, nem há nada que impeça uma ferramenta de "
"usar uma ID, mesmo que ela já esteja em uso. No entanto, as ferramentas são "
"incentivadas a usar uma ID exclusiva e a respeitar as outras ferramentas."

#: ../../library/sys.monitoring.rst:76
msgid "The following events are supported:"
msgstr "Os seguintes eventos são suportados:"

#: ../../library/sys.monitoring.rst:78 ../../library/sys.monitoring.rst:138
msgid "BRANCH"
msgstr "BRANCH"

#: ../../library/sys.monitoring.rst:79
msgid "A conditional branch is taken (or not)."
msgstr "Uma ramificação condicional é feita (ou não)."

#: ../../library/sys.monitoring.rst:80 ../../library/sys.monitoring.rst:134
msgid "CALL"
msgstr "CALL"

#: ../../library/sys.monitoring.rst:81
msgid "A call in Python code (event occurs before the call)."
msgstr "Uma chamada no código Python (o evento ocorre antes da chamada)."

#: ../../library/sys.monitoring.rst:82 ../../library/sys.monitoring.rst:147
msgid "C_RAISE"
msgstr "C_RAISE"

#: ../../library/sys.monitoring.rst:83
msgid ""
"Exception raised from any callable, except Python functions (event occurs "
"after the exit)."
msgstr ""
"Exceção levantada por qualquer chamável, exceto funções Python (o evento "
"ocorre após a saída)."

#: ../../library/sys.monitoring.rst:84 ../../library/sys.monitoring.rst:148
msgid "C_RETURN"
msgstr "C_RETURN"

#: ../../library/sys.monitoring.rst:85
msgid ""
"Return from any callable, except Python functions (event occurs after the "
"return)."
msgstr ""
"Retorno de qualquer chamável, exceto funções Python (o evento ocorre após o "
"retorno)."

#: ../../library/sys.monitoring.rst:86 ../../library/sys.monitoring.rst:165
msgid "EXCEPTION_HANDLED"
msgstr "EXCEPTION_HANDLED"

#: ../../library/sys.monitoring.rst:87
msgid "An exception is handled."
msgstr "Uma exceção é tratada."

#: ../../library/sys.monitoring.rst:88 ../../library/sys.monitoring.rst:136
msgid "INSTRUCTION"
msgstr "INSTRUCTION"

#: ../../library/sys.monitoring.rst:89
msgid "A VM instruction is about to be executed."
msgstr "Uma instrução VM está prestes a ser executada."

#: ../../library/sys.monitoring.rst:90 ../../library/sys.monitoring.rst:137
msgid "JUMP"
msgstr "JUMP"

#: ../../library/sys.monitoring.rst:91
msgid "An unconditional jump in the control flow graph is made."
msgstr "É feito um salto incondicional no gráfico do fluxo de controle."

#: ../../library/sys.monitoring.rst:92 ../../library/sys.monitoring.rst:135
msgid "LINE"
msgstr "LINE"

#: ../../library/sys.monitoring.rst:93
msgid ""
"An instruction is about to be executed that has a different line number from "
"the preceding instruction."
msgstr ""
"Está prestes a ser executada uma instrução que tem um número de linha "
"diferente da instrução anterior."

#: ../../library/sys.monitoring.rst:94 ../../library/sys.monitoring.rst:131
msgid "PY_RESUME"
msgstr "PY_RESUME"

#: ../../library/sys.monitoring.rst:95
msgid ""
"Resumption of a Python function (for generator and coroutine functions), "
"except for throw() calls."
msgstr ""
"Retomada de uma função Python (para funções geradoras e de corrotina), "
"exceto para chamadas throw()."

#: ../../library/sys.monitoring.rst:96 ../../library/sys.monitoring.rst:132
msgid "PY_RETURN"
msgstr "PY_RETURN"

#: ../../library/sys.monitoring.rst:97
msgid ""
"Return from a Python function (occurs immediately before the return, the "
"callee's frame will be on the stack)."
msgstr ""
"Retorno de uma função Python (ocorre imediatamente antes do retorno, o "
"quadro do receptor estará na pilha)."

#: ../../library/sys.monitoring.rst:98 ../../library/sys.monitoring.rst:130
msgid "PY_START"
msgstr "PY_START"

#: ../../library/sys.monitoring.rst:99
msgid ""
"Start of a Python function (occurs immediately after the call, the callee's "
"frame will be on the stack)"
msgstr ""
"Início de uma função Python (ocorre imediatamente após a chamada, o quadro "
"do receptor da chamada estará na pilha)"

#: ../../library/sys.monitoring.rst:100 ../../library/sys.monitoring.rst:162
msgid "PY_THROW"
msgstr "PY_THROW"

#: ../../library/sys.monitoring.rst:101
msgid "A Python function is resumed by a throw() call."
msgstr "Uma função Python é retomada por uma chamada throw()."

#: ../../library/sys.monitoring.rst:102 ../../library/sys.monitoring.rst:163
msgid "PY_UNWIND"
msgstr "PY_UNWIND"

#: ../../library/sys.monitoring.rst:103
msgid "Exit from a Python function during exception unwinding."
msgstr "Saída de uma função Python durante o desenrolar da exceção."

#: ../../library/sys.monitoring.rst:104 ../../library/sys.monitoring.rst:133
msgid "PY_YIELD"
msgstr "PY_YIELD"

#: ../../library/sys.monitoring.rst:105
msgid ""
"Yield from a Python function (occurs immediately before the yield, the "
"callee's frame will be on the stack)."
msgstr ""
"Produz de uma função Python (ocorre imediatamente antes do yield, o quadro "
"do receptor estará na pilha)."

#: ../../library/sys.monitoring.rst:106 ../../library/sys.monitoring.rst:164
msgid "RAISE"
msgstr "RAISE"

#: ../../library/sys.monitoring.rst:107
msgid ""
"An exception is raised, except those that cause a ``STOP_ITERATION`` event."
msgstr ""
"Uma exceção é levantada, exceto aquelas que causam um evento "
"``STOP_ITERATION``."

#: ../../library/sys.monitoring.rst:108
msgid "RERAISE"
msgstr "RERAISE"

#: ../../library/sys.monitoring.rst:109
msgid ""
"An exception is re-raised, for example at the end of a ``finally`` block."
msgstr ""
"Uma exceção é levantada novamente, por exemplo, no final de um bloco "
"``finally``."

#: ../../library/sys.monitoring.rst:111 ../../library/sys.monitoring.rst:139
msgid "STOP_ITERATION"
msgstr "STOP_ITERATION"

#: ../../library/sys.monitoring.rst:111
msgid ""
"An artificial ``StopIteration`` is raised; see `the STOP_ITERATION event`_."
msgstr ""
"Um ``StopIteration`` artificial é levantado; consulte `o evento "
"STOP_ITERATION`_."

#: ../../library/sys.monitoring.rst:113
msgid "More events may be added in the future."
msgstr "Mais eventos poderão ser adicionados no futuro."

#: ../../library/sys.monitoring.rst:115
msgid ""
"These events are attributes of the :mod:`!sys.monitoring.events` namespace. "
"Each event is represented as a power-of-2 integer constant. To define a set "
"of events, simply bitwise or the individual events together. For example, to "
"specify both ``PY_RETURN`` and ``PY_START`` events, use the expression "
"``PY_RETURN | PY_START``."
msgstr ""
"Esses eventos são atributos do espaço de nomes :mod:`!sys.monitoring."
"events`. Cada evento é representado como uma constante de potência de 2 "
"inteiros. Para definir um conjunto de eventos, basta usar o bit a bit ou os "
"eventos individuais juntos. Por exemplo, para especificar os eventos "
"``PY_RETURN`` e ``PY_START``, use a expressão ``PY_RETURN | PY_START``."

#: ../../library/sys.monitoring.rst:121
msgid "Events are divided into three groups:"
msgstr "Os eventos são divididos em três grupos:"

#: ../../library/sys.monitoring.rst:124
msgid "Local events"
msgstr "Eventos locais"

#: ../../library/sys.monitoring.rst:126
msgid ""
"Local events are associated with normal execution of the program and happen "
"at clearly defined locations. All local events can be disabled. The local "
"events are:"
msgstr ""
"Os eventos locais estão associados à execução normal do programa e ocorrem "
"em locais claramente definidos. Todos os eventos locais podem ser "
"desativados. Os eventos locais são:"

#: ../../library/sys.monitoring.rst:142
msgid "Ancillary events"
msgstr "Eventos auxiliares"

#: ../../library/sys.monitoring.rst:144
msgid ""
"Ancillary events can be monitored like other events, but are controlled by "
"another event:"
msgstr ""
"Os eventos auxiliares podem ser monitorados como outros eventos, mas são "
"controlados por outro evento:"

#: ../../library/sys.monitoring.rst:150
msgid ""
"The ``C_RETURN`` and ``C_RAISE`` events are controlled by the ``CALL`` "
"event. ``C_RETURN`` and ``C_RAISE`` events will only be seen if the "
"corresponding ``CALL`` event is being monitored."
msgstr ""
"Os eventos ``C_RETURN`` e ``C_RAISE`` são controlados pelo evento ``CALL``. "
"Os eventos ``C_RETURN`` e ``C_RAISE`` só serão vistos se o evento ``CALL`` "
"correspondente estiver sendo monitorado."

#: ../../library/sys.monitoring.rst:155
msgid "Other events"
msgstr "Outros eventos"

#: ../../library/sys.monitoring.rst:157
msgid ""
"Other events are not necessarily tied to a specific location in the program "
"and cannot be individually disabled."
msgstr ""
"Outros eventos não estão necessariamente vinculados a um local específico no "
"programa e não podem ser desativados individualmente."

#: ../../library/sys.monitoring.rst:160
msgid "The other events that can be monitored are:"
msgstr "Os outros eventos que podem ser monitorados são:"

#: ../../library/sys.monitoring.rst:169
msgid "The STOP_ITERATION event"
msgstr "O evento STOP_ITERATION"

#: ../../library/sys.monitoring.rst:171
msgid ""
":pep:`PEP 380 <380#use-of-stopiteration-to-return-values>` specifies that a "
"``StopIteration`` exception is raised when returning a value from a "
"generator or coroutine. However, this is a very inefficient way to return a "
"value, so some Python implementations, notably CPython 3.12+, do not raise "
"an exception unless it would be visible to other code."
msgstr ""
":pep:`PEP 380 <380#use-of-stopiteration-to-return-values>` especifica que "
"uma exceção ``StopIteration`` é levantada ao retornar um valor de um gerador "
"ou corrotina. No entanto, essa é uma maneira muito ineficiente de retornar "
"um valor, portanto, algumas implementações do Python, especialmente o "
"CPython 3.12+, não levantam uma exceção, a menos que ela seja visível para "
"outro código."

#: ../../library/sys.monitoring.rst:177
msgid ""
"To allow tools to monitor for real exceptions without slowing down "
"generators and coroutines, the ``STOP_ITERATION`` event is provided. "
"``STOP_ITERATION`` can be locally disabled, unlike ``RAISE``."
msgstr ""
"Para permitir que as ferramentas monitorem exceções reais sem reduzir a "
"velocidade dos geradores e das corrotinas, o evento ``STOP_ITERATION`` é "
"fornecido. O ``STOP_ITERATION`` pode ser desativado localmente, ao contrário "
"do ``RAISE``."

#: ../../library/sys.monitoring.rst:183
msgid "Turning events on and off"
msgstr "Ativação e desativação de eventos"

#: ../../library/sys.monitoring.rst:185
msgid ""
"In order to monitor an event, it must be turned on and a callback "
"registered. Events can be turned on or off by setting the events either "
"globally or for a particular code object."
msgstr ""
"Para monitorar um evento, ele deve ser ativado e uma função de retorno deve "
"ser registrada. Os eventos podem ser ativados ou desativados definindo-os "
"globalmente ou para um objeto código específico."

#: ../../library/sys.monitoring.rst:191
msgid "Setting events globally"
msgstr "Definir eventos globalmente"

#: ../../library/sys.monitoring.rst:193
msgid ""
"Events can be controlled globally by modifying the set of events being "
"monitored."
msgstr ""
"Os eventos podem ser controlados globalmente, modificando o conjunto de "
"eventos que estão sendo monitorados."

#: ../../library/sys.monitoring.rst:197
msgid "Returns the ``int`` representing all the active events."
msgstr "Retorna o endereço ``int`` que representa todos os eventos ativos."

#: ../../library/sys.monitoring.rst:201
msgid ""
"Activates all events which are set in ``event_set``. Raises a ``ValueError`` "
"if ``tool_id`` is not in use."
msgstr ""
"Ativa todos os eventos definidos em ``event_set``. Cria um ``ValueError`` se "
"``tool_id`` não estiver em uso."

#: ../../library/sys.monitoring.rst:204
msgid "No events are active by default."
msgstr "Nenhum evento está ativo por padrão."

#: ../../library/sys.monitoring.rst:207
msgid "Per code object events"
msgstr "Eventos por objeto código"

#: ../../library/sys.monitoring.rst:209
msgid "Events can also be controlled on a per code object basis."
msgstr ""
"Os eventos também podem ser controlados com base em cada objeto código."

#: ../../library/sys.monitoring.rst:213
msgid "Returns all the local events for ``code``"
msgstr "Retorna todos os eventos locais para ``code``"

#: ../../library/sys.monitoring.rst:217
msgid ""
"Activates all the local events for ``code`` which are set in ``event_set``. "
"Raises a ``ValueError`` if ``tool_id`` is not in use."
msgstr ""
"Ativa todos os eventos locais para ``code`` que estão definidos em "
"``event_set``. Cria um ``ValueError`` se ``tool_id`` não estiver em uso."

#: ../../library/sys.monitoring.rst:220
msgid ""
"Local events add to global events, but do not mask them. In other words, all "
"global events will trigger for a code object, regardless of the local events."
msgstr ""
"Os eventos locais são adicionados aos eventos globais, mas não os mascaram. "
"Em outras palavras, todos os eventos globais serão acionados para um objeto "
"código, independentemente dos eventos locais."

#: ../../library/sys.monitoring.rst:226
msgid "Disabling events"
msgstr "Desativação de eventos"

#: ../../library/sys.monitoring.rst:228
msgid ""
"Local events can be disabled for a specific code location by returning ``sys."
"monitoring.DISABLE`` from a callback function. This does not change which "
"events are set, or any other code locations for the same event."
msgstr ""
"Os eventos locais podem ser desativados para um local de código específico, "
"retornando ``sys.monitoring.DISABLE`` de uma função de retorno de chamada. "
"Isso não altera quais eventos são definidos ou quaisquer outros locais de "
"código para o mesmo evento."

#: ../../library/sys.monitoring.rst:232
msgid ""
"Disabling events for specific locations is very important for high "
"performance monitoring. For example, a program can be run under a debugger "
"with no overhead if the debugger disables all monitoring except for a few "
"breakpoints."
msgstr ""
"A desativação de eventos para locais específicos é muito importante para o "
"monitoramento de alto desempenho. Por exemplo, um programa pode ser "
"executado em um depurador sem sobrecarga se o depurador desativar todo o "
"monitoramento, exceto alguns pontos de interrupção."

#: ../../library/sys.monitoring.rst:239
msgid "Registering callback functions"
msgstr "Registro de funções de retorno de chamada"

#: ../../library/sys.monitoring.rst:241
msgid "To register a callable for events call"
msgstr "Para registrar um chamável para eventos, chame"

#: ../../library/sys.monitoring.rst:245
msgid ""
"Registers the callable ``func`` for the ``event`` with the given ``tool_id``"
msgstr "Registra o chamável ``func`` para o ``event`` com o ``tool_id``"

#: ../../library/sys.monitoring.rst:247
msgid ""
"If another callback was registered for the given ``tool_id`` and ``event``, "
"it is unregistered and returned. Otherwise ``register_callback`` returns "
"``None``."
msgstr ""
"Se outra função de retorno tiver sido registrada para os dados ``tool_id`` e "
"``event``, ela será cancelada e retornada. Caso contrário, "
"``register_callback`` retorna ``None``."

#: ../../library/sys.monitoring.rst:252
msgid ""
"Functions can be unregistered by calling ``sys.monitoring."
"register_callback(tool_id, event, None)``."
msgstr ""
"As funções podem ser canceladas chamando ``sys.monitoring."
"register_callback(tool_id, event, None)``."

#: ../../library/sys.monitoring.rst:255
msgid "Callback functions can be registered and unregistered at any time."
msgstr ""
"As funções de retorno de chamada podem ser registradas e canceladas a "
"qualquer momento."

#: ../../library/sys.monitoring.rst:257
msgid ""
"Registering or unregistering a callback function will generate a ``sys."
"audit`` event."
msgstr ""
"O registro ou o cancelamento do registro de uma função de retorno de chamada "
"gerará um evento ``sys.audit``."

#: ../../library/sys.monitoring.rst:261
msgid "Callback function arguments"
msgstr "Argumentos da função de retorno de chamada"

#: ../../library/sys.monitoring.rst:263
msgid ""
"When an active event occurs, the registered callback function is called. "
"Different events will provide the callback function with different "
"arguments, as follows:"
msgstr ""
"Quando ocorre um evento ativo, a função de retorno de chamada registrada é "
"chamada. Eventos diferentes fornecerão à função de retorno de chamada "
"argumentos diferentes, como segue:"

#: ../../library/sys.monitoring.rst:266
msgid "``PY_START`` and ``PY_RESUME``::"
msgstr "``PY_START`` e ``PY_RESUME``::"

#: ../../library/sys.monitoring.rst:270
msgid "``PY_RETURN`` and ``PY_YIELD``:"
msgstr "``PY_RETURN`` e ``PY_YIELD``:"

#: ../../library/sys.monitoring.rst:272
msgid ""
"``func(code: CodeType, instruction_offset: int, retval: object) -> DISABLE | "
"Any``"
msgstr ""
"``func(code: CodeType, instruction_offset: int, retval: object) -> DISABLE | "
"Any``"

#: ../../library/sys.monitoring.rst:274
msgid "``CALL``, ``C_RAISE`` and ``C_RETURN``:"
msgstr "``CALL``, ``C_RAISE`` e ``C_RETURN``:"

#: ../../library/sys.monitoring.rst:276
msgid ""
"``func(code: CodeType, instruction_offset: int, callable: object, arg0: "
"object | MISSING) -> DISABLE | Any``"
msgstr ""
"``func(code: CodeType, instruction_offset: int, callable: object, arg0: "
"object | MISSING) -> DISABLE | Any``"

#: ../../library/sys.monitoring.rst:278
msgid "If there are no arguments, ``arg0`` is set to ``MISSING``."
msgstr "Se não houver argumentos, ``arg0`` será definido como ``MISSING``."

#: ../../library/sys.monitoring.rst:280
msgid ""
"``RAISE``, ``RERAISE``, ``EXCEPTION_HANDLED``, ``PY_UNWIND``, ``PY_THROW`` "
"and ``STOP_ITERATION``:"
msgstr ""
"``RAISE``, ``RERAISE``, ``EXCEPTION_HANDLED``, ``PY_UNWIND``, ``PY_THROW`` e "
"``STOP_ITERATION``:"

#: ../../library/sys.monitoring.rst:282
msgid ""
"``func(code: CodeType, instruction_offset: int, exception: BaseException) -> "
"DISABLE | Any``"
msgstr ""
"``func(code: CodeType, instruction_offset: int, exception: BaseException) -> "
"DISABLE | Any``"

#: ../../library/sys.monitoring.rst:284
msgid "``LINE``:"
msgstr "``LINE``:"

#: ../../library/sys.monitoring.rst:286
msgid "``func(code: CodeType, line_number: int) -> DISABLE | Any``"
msgstr "``func(code: CodeType, line_number: int) -> DISABLE | Any``"

#: ../../library/sys.monitoring.rst:288
msgid "``BRANCH`` and ``JUMP``:"
msgstr "``BRANCH`` e ``JUMP``:"

#: ../../library/sys.monitoring.rst:290
msgid ""
"``func(code: CodeType, instruction_offset: int, destination_offset: int) -> "
"DISABLE | Any``"
msgstr ""
"``func(code: CodeType, instruction_offset: int, destination_offset: int) -> "
"DISABLE | Any``"

#: ../../library/sys.monitoring.rst:292
msgid ""
"Note that the ``destination_offset`` is where the code will next execute. "
"For an untaken branch this will be the offset of the instruction following "
"the branch."
msgstr ""
"Observe que ``destination_offset`` é onde o código será executado em "
"seguida. Para uma ramificação não executada, esse será o deslocamento da "
"instrução que segue a ramificação."

#: ../../library/sys.monitoring.rst:296
msgid "``INSTRUCTION``:"
msgstr "``INSTRUCTION``:"

#: ../../library/sys.monitoring.rst:298
msgid "``func(code: CodeType, instruction_offset: int) -> DISABLE | Any``"
msgstr "``func(code: CodeType, instruction_offset: int) -> DISABLE | Any``"
