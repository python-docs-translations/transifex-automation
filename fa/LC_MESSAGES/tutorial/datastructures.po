# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Alireza Shabani <theRevisto@gmail.com>, 2025
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-02-21 17:04+0000\n"
"PO-Revision-Date: 2017-02-16 23:40+0000\n"
"Last-Translator: Alireza Shabani <theRevisto@gmail.com>, 2025\n"
"Language-Team: Persian (https://app.transifex.com/python-doc/teams/5390/fa/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fa\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../tutorial/datastructures.rst:5
msgid "Data Structures"
msgstr "ساختارهای داده"

#: ../../tutorial/datastructures.rst:7
msgid ""
"This chapter describes some things you've learned about already in more "
"detail, and adds some new things as well."
msgstr ""
"این فصل برخی از چیزهایی را که قبلاً در مورد آنها آموخته اید را با جزئیات "
"بیشتر توضیح می دهد و همچنین موارد جدیدی را اضافه می کند."

#: ../../tutorial/datastructures.rst:13
msgid "More on Lists"
msgstr "اطلاعات بیشتر در مورد لیست ها"

#: ../../tutorial/datastructures.rst:15
msgid ""
"The list data type has some more methods.  Here are all of the methods of "
"list objects:"
msgstr ""
"نوع داده لیست روش های بیشتری دارد.  در اینجا همه روش های لیست اشیاء آمده "
"است:"

#: ../../tutorial/datastructures.rst:22
msgid ""
"Add an item to the end of the list.  Equivalent to ``a[len(a):] = [x]``."
msgstr ""

#: ../../tutorial/datastructures.rst:28
msgid ""
"Extend the list by appending all the items from the iterable.  Equivalent to"
" ``a[len(a):] = iterable``."
msgstr ""

#: ../../tutorial/datastructures.rst:35
msgid ""
"Insert an item at a given position.  The first argument is the index of the "
"element before which to insert, so ``a.insert(0, x)`` inserts at the front "
"of the list, and ``a.insert(len(a), x)`` is equivalent to ``a.append(x)``."
msgstr ""
"یک مورد را در یک موقعیت مشخص درج کنید.  اولین آرگومان شاخص عنصری است که قبل "
"از آن درج می شود، بنابراین ``a.insert(0, x)`` در جلوی لیست قرار می گیرد و "
"``a.insert(len(a), x)`` معادل ``a.append(x)`` است."

#: ../../tutorial/datastructures.rst:43
msgid ""
"Remove the first item from the list whose value is equal to *x*.  It raises "
"a :exc:`ValueError` if there is no such item."
msgstr ""
"اولین مورد را که مقدار آن برابر با *x* است را از لیست حذف کنید.  اگر چنین "
"موردی وجود نداشته باشد، یک :exc:`ValueError` را افزایش می دهد."

#: ../../tutorial/datastructures.rst:50
msgid ""
"Remove the item at the given position in the list, and return it.  If no "
"index is specified, ``a.pop()`` removes and returns the last item in the "
"list.  (The square brackets around the *i* in the method signature denote "
"that the parameter is optional, not that you should type square brackets at "
"that position.  You will see this notation frequently in the Python Library "
"Reference.)"
msgstr ""

#: ../../tutorial/datastructures.rst:60
msgid "Remove all items from the list.  Equivalent to ``del a[:]``."
msgstr ""

#: ../../tutorial/datastructures.rst:66
msgid ""
"Return zero-based index in the list of the first item whose value is equal "
"to *x*. Raises a :exc:`ValueError` if there is no such item."
msgstr ""
"شاخص مبتنی بر صفر را در لیست اولین موردی که مقدار آن برابر با *x* است، "
"برگردانید. اگر چنین موردی وجود نداشته باشد، یک :exc:`ValueError` را افزایش "
"می دهد."

#: ../../tutorial/datastructures.rst:69
msgid ""
"The optional arguments *start* and *end* are interpreted as in the slice "
"notation and are used to limit the search to a particular subsequence of the"
" list.  The returned index is computed relative to the beginning of the full"
" sequence rather than the *start* argument."
msgstr ""
"آرگومان های اختیاری *start* و *end* به صورت نماد برش تفسیر می شوند و برای "
"محدود کردن جستجو به دنباله خاصی از لیست استفاده می شوند.  شاخص برگشتی به جای"
" آرگومان *start* نسبت به ابتدای دنباله کامل محاسبه می شود."

#: ../../tutorial/datastructures.rst:78
msgid "Return the number of times *x* appears in the list."
msgstr "تعداد دفعاتی که *x* در لیست ظاهر می شود را برگردانید."

#: ../../tutorial/datastructures.rst:84
msgid ""
"Sort the items of the list in place (the arguments can be used for sort "
"customization, see :func:`sorted` for their explanation)."
msgstr ""
"موارد لیست را در جای خود مرتب کنید (از آرگومان ها می توان برای سفارشی سازی "
"مرتب سازی استفاده کرد, برای توضیح آنها به :func:`sorted` مراجعه کنید)."

#: ../../tutorial/datastructures.rst:91
msgid "Reverse the elements of the list in place."
msgstr "عناصر لیست را در جای خود معکوس کنید."

#: ../../tutorial/datastructures.rst:97
msgid "Return a shallow copy of the list.  Equivalent to ``a[:]``."
msgstr ""

#: ../../tutorial/datastructures.rst:100
msgid "An example that uses most of the list methods::"
msgstr "مثالی که از اکثر متدهای لیست استفاده می کند:"

#: ../../tutorial/datastructures.rst:123
msgid ""
"You might have noticed that methods like ``insert``, ``remove`` or ``sort`` "
"that only modify the list have no return value printed -- they return the "
"default ``None``. [1]_  This is a design principle for all mutable data "
"structures in Python."
msgstr ""

#: ../../tutorial/datastructures.rst:128
msgid ""
"Another thing you might notice is that not all data can be sorted or "
"compared.  For instance, ``[None, 'hello', 10]`` doesn't sort because "
"integers can't be compared to strings and *None* can't be compared to other "
"types.  Also, there are some types that don't have a defined ordering "
"relation.  For example, ``3+4j < 5+7j`` isn't a valid comparison."
msgstr ""

#: ../../tutorial/datastructures.rst:139
msgid "Using Lists as Stacks"
msgstr "استفاده از لیست ها به عنوان پشته"

#: ../../tutorial/datastructures.rst:144
msgid ""
"The list methods make it very easy to use a list as a stack, where the last "
"element added is the first element retrieved (\"last-in, first-out\").  To "
"add an item to the top of the stack, use :meth:`append`.  To retrieve an "
"item from the top of the stack, use :meth:`pop` without an explicit index.  "
"For example::"
msgstr ""

#: ../../tutorial/datastructures.rst:169
msgid "Using Lists as Queues"
msgstr "استفاده از لیست ها به عنوان صف"

#: ../../tutorial/datastructures.rst:173
msgid ""
"It is also possible to use a list as a queue, where the first element added "
"is the first element retrieved (\"first-in, first-out\"); however, lists are"
" not efficient for this purpose.  While appends and pops from the end of "
"list are fast, doing inserts or pops from the beginning of a list is slow "
"(because all of the other elements have to be shifted by one)."
msgstr ""
"همچنین می توان از یک لیست به عنوان صف استفاده کرد، که در آن اولین عنصر اضافه"
" شده، اولین عنصر بازیابی شده است (\"first-in, first-out\"). با این حال، لیست"
" ها برای این منظور کارآمد نیستند.  در حالی که ضمیمه‌ها و پاپ‌ها از انتهای "
"فهرست سریع هستند، انجام درج‌ها یا پاپ‌ها از ابتدای فهرست به کندی انجام "
"می‌شود (زیرا همه عناصر دیگر باید با یک جابجا شوند)."

#: ../../tutorial/datastructures.rst:179
msgid ""
"To implement a queue, use :class:`collections.deque` which was designed to "
"have fast appends and pops from both ends.  For example::"
msgstr ""
"برای پیاده سازی یک صف، از :class:`collections.deque` استفاده کنید که به گونه"
" ای طراحی شده است که دارای ضمائم سریع و پاپ از هر دو طرف باشد.  به عنوان "
"مثال::"

#: ../../tutorial/datastructures.rst:197
msgid "List Comprehensions"
msgstr "فهرست درک"

#: ../../tutorial/datastructures.rst:199
msgid ""
"List comprehensions provide a concise way to create lists. Common "
"applications are to make new lists where each element is the result of some "
"operations applied to each member of another sequence or iterable, or to "
"create a subsequence of those elements that satisfy a certain condition."
msgstr ""
"درک فهرست ها راهی مختصر برای ایجاد لیست ها فراهم می کند. برنامه های رایج "
"عبارتند از ایجاد لیست های جدید که در آن هر عنصر نتیجه برخی از عملیات اعمال "
"شده بر روی هر یک از اعضای یک دنباله دیگر یا قابل تکرار است، یا ایجاد دنباله "
"ای از آن عناصر که شرایط خاصی را برآورده می کند."

#: ../../tutorial/datastructures.rst:204
msgid "For example, assume we want to create a list of squares, like::"
msgstr "به عنوان مثال، فرض کنید می خواهیم لیستی از مربع ها ایجاد کنیم، مانند:"

#: ../../tutorial/datastructures.rst:213
msgid ""
"Note that this creates (or overwrites) a variable named ``x`` that still "
"exists after the loop completes.  We can calculate the list of squares "
"without any side effects using::"
msgstr ""
"توجه داشته باشید که با این کار متغیری به نام ``x`` ایجاد می شود (یا بازنویسی"
" می شود) که پس از اتمام حلقه همچنان وجود دارد.  ما می توانیم لیست مربع ها را"
" بدون هیچ گونه عوارض جانبی با استفاده از:"

#: ../../tutorial/datastructures.rst:219
msgid "or, equivalently::"
msgstr "یا به طور معادل::"

#: ../../tutorial/datastructures.rst:223
msgid "which is more concise and readable."
msgstr "که مختصرتر و خواندنی تر است."

#: ../../tutorial/datastructures.rst:225
msgid ""
"A list comprehension consists of brackets containing an expression followed "
"by a :keyword:`!for` clause, then zero or more :keyword:`!for` or "
":keyword:`!if` clauses.  The result will be a new list resulting from "
"evaluating the expression in the context of the :keyword:`!for` and "
":keyword:`!if` clauses which follow it. For example, this listcomp combines "
"the elements of two lists if they are not equal::"
msgstr ""
"درک لیست شامل براکت هایی است که شامل عبارتی به دنبال آن یک بند "
":keyword:`!for` و سپس صفر یا بیشتر عبارت :keyword:`!for` یا :keyword:`!if` "
"است.  نتیجه یک لیست جدید خواهد بود که از ارزیابی عبارت در متن بندهای "
":keyword:`!for` و :keyword:`!if` حاصل می شود. به عنوان مثال، این listcomp "
"عناصر دو لیست را در صورتی که برابر نباشند ترکیب می کند:"

#: ../../tutorial/datastructures.rst:235
msgid "and it's equivalent to::"
msgstr "و معادل است با::"

#: ../../tutorial/datastructures.rst:246
msgid ""
"Note how the order of the :keyword:`for` and :keyword:`if` statements is the"
" same in both these snippets."
msgstr ""
"توجه داشته باشید که چگونه ترتیب دستورات :keyword:`for` و :keyword:`if` در هر"
" دو قطعه یکسان است."

#: ../../tutorial/datastructures.rst:249
msgid ""
"If the expression is a tuple (e.g. the ``(x, y)`` in the previous example), "
"it must be parenthesized. ::"
msgstr ""
"اگر عبارت یک تاپلی باشد (مثلاً ``(x, y)`` در مثال قبلی), باید پرانتز شود. ::"

#: ../../tutorial/datastructures.rst:280
msgid ""
"List comprehensions can contain complex expressions and nested functions::"
msgstr "درک لیست می تواند شامل عبارات پیچیده و توابع تو در تو باشد:"

#: ../../tutorial/datastructures.rst:287
msgid "Nested List Comprehensions"
msgstr "درک لیست تودرتو"

#: ../../tutorial/datastructures.rst:289
msgid ""
"The initial expression in a list comprehension can be any arbitrary "
"expression, including another list comprehension."
msgstr ""
"عبارت اولیه در درک لیست می تواند هر عبارت دلخواه، از جمله درک لیست دیگری "
"باشد."

#: ../../tutorial/datastructures.rst:292
msgid ""
"Consider the following example of a 3x4 matrix implemented as a list of 3 "
"lists of length 4::"
msgstr ""
"مثال زیر را از یک ماتریس 3x4 در نظر بگیرید که به صورت لیستی از 3 لیست با طول"
" 4 پیاده سازی شده است:"

#: ../../tutorial/datastructures.rst:301
msgid "The following list comprehension will transpose rows and columns::"
msgstr "درک لیست زیر سطرها و ستون ها را جابجا می کند:"

#: ../../tutorial/datastructures.rst:306
msgid ""
"As we saw in the previous section, the nested listcomp is evaluated in the "
"context of the :keyword:`for` that follows it, so this example is equivalent"
" to::"
msgstr ""

#: ../../tutorial/datastructures.rst:317
msgid "which, in turn, is the same as::"
msgstr "که به نوبه خود همان است که:"

#: ../../tutorial/datastructures.rst:330
msgid ""
"In the real world, you should prefer built-in functions to complex flow "
"statements. The :func:`zip` function would do a great job for this use "
"case::"
msgstr ""
"در دنیای واقعی، شما باید توابع داخلی را به دستورات جریان پیچیده ترجیح دهید. "
"تابع :func:`zip` کار بسیار خوبی برای این مورد استفاده می کند:"

#: ../../tutorial/datastructures.rst:336
msgid ""
"See :ref:`tut-unpacking-arguments` for details on the asterisk in this line."
msgstr ""
"برای جزئیات بیشتر در مورد ستاره در این خط به :ref:`tut-unpacking-arguments` "
"مراجعه کنید."

#: ../../tutorial/datastructures.rst:341
msgid "The :keyword:`!del` statement"
msgstr "بیانیه :keyword:`!del`"

#: ../../tutorial/datastructures.rst:343
msgid ""
"There is a way to remove an item from a list given its index instead of its "
"value: the :keyword:`del` statement.  This differs from the :meth:`pop` "
"method which returns a value.  The :keyword:`!del` statement can also be "
"used to remove slices from a list or clear the entire list (which we did "
"earlier by assignment of an empty list to the slice).  For example::"
msgstr ""

#: ../../tutorial/datastructures.rst:360
msgid ":keyword:`del` can also be used to delete entire variables::"
msgstr ":keyword:`del` همچنین می تواند برای حذف کل متغیرها استفاده شود:"

#: ../../tutorial/datastructures.rst:364
msgid ""
"Referencing the name ``a`` hereafter is an error (at least until another "
"value is assigned to it).  We'll find other uses for :keyword:`del` later."
msgstr ""
"ارجاع به نام ``a`` از این پس یک خطا است (حداقل تا زمانی که مقدار دیگری به آن"
" اختصاص داده شود).  ما بعداً کاربردهای دیگری برای :keyword:`del` پیدا خواهیم"
" کرد."

#: ../../tutorial/datastructures.rst:371
msgid "Tuples and Sequences"
msgstr "Tuples and Sequences"

#: ../../tutorial/datastructures.rst:373
msgid ""
"We saw that lists and strings have many common properties, such as indexing "
"and slicing operations.  They are two examples of *sequence* data types (see"
" :ref:`typesseq`).  Since Python is an evolving language, other sequence "
"data types may be added.  There is also another standard sequence data type:"
" the *tuple*."
msgstr ""
"دیدیم که لیست‌ها و رشته‌ها ویژگی‌های مشترک زیادی دارند، مانند عملیات "
"فهرست‌سازی و برش.  آنها دو نمونه از انواع داده *sequence* هستند (به "
":ref:`typesseq` مراجعه کنید).  از آنجایی که پایتون یک زبان در حال تکامل است،"
" ممکن است انواع داده های توالی دیگری اضافه شود.  نوع داده توالی استاندارد "
"دیگری نیز وجود دارد: *tuple*."

#: ../../tutorial/datastructures.rst:379
msgid ""
"A tuple consists of a number of values separated by commas, for instance::"
msgstr ""
"یک تاپل از تعدادی مقدار تشکیل شده است که با کاما از هم جدا شده اند، به عنوان"
" مثال:"

#: ../../tutorial/datastructures.rst:401
msgid ""
"As you see, on output tuples are always enclosed in parentheses, so that "
"nested tuples are interpreted correctly; they may be input with or without "
"surrounding parentheses, although often parentheses are necessary anyway (if"
" the tuple is part of a larger expression).  It is not possible to assign to"
" the individual items of a tuple, however it is possible to create tuples "
"which contain mutable objects, such as lists."
msgstr ""
"همانطور که می بینید، تاپل های خروجی همیشه در داخل پرانتز قرار می گیرند، به "
"طوری که تاپل های تو در تو به درستی تفسیر می شوند. آنها ممکن است با یا بدون "
"پرانتزهای اطراف وارد شوند، اگرچه اغلب پرانتزها به هر حال ضروری هستند (اگر "
"تاپل بخشی از یک عبارت بزرگتر باشد).  نمی‌توان به تک تک آیتم‌های یک تاپل "
"اختصاص داد، با این حال می‌توان تاپل‌هایی ایجاد کرد که حاوی اشیاء قابل تغییر،"
" مانند لیست‌ها هستند."

#: ../../tutorial/datastructures.rst:408
msgid ""
"Though tuples may seem similar to lists, they are often used in different "
"situations and for different purposes. Tuples are :term:`immutable`, and "
"usually contain a heterogeneous sequence of elements that are accessed via "
"unpacking (see later in this section) or indexing (or even by attribute in "
"the case of :func:`namedtuples <collections.namedtuple>`). Lists are "
":term:`mutable`, and their elements are usually homogeneous and are accessed"
" by iterating over the list."
msgstr ""
"اگرچه تاپل ها ممکن است شبیه به لیست ها به نظر برسند، اما اغلب در موقعیت های "
"مختلف و برای اهداف مختلف استفاده می شوند. تاپل ها :term:`immutable` هستند و "
"معمولاً شامل یک توالی ناهمگن از عناصر هستند که از طریق باز کردن بسته بندی "
"(به بعد در این بخش مراجعه کنید) یا نمایه سازی (یا حتی با ویژگی در مورد "
":func:`namedtuples <collections.namedtuple>`) قابل دسترسی هستند. لیست ها "
":term:`mutable` هستند و عناصر آنها معمولاً همگن هستند و با تکرار در لیست "
"قابل دسترسی هستند."

#: ../../tutorial/datastructures.rst:416
msgid ""
"A special problem is the construction of tuples containing 0 or 1 items: the"
" syntax has some extra quirks to accommodate these.  Empty tuples are "
"constructed by an empty pair of parentheses; a tuple with one item is "
"constructed by following a value with a comma (it is not sufficient to "
"enclose a single value in parentheses). Ugly, but effective.  For example::"
msgstr ""
"یک مشکل خاص ساخت تاپل هایی است که حاوی 0 یا 1 آیتم هستند: نحو دارای برخی "
"ویژگی های عجیب و غریب برای جا دادن این موارد است.  تاپل های خالی با یک جفت "
"پرانتز خالی ساخته می شوند. یک تاپل با یک آیتم با دنبال کردن یک مقدار با کاما"
" ساخته می‌شود (اینکه یک مقدار را در پرانتز قرار دهید کافی نیست). زشت، اما "
"موثر.  به عنوان مثال::"

#: ../../tutorial/datastructures.rst:431
msgid ""
"The statement ``t = 12345, 54321, 'hello!'`` is an example of *tuple "
"packing*: the values ``12345``, ``54321`` and ``'hello!'`` are packed "
"together in a tuple. The reverse operation is also possible::"
msgstr ""
"عبارت ``t = 12345, 54321, 'hello!'`` نمونه ای از *tuple packing* است: مقادیر"
" ``12345``، ``54321`` و ``'hello!'`` در یک تاپیک با هم بسته بندی شده اند. "
"عملیات معکوس نیز امکان پذیر است:"

#: ../../tutorial/datastructures.rst:437
msgid ""
"This is called, appropriately enough, *sequence unpacking* and works for any"
" sequence on the right-hand side.  Sequence unpacking requires that there "
"are as many variables on the left side of the equals sign as there are "
"elements in the sequence.  Note that multiple assignment is really just a "
"combination of tuple packing and sequence unpacking."
msgstr ""
"این به اندازه کافی *sequence unpacking* نامیده می شود و برای هر دنباله ای در"
" سمت راست کار می کند.  باز کردن توالی مستلزم آن است که به تعداد عناصر موجود "
"در دنباله، در سمت چپ علامت تساوی متغیر وجود داشته باشد.  توجه داشته باشید که"
" تخصیص چندگانه در واقع فقط ترکیبی از بسته بندی چندگانه و باز کردن توالی است."

#: ../../tutorial/datastructures.rst:447
msgid "Sets"
msgstr "مجموعه ها"

#: ../../tutorial/datastructures.rst:449
msgid ""
"Python also includes a data type for *sets*.  A set is an unordered "
"collection with no duplicate elements.  Basic uses include membership "
"testing and eliminating duplicate entries.  Set objects also support "
"mathematical operations like union, intersection, difference, and symmetric "
"difference."
msgstr ""
"پایتون همچنین شامل یک نوع داده برای *sets* است.  مجموعه یک مجموعه نامرتب و "
"بدون عناصر تکراری است.  کاربردهای اصلی شامل تست عضویت و حذف ورودی های تکراری"
" است.  اشیاء مجموعه همچنین از عملیات ریاضی مانند اتحاد، تقاطع، تفاوت و تفاوت"
" متقارن پشتیبانی می کنند."

#: ../../tutorial/datastructures.rst:454
msgid ""
"Curly braces or the :func:`set` function can be used to create sets.  Note: "
"to create an empty set you have to use ``set()``, not ``{}``; the latter "
"creates an empty dictionary, a data structure that we discuss in the next "
"section."
msgstr ""
"برای ایجاد مجموعه می توان از بریس های فرفری یا تابع :func:`set` استفاده کرد."
"  توجه: برای ایجاد یک مجموعه خالی باید از ``set()`` استفاده کنید نه ``{}``. "
"دومی یک فرهنگ لغت خالی ایجاد می کند، یک ساختار داده که در بخش بعدی به آن می "
"پردازیم."

#: ../../tutorial/datastructures.rst:458
msgid "Here is a brief demonstration::"
msgstr "در اینجا یک نمایش کوتاه وجود دارد:"

#: ../../tutorial/datastructures.rst:483
msgid ""
"Similarly to :ref:`list comprehensions <tut-listcomps>`, set comprehensions "
"are also supported::"
msgstr ""
"مانند :ref:`list comprehensions <tut-listcomps>`، درک مجموعه نیز پشتیبانی می"
" شود:"

#: ../../tutorial/datastructures.rst:494
msgid "Dictionaries"
msgstr "لغت نامه ها"

#: ../../tutorial/datastructures.rst:496
msgid ""
"Another useful data type built into Python is the *dictionary* (see "
":ref:`typesmapping`). Dictionaries are sometimes found in other languages as"
" \"associative memories\" or \"associative arrays\".  Unlike sequences, "
"which are indexed by a range of numbers, dictionaries are indexed by *keys*,"
" which can be any immutable type; strings and numbers can always be keys.  "
"Tuples can be used as keys if they contain only strings, numbers, or tuples;"
" if a tuple contains any mutable object either directly or indirectly, it "
"cannot be used as a key. You can't use lists as keys, since lists can be "
"modified in place using index assignments, slice assignments, or methods "
"like :meth:`append` and :meth:`extend`."
msgstr ""

#: ../../tutorial/datastructures.rst:507
msgid ""
"It is best to think of a dictionary as a set of *key: value* pairs, with the"
" requirement that the keys are unique (within one dictionary). A pair of "
"braces creates an empty dictionary: ``{}``. Placing a comma-separated list "
"of key:value pairs within the braces adds initial key:value pairs to the "
"dictionary; this is also the way dictionaries are written on output."
msgstr ""
"بهتر است دیکشنری را مجموعه‌ای از جفت‌های *key: value* در نظر بگیرید، با این "
"شرط که کلیدها منحصر به فرد باشند (در یک فرهنگ لغت). یک جفت بریس یک فرهنگ لغت"
" خالی ایجاد می کند: ``{}``. قرار دادن یک لیست جدا شده با کاما از جفت های "
"کلید:مقدار در داخل پرانتز، جفت های کلید:مقدار اولیه را به فرهنگ لغت اضافه می"
" کند. این روشی است که دیکشنری ها روی خروجی نوشته می شوند."

#: ../../tutorial/datastructures.rst:513
msgid ""
"The main operations on a dictionary are storing a value with some key and "
"extracting the value given the key.  It is also possible to delete a "
"key:value pair with ``del``. If you store using a key that is already in "
"use, the old value associated with that key is forgotten.  It is an error to"
" extract a value using a non-existent key."
msgstr ""
"عملیات اصلی در یک فرهنگ لغت، ذخیره یک مقدار با مقداری کلید و استخراج مقدار "
"داده شده کلید است.  همچنین امکان حذف یک جفت کلید: ارزش با ``del`` وجود دارد."
" اگر با استفاده از کلیدی که قبلاً در حال استفاده است ذخیره کنید، مقدار قدیمی"
" مرتبط با آن کلید فراموش می شود.  استخراج یک مقدار با استفاده از کلیدی که "
"وجود ندارد یک خطا است."

#: ../../tutorial/datastructures.rst:519
msgid ""
"Performing ``list(d)`` on a dictionary returns a list of all the keys used "
"in the dictionary, in insertion order (if you want it sorted, just use "
"``sorted(d)`` instead). To check whether a single key is in the dictionary, "
"use the :keyword:`in` keyword."
msgstr ""
"اجرای ``list(d)`` در دیکشنری فهرستی از تمام کلیدهای استفاده شده در فرهنگ لغت"
" را به ترتیب درج برمی گرداند (اگر می خواهید مرتب شود, فقط از ``sorted(d)`` "
"استفاده کنید). برای بررسی اینکه آیا یک کلید در فرهنگ لغت وجود دارد یا خیر، "
"از کلمه کلیدی :keyword:`in` استفاده کنید."

#: ../../tutorial/datastructures.rst:524
msgid "Here is a small example using a dictionary::"
msgstr "در اینجا یک مثال کوچک با استفاده از فرهنگ لغت آورده شده است:"

#: ../../tutorial/datastructures.rst:545
msgid ""
"The :func:`dict` constructor builds dictionaries directly from sequences of "
"key-value pairs::"
msgstr ""
"سازنده :func:`dict` دیکشنری ها را مستقیماً از دنباله های جفت کلید-مقدار می "
"سازد:"

#: ../../tutorial/datastructures.rst:551
msgid ""
"In addition, dict comprehensions can be used to create dictionaries from "
"arbitrary key and value expressions::"
msgstr ""
"علاوه بر این، درک دیکت می تواند برای ایجاد فرهنگ لغت از عبارات کلیدی و "
"مقادیر دلخواه استفاده شود:"

#: ../../tutorial/datastructures.rst:557
msgid ""
"When the keys are simple strings, it is sometimes easier to specify pairs "
"using keyword arguments::"
msgstr ""
"وقتی کلیدها رشته های ساده ای هستند، گاهی اوقات تعیین جفت ها با استفاده از "
"آرگومان های کلیدواژه آسان تر است:"

#: ../../tutorial/datastructures.rst:567
msgid "Looping Techniques"
msgstr "تکنیک های حلقه زدن"

#: ../../tutorial/datastructures.rst:569
msgid ""
"When looping through dictionaries, the key and corresponding value can be "
"retrieved at the same time using the :meth:`items` method. ::"
msgstr ""

#: ../../tutorial/datastructures.rst:579
msgid ""
"When looping through a sequence, the position index and corresponding value "
"can be retrieved at the same time using the :func:`enumerate` function. ::"
msgstr ""
"هنگام حلقه زدن از طریق یک دنباله، شاخص موقعیت و مقدار مربوطه را می توان "
"همزمان با استفاده از تابع :func:`enumerate` بازیابی کرد. ::"

#: ../../tutorial/datastructures.rst:589
msgid ""
"To loop over two or more sequences at the same time, the entries can be "
"paired with the :func:`zip` function. ::"
msgstr ""
"برای حلقه روی دو یا چند دنباله به طور همزمان، ورودی ها را می توان با تابع "
":func:`zip` جفت کرد. ::"

#: ../../tutorial/datastructures.rst:601
msgid ""
"To loop over a sequence in reverse, first specify the sequence in a forward "
"direction and then call the :func:`reversed` function. ::"
msgstr ""
"برای چرخش بر روی یک دنباله به صورت معکوس، ابتدا دنباله را در جهت جلو مشخص "
"کنید و سپس تابع :func:`reversed` را فراخوانی کنید. ::"

#: ../../tutorial/datastructures.rst:613
msgid ""
"To loop over a sequence in sorted order, use the :func:`sorted` function "
"which returns a new sorted list while leaving the source unaltered. ::"
msgstr ""
"برای حلقه زدن روی یک دنباله به ترتیب مرتب شده، از تابع :func:`sorted` "
"استفاده کنید که یک لیست مرتب شده جدید را برمی گرداند در حالی که منبع را بدون"
" تغییر باقی می گذارد. ::"

#: ../../tutorial/datastructures.rst:627
msgid ""
"Using :func:`set` on a sequence eliminates duplicate elements. The use of "
":func:`sorted` in combination with :func:`set` over a sequence is an "
"idiomatic way to loop over unique elements of the sequence in sorted order. "
"::"
msgstr ""
"استفاده از :func:`set` روی یک دنباله، عناصر تکراری را حذف می کند. استفاده از"
" :func:`sorted` در ترکیب با :func:`set` روی یک دنباله، روشی اصطلاحی برای "
"حلقه زدن عناصر منحصر به فرد دنباله به ترتیب مرتب شده است. ::"

#: ../../tutorial/datastructures.rst:640
msgid ""
"It is sometimes tempting to change a list while you are looping over it; "
"however, it is often simpler and safer to create a new list instead. ::"
msgstr ""
"گاهی اوقات وسوسه انگیز است که یک لیست را در حالی که در حال بررسی آن هستید "
"تغییر دهید. با این حال، ایجاد یک لیست جدید اغلب ساده تر و ایمن تر است. ::"

#: ../../tutorial/datastructures.rst:657
msgid "More on Conditions"
msgstr "بیشتر در مورد شرایط"

#: ../../tutorial/datastructures.rst:659
msgid ""
"The conditions used in ``while`` and ``if`` statements can contain any "
"operators, not just comparisons."
msgstr ""
"شرایط استفاده شده در دستورات ``while`` و ``if`` می تواند شامل هر عملگر باشد،"
" نه فقط مقایسه."

#: ../../tutorial/datastructures.rst:662
msgid ""
"The comparison operators ``in`` and ``not in`` check whether a value occurs "
"(does not occur) in a sequence.  The operators ``is`` and ``is not`` compare"
" whether two objects are really the same object.  All comparison operators "
"have the same priority, which is lower than that of all numerical operators."
msgstr ""

#: ../../tutorial/datastructures.rst:667
msgid ""
"Comparisons can be chained.  For example, ``a < b == c`` tests whether ``a``"
" is less than ``b`` and moreover ``b`` equals ``c``."
msgstr ""
"مقایسه ها را می توان زنجیره ای کرد.  به عنوان مثال، ``a < b == c`` تست می "
"کند که آیا ``a`` کمتر از ``b`` است و علاوه بر این، ``b`` برابر با ``c`` است."

#: ../../tutorial/datastructures.rst:670
msgid ""
"Comparisons may be combined using the Boolean operators ``and`` and ``or``, "
"and the outcome of a comparison (or of any other Boolean expression) may be "
"negated with ``not``.  These have lower priorities than comparison "
"operators; between them, ``not`` has the highest priority and ``or`` the "
"lowest, so that ``A and not B or C`` is equivalent to ``(A and (not B)) or "
"C``. As always, parentheses can be used to express the desired composition."
msgstr ""
"مقایسه ها ممکن است با استفاده از عملگرهای بولی ``and`` و ``or`` ترکیب شوند و"
" نتیجه مقایسه (یا هر عبارت بولی دیگر) با ``not`` نفی شود.  اینها نسبت به "
"اپراتورهای مقایسه اولویت کمتری دارند. در بین آنها ``not`` بیشترین اولویت و "
"``or`` کمترین اولویت را دارد به طوری که ``A and not B or C`` معادل ``(A and "
"(not B)) or C`` است. مثل همیشه می توان از پرانتز برای بیان ترکیب مورد نظر "
"استفاده کرد."

#: ../../tutorial/datastructures.rst:677
msgid ""
"The Boolean operators ``and`` and ``or`` are so-called *short-circuit* "
"operators: their arguments are evaluated from left to right, and evaluation "
"stops as soon as the outcome is determined.  For example, if ``A`` and ``C``"
" are true but ``B`` is false, ``A and B and C`` does not evaluate the "
"expression ``C``.  When used as a general value and not as a Boolean, the "
"return value of a short-circuit operator is the last evaluated argument."
msgstr ""
"عملگرهای Boolean ``and`` و ``or`` اصطلاحاً عملگرهای *short-circuit* هستند: "
"آرگومان های آنها از چپ به راست ارزیابی می شوند و به محض تعیین نتیجه ارزیابی "
"متوقف می شود.  به عنوان مثال، اگر ``A`` و ``C`` درست باشند اما ``B`` نادرست "
"باشد، ``A and B and C`` عبارت ``C`` را ارزیابی نمی کند.  هنگامی که به عنوان "
"یک مقدار کلی و نه به عنوان یک بولی استفاده می شود، مقدار بازگشتی یک اپراتور "
"اتصال کوتاه آخرین آرگومان ارزیابی شده است."

#: ../../tutorial/datastructures.rst:684
msgid ""
"It is possible to assign the result of a comparison or other Boolean "
"expression to a variable.  For example, ::"
msgstr ""
"می توان نتیجه یک مقایسه یا عبارت بولی دیگر را به یک متغیر اختصاص داد.  به "
"عنوان مثال، ::"

#: ../../tutorial/datastructures.rst:692
msgid ""
"Note that in Python, unlike C, assignment inside expressions must be done "
"explicitly with the :ref:`walrus operator <why-can-t-i-use-an-assignment-in-"
"an-expression>` ``:=``. This avoids a common class of problems encountered "
"in C programs: typing ``=`` in an expression when ``==`` was intended."
msgstr ""
"توجه داشته باشید که در پایتون، برخلاف C، تخصیص درون عبارات باید به طور صریح "
"با :ref:`walrus operator <why-can-t-i-use-an-assignment-in-an-expression>` "
"``:=`` انجام شود. با این کار از یک کلاس رایج از مشکلاتی که در برنامه‌های C "
"با آن مواجه می‌شوید جلوگیری می‌شود: تایپ ``=`` در یک عبارت زمانی که ``==`` "
"در نظر گرفته شده بود."

#: ../../tutorial/datastructures.rst:702
msgid "Comparing Sequences and Other Types"
msgstr "مقایسه توالی ها و انواع دیگر"

#: ../../tutorial/datastructures.rst:703
msgid ""
"Sequence objects typically may be compared to other objects with the same "
"sequence type. The comparison uses *lexicographical* ordering: first the "
"first two items are compared, and if they differ this determines the outcome"
" of the comparison; if they are equal, the next two items are compared, and "
"so on, until either sequence is exhausted. If two items to be compared are "
"themselves sequences of the same type, the lexicographical comparison is "
"carried out recursively.  If all items of two sequences compare equal, the "
"sequences are considered equal. If one sequence is an initial sub-sequence "
"of the other, the shorter sequence is the smaller (lesser) one.  "
"Lexicographical ordering for strings uses the Unicode code point number to "
"order individual characters. Some examples of comparisons between sequences "
"of the same type::"
msgstr ""
"اشیاء دنباله معمولاً ممکن است با اشیاء دیگر با همان نوع توالی مقایسه شوند. "
"مقایسه از ترتیب *lexicographical* استفاده می کند: ابتدا دو مورد اول با هم "
"مقایسه می شوند و اگر متفاوت باشند، نتیجه مقایسه را مشخص می کند. اگر مساوی "
"باشند، دو مورد بعدی با هم مقایسه می شوند، و به همین ترتیب، تا زمانی که هر یک"
" از دنباله ها تمام شود. اگر دو مورد برای مقایسه، خود توالی هایی از یک نوع "
"باشند، مقایسه واژگانی به صورت بازگشتی انجام می شود.  اگر همه آیتم های دو "
"دنباله با هم برابر باشند، دنباله ها برابر در نظر گرفته می شوند. اگر یک "
"دنباله زیر دنباله ابتدایی دیگری باشد، دنباله کوتاهتر کوچکتر (کوچکتر) است.  "
"ترتیب واژگانی رشته‌ها از شماره نقطه کد یونیکد برای مرتب کردن کاراکترها "
"استفاده می‌کند. چند نمونه از مقایسه بین دنباله هایی از یک نوع::"

#: ../../tutorial/datastructures.rst:723
msgid ""
"Note that comparing objects of different types with ``<`` or ``>`` is legal "
"provided that the objects have appropriate comparison methods.  For example,"
" mixed numeric types are compared according to their numeric value, so 0 "
"equals 0.0, etc.  Otherwise, rather than providing an arbitrary ordering, "
"the interpreter will raise a :exc:`TypeError` exception."
msgstr ""
"توجه داشته باشید که مقایسه اشیاء از انواع مختلف با ``<`` یا ``>`` قانونی است"
" مشروط بر اینکه اشیاء دارای روش های مقایسه مناسب باشند.  به عنوان مثال، "
"انواع عددی مختلط با توجه به مقدار عددی آنها مقایسه می شوند، بنابراین 0 برابر"
" با 0.0 و غیره است. در غیر این صورت، به جای ارائه یک ترتیب دلخواه، مفسر یک "
"استثنا :exc:`TypeError` را ایجاد می کند."

#: ../../tutorial/datastructures.rst:731
msgid "Footnotes"
msgstr "پاورقی ها"

#: ../../tutorial/datastructures.rst:732
msgid ""
"Other languages may return the mutated object, which allows method chaining,"
" such as ``d->insert(\"a\")->remove(\"b\")->sort();``."
msgstr ""
"زبان های دیگر ممکن است شی جهش یافته را برگردانند، که امکان زنجیره متد را "
"فراهم می کند، مانند ``d->insert(\"a\")->remove(\"b\")->sort();``."
