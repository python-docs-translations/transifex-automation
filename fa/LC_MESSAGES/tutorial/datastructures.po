# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2025
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-03-07 14:53+0000\n"
"PO-Revision-Date: 2024-05-11 00:34+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2025\n"
"Language-Team: Persian (https://app.transifex.com/python-doc/teams/5390/"
"fa/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: fa\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../tutorial/datastructures.rst:5
msgid "Data Structures"
msgstr "ساختارهای داده"

#: ../../tutorial/datastructures.rst:7
msgid ""
"This chapter describes some things you've learned about already in more "
"detail, and adds some new things as well."
msgstr ""
"این فصل برخی از چیزهایی را که قبلاً در مورد آنها آموخته اید را با جزئیات "
"بیشتر توضیح می دهد و همچنین موارد جدیدی را اضافه می کند."

#: ../../tutorial/datastructures.rst:13
msgid "More on Lists"
msgstr "اطلاعات بیشتر در مورد لیست ها"

#: ../../tutorial/datastructures.rst:15
msgid ""
"The list data type has some more methods.  Here are all of the methods of "
"list objects:"
msgstr ""
"نوع داده لیست روش های بیشتری دارد.  در اینجا همه روش های لیست اشیاء آمده است:"

#: ../../tutorial/datastructures.rst:22
msgid "Add an item to the end of the list.  Similar to ``a[len(a):] = [x]``."
msgstr "یک مورد را به انتهای لیست اضافه کنید.  مشابه ``a[len(a):] = [x]``."

#: ../../tutorial/datastructures.rst:28
msgid ""
"Extend the list by appending all the items from the iterable.  Similar to "
"``a[len(a):] = iterable``."
msgstr ""
"لیست را با اضافه کردن همه موارد از تکرار شونده گسترش دهید.  مشابه "
"``a[len(a):] = iterable``."

#: ../../tutorial/datastructures.rst:35
msgid ""
"Insert an item at a given position.  The first argument is the index of the "
"element before which to insert, so ``a.insert(0, x)`` inserts at the front "
"of the list, and ``a.insert(len(a), x)`` is equivalent to ``a.append(x)``."
msgstr ""
"یک مورد را در یک موقعیت مشخص درج کنید.  اولین آرگومان شاخص عنصری است که قبل "
"از آن درج می شود، بنابراین ``a.insert(0, x)`` در جلوی لیست قرار می گیرد و "
"``a.insert(len(a), x)`` معادل ``a.append(x)`` است."

#: ../../tutorial/datastructures.rst:43
msgid ""
"Remove the first item from the list whose value is equal to *x*.  It raises "
"a :exc:`ValueError` if there is no such item."
msgstr ""
"اولین مورد را که مقدار آن برابر با *x* است را از لیست حذف کنید.  اگر چنین "
"موردی وجود نداشته باشد، یک :exc:`ValueError` را افزایش می دهد."

#: ../../tutorial/datastructures.rst:50
msgid ""
"Remove the item at the given position in the list, and return it.  If no "
"index is specified, ``a.pop()`` removes and returns the last item in the "
"list. It raises an :exc:`IndexError` if the list is empty or the index is "
"outside the list range."
msgstr ""
"مورد را در موقعیت داده شده در لیست بردارید و آن را برگردانید.  اگر هیچ شاخصی "
"مشخص نشده باشد، ``a.pop()`` آخرین مورد از لیست را حذف کرده و برمی گرداند. "
"اگر لیست خالی باشد یا ایندکس خارج از محدوده لیست باشد، یک :exc:`IndexError` "
"را افزایش می دهد."

#: ../../tutorial/datastructures.rst:59
msgid "Remove all items from the list.  Similar to ``del a[:]``."
msgstr "تمام موارد را از لیست حذف کنید.  مشابه ``del a[:]``."

#: ../../tutorial/datastructures.rst:65
msgid ""
"Return zero-based index in the list of the first item whose value is equal "
"to *x*. Raises a :exc:`ValueError` if there is no such item."
msgstr ""
"شاخص مبتنی بر صفر را در لیست اولین موردی که مقدار آن برابر با *x* است، "
"برگردانید. اگر چنین موردی وجود نداشته باشد، یک :exc:`ValueError` را افزایش "
"می دهد."

#: ../../tutorial/datastructures.rst:68
msgid ""
"The optional arguments *start* and *end* are interpreted as in the slice "
"notation and are used to limit the search to a particular subsequence of the "
"list.  The returned index is computed relative to the beginning of the full "
"sequence rather than the *start* argument."
msgstr ""
"آرگومان های اختیاری *start* و *end* به صورت نماد برش تفسیر می شوند و برای "
"محدود کردن جستجو به دنباله خاصی از لیست استفاده می شوند.  شاخص برگشتی به جای "
"آرگومان *start* نسبت به ابتدای دنباله کامل محاسبه می شود."

#: ../../tutorial/datastructures.rst:77
msgid "Return the number of times *x* appears in the list."
msgstr "تعداد دفعاتی که *x* در لیست ظاهر می شود را برگردانید."

#: ../../tutorial/datastructures.rst:83
msgid ""
"Sort the items of the list in place (the arguments can be used for sort "
"customization, see :func:`sorted` for their explanation)."
msgstr ""
"موارد لیست را در جای خود مرتب کنید (از آرگومان ها می توان برای سفارشی سازی "
"مرتب سازی استفاده کرد, برای توضیح آنها به :func:`sorted` مراجعه کنید)."

#: ../../tutorial/datastructures.rst:90
msgid "Reverse the elements of the list in place."
msgstr "عناصر لیست را در جای خود معکوس کنید."

#: ../../tutorial/datastructures.rst:96
msgid "Return a shallow copy of the list.  Similar to ``a[:]``."
msgstr "یک کپی کم عمق از لیست را برگردانید.  مشابه ``a[:]``."

#: ../../tutorial/datastructures.rst:99
msgid "An example that uses most of the list methods::"
msgstr "مثالی که از اکثر متدهای لیست استفاده می کند:"

#: ../../tutorial/datastructures.rst:101
msgid ""
">>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', "
"'banana']\n"
">>> fruits.count('apple')\n"
"2\n"
">>> fruits.count('tangerine')\n"
"0\n"
">>> fruits.index('banana')\n"
"3\n"
">>> fruits.index('banana', 4)  # Find next banana starting at position 4\n"
"6\n"
">>> fruits.reverse()\n"
">>> fruits\n"
"['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']\n"
">>> fruits.append('grape')\n"
">>> fruits\n"
"['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']\n"
">>> fruits.sort()\n"
">>> fruits\n"
"['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']\n"
">>> fruits.pop()\n"
"'pear'"
msgstr ""
">>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', "
"'banana']\n"
">>> fruits.count('apple')\n"
"2\n"
">>> fruits.count('tangerine')\n"
"0\n"
">>> fruits.index('banana')\n"
"3\n"
">>> fruits.index('banana', 4)  # Find next banana starting at position 4\n"
"6\n"
">>> fruits.reverse()\n"
">>> fruits\n"
"['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']\n"
">>> fruits.append('grape')\n"
">>> fruits\n"
"['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']\n"
">>> fruits.sort()\n"
">>> fruits\n"
"['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']\n"
">>> fruits.pop()\n"
"'pear'"

#: ../../tutorial/datastructures.rst:122
msgid ""
"You might have noticed that methods like ``insert``, ``remove`` or ``sort`` "
"that only modify the list have no return value printed -- they return the "
"default ``None``. [#]_  This is a design principle for all mutable data "
"structures in Python."
msgstr ""
"شاید متوجه شده باشید که روش‌هایی مانند ``insert``، ``remove`` یا ``sort`` که "
"فقط فهرست را اصلاح می‌کنند، هیچ مقدار بازگشتی چاپ نشده‌اند -- آنها ``None`` "
"پیش‌فرض را برمی‌گردانند. [#]_ این یک اصل طراحی برای تمام ساختارهای داده قابل "
"تغییر در پایتون است."

#: ../../tutorial/datastructures.rst:127
msgid ""
"Another thing you might notice is that not all data can be sorted or "
"compared.  For instance, ``[None, 'hello', 10]`` doesn't sort because "
"integers can't be compared to strings and ``None`` can't be compared to "
"other types.  Also, there are some types that don't have a defined ordering "
"relation.  For example, ``3+4j < 5+7j`` isn't a valid comparison."
msgstr ""
"نکته دیگری که ممکن است متوجه شوید این است که همه داده ها را نمی توان مرتب "
"کرد یا مقایسه کرد.  به عنوان مثال، ``[None, 'hello', 10]`` مرتب سازی نمی کند "
"زیرا اعداد صحیح را نمی توان با رشته ها مقایسه کرد و ``None`` را نمی توان با "
"انواع دیگر مقایسه کرد.  همچنین، برخی از انواع وجود دارند که رابطه سفارشی "
"مشخصی ندارند.  برای مثال، ``3+4j < 5+7j`` مقایسه معتبری نیست."

#: ../../tutorial/datastructures.rst:138
msgid "Using Lists as Stacks"
msgstr "استفاده از لیست ها به عنوان پشته"

#: ../../tutorial/datastructures.rst:143
msgid ""
"The list methods make it very easy to use a list as a stack, where the last "
"element added is the first element retrieved (\"last-in, first-out\").  To "
"add an item to the top of the stack, use :meth:`!append`.  To retrieve an "
"item from the top of the stack, use :meth:`!pop` without an explicit index.  "
"For example::"
msgstr ""
"روش های لیست استفاده از یک لیست را به عنوان پشته بسیار آسان می کند، جایی که "
"آخرین عنصر اضافه شده، اولین عنصر بازیابی شده است (\"آخرین ورود, اولین "
"خروج\").  برای افزودن یک آیتم به بالای پشته، از :meth:`!append` استفاده "
"کنید.  برای بازیابی یک آیتم از بالای پشته، از :meth:`!pop` بدون ایندکس صریح "
"استفاده کنید.  به عنوان مثال::"

#: ../../tutorial/datastructures.rst:148
msgid ""
">>> stack = [3, 4, 5]\n"
">>> stack.append(6)\n"
">>> stack.append(7)\n"
">>> stack\n"
"[3, 4, 5, 6, 7]\n"
">>> stack.pop()\n"
"7\n"
">>> stack\n"
"[3, 4, 5, 6]\n"
">>> stack.pop()\n"
"6\n"
">>> stack.pop()\n"
"5\n"
">>> stack\n"
"[3, 4]"
msgstr ""
">>> stack = [3, 4, 5]\n"
">>> stack.append(6)\n"
">>> stack.append(7)\n"
">>> stack\n"
"[3, 4, 5, 6, 7]\n"
">>> stack.pop()\n"
"7\n"
">>> stack\n"
"[3, 4, 5, 6]\n"
">>> stack.pop()\n"
"6\n"
">>> stack.pop()\n"
"5\n"
">>> stack\n"
"[3, 4]"

#: ../../tutorial/datastructures.rst:168
msgid "Using Lists as Queues"
msgstr "استفاده از لیست ها به عنوان صف"

#: ../../tutorial/datastructures.rst:172
msgid ""
"It is also possible to use a list as a queue, where the first element added "
"is the first element retrieved (\"first-in, first-out\"); however, lists are "
"not efficient for this purpose.  While appends and pops from the end of list "
"are fast, doing inserts or pops from the beginning of a list is slow "
"(because all of the other elements have to be shifted by one)."
msgstr ""
"همچنین می توان از یک لیست به عنوان صف استفاده کرد، که در آن اولین عنصر اضافه "
"شده، اولین عنصر بازیابی شده است (\"first-in, first-out\"). با این حال، لیست "
"ها برای این منظور کارآمد نیستند.  در حالی که ضمیمه‌ها و پاپ‌ها از انتهای فهرست "
"سریع هستند، انجام درج‌ها یا پاپ‌ها از ابتدای فهرست به کندی انجام می‌شود (زیرا "
"همه عناصر دیگر باید با یک جابجا شوند)."

#: ../../tutorial/datastructures.rst:178
msgid ""
"To implement a queue, use :class:`collections.deque` which was designed to "
"have fast appends and pops from both ends.  For example::"
msgstr ""
"برای پیاده سازی یک صف، از :class:`collections.deque` استفاده کنید که به گونه "
"ای طراحی شده است که دارای ضمائم سریع و پاپ از هر دو طرف باشد.  به عنوان "
"مثال::"

#: ../../tutorial/datastructures.rst:181
msgid ""
">>> from collections import deque\n"
">>> queue = deque([\"Eric\", \"John\", \"Michael\"])\n"
">>> queue.append(\"Terry\")           # Terry arrives\n"
">>> queue.append(\"Graham\")          # Graham arrives\n"
">>> queue.popleft()                 # The first to arrive now leaves\n"
"'Eric'\n"
">>> queue.popleft()                 # The second to arrive now leaves\n"
"'John'\n"
">>> queue                           # Remaining queue in order of arrival\n"
"deque(['Michael', 'Terry', 'Graham'])"
msgstr ""
">>> from collections import deque\n"
">>> queue = deque([\"Eric\", \"John\", \"Michael\"])\n"
">>> queue.append(\"Terry\")           # Terry arrives\n"
">>> queue.append(\"Graham\")          # Graham arrives\n"
">>> queue.popleft()                 # The first to arrive now leaves\n"
"'Eric'\n"
">>> queue.popleft()                 # The second to arrive now leaves\n"
"'John'\n"
">>> queue                           # Remaining queue in order of arrival\n"
"deque(['Michael', 'Terry', 'Graham'])"

#: ../../tutorial/datastructures.rst:196
msgid "List Comprehensions"
msgstr "فهرست درک"

#: ../../tutorial/datastructures.rst:198
msgid ""
"List comprehensions provide a concise way to create lists. Common "
"applications are to make new lists where each element is the result of some "
"operations applied to each member of another sequence or iterable, or to "
"create a subsequence of those elements that satisfy a certain condition."
msgstr ""
"درک فهرست ها راهی مختصر برای ایجاد لیست ها فراهم می کند. برنامه های رایج "
"عبارتند از ایجاد لیست های جدید که در آن هر عنصر نتیجه برخی از عملیات اعمال "
"شده بر روی هر یک از اعضای یک دنباله دیگر یا قابل تکرار است، یا ایجاد دنباله "
"ای از آن عناصر که شرایط خاصی را برآورده می کند."

#: ../../tutorial/datastructures.rst:203
msgid "For example, assume we want to create a list of squares, like::"
msgstr "به عنوان مثال، فرض کنید می خواهیم لیستی از مربع ها ایجاد کنیم، مانند:"

#: ../../tutorial/datastructures.rst:205
msgid ""
">>> squares = []\n"
">>> for x in range(10):\n"
"...     squares.append(x**2)\n"
"...\n"
">>> squares\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]"
msgstr ""
">>> squares = []\n"
">>> for x in range(10):\n"
"...     squares.append(x**2)\n"
"...\n"
">>> squares\n"
"[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]"

#: ../../tutorial/datastructures.rst:212
msgid ""
"Note that this creates (or overwrites) a variable named ``x`` that still "
"exists after the loop completes.  We can calculate the list of squares "
"without any side effects using::"
msgstr ""
"توجه داشته باشید که با این کار متغیری به نام ``x`` ایجاد می شود (یا بازنویسی "
"می شود) که پس از اتمام حلقه همچنان وجود دارد.  ما می توانیم لیست مربع ها را "
"بدون هیچ گونه عوارض جانبی با استفاده از:"

#: ../../tutorial/datastructures.rst:216
msgid "squares = list(map(lambda x: x**2, range(10)))"
msgstr "squares = list(map(lambda x: x**2, range(10)))"

#: ../../tutorial/datastructures.rst:218
msgid "or, equivalently::"
msgstr "یا به طور معادل::"

#: ../../tutorial/datastructures.rst:220
msgid "squares = [x**2 for x in range(10)]"
msgstr "squares = [x**2 for x in range(10)]"

#: ../../tutorial/datastructures.rst:222
msgid "which is more concise and readable."
msgstr "که مختصرتر و خواندنی تر است."

#: ../../tutorial/datastructures.rst:224
msgid ""
"A list comprehension consists of brackets containing an expression followed "
"by a :keyword:`!for` clause, then zero or more :keyword:`!for` or :keyword:`!"
"if` clauses.  The result will be a new list resulting from evaluating the "
"expression in the context of the :keyword:`!for` and :keyword:`!if` clauses "
"which follow it. For example, this listcomp combines the elements of two "
"lists if they are not equal::"
msgstr ""
"درک لیست شامل براکت هایی است که شامل عبارتی به دنبال آن یک بند :keyword:`!"
"for` و سپس صفر یا بیشتر عبارت :keyword:`!for` یا :keyword:`!if` است.  نتیجه "
"یک لیست جدید خواهد بود که از ارزیابی عبارت در متن بندهای :keyword:`!for` و :"
"keyword:`!if` حاصل می شود. به عنوان مثال، این listcomp عناصر دو لیست را در "
"صورتی که برابر نباشند ترکیب می کند:"

#: ../../tutorial/datastructures.rst:231
msgid ""
">>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]\n"
"[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"
msgstr ""
">>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]\n"
"[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"

#: ../../tutorial/datastructures.rst:234
msgid "and it's equivalent to::"
msgstr "و معادل است با::"

#: ../../tutorial/datastructures.rst:236
msgid ""
">>> combs = []\n"
">>> for x in [1,2,3]:\n"
"...     for y in [3,1,4]:\n"
"...         if x != y:\n"
"...             combs.append((x, y))\n"
"...\n"
">>> combs\n"
"[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"
msgstr ""
">>> combs = []\n"
">>> for x in [1,2,3]:\n"
"...     for y in [3,1,4]:\n"
"...         if x != y:\n"
"...             combs.append((x, y))\n"
"...\n"
">>> combs\n"
"[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]"

#: ../../tutorial/datastructures.rst:245
msgid ""
"Note how the order of the :keyword:`for` and :keyword:`if` statements is the "
"same in both these snippets."
msgstr ""
"توجه داشته باشید که چگونه ترتیب دستورات :keyword:`for` و :keyword:`if` در هر "
"دو قطعه یکسان است."

#: ../../tutorial/datastructures.rst:248
msgid ""
"If the expression is a tuple (e.g. the ``(x, y)`` in the previous example), "
"it must be parenthesized. ::"
msgstr ""
"اگر عبارت یک تاپلی باشد (مثلاً ``(x, y)`` در مثال قبلی), باید پرانتز شود. ::"

#: ../../tutorial/datastructures.rst:251
msgid ""
">>> vec = [-4, -2, 0, 2, 4]\n"
">>> # create a new list with the values doubled\n"
">>> [x*2 for x in vec]\n"
"[-8, -4, 0, 4, 8]\n"
">>> # filter the list to exclude negative numbers\n"
">>> [x for x in vec if x >= 0]\n"
"[0, 2, 4]\n"
">>> # apply a function to all the elements\n"
">>> [abs(x) for x in vec]\n"
"[4, 2, 0, 2, 4]\n"
">>> # call a method on each element\n"
">>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']\n"
">>> [weapon.strip() for weapon in freshfruit]\n"
"['banana', 'loganberry', 'passion fruit']\n"
">>> # create a list of 2-tuples like (number, square)\n"
">>> [(x, x**2) for x in range(6)]\n"
"[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]\n"
">>> # the tuple must be parenthesized, otherwise an error is raised\n"
">>> [x, x**2 for x in range(6)]\n"
"  File \"<stdin>\", line 1\n"
"    [x, x**2 for x in range(6)]\n"
"     ^^^^^^^\n"
"SyntaxError: did you forget parentheses around the comprehension target?\n"
">>> # flatten a list using a listcomp with two 'for'\n"
">>> vec = [[1,2,3], [4,5,6], [7,8,9]]\n"
">>> [num for elem in vec for num in elem]\n"
"[1, 2, 3, 4, 5, 6, 7, 8, 9]"
msgstr ""
">>> vec = [-4, -2, 0, 2, 4]\n"
">>> # یک لیست جدید با مقادیر دو برابر شده ایجاد کنید\n"
">>> [x*2 for x in vec]\n"
"[-8, -4, 0, 4, 8]\n"
">>> # filter the list to exclude negative numbers\n"
">>> [x for x in vec if x >= 0]\n"
"[0, 2, 4]\n"
">>> # apply a function to all the elements\n"
">>> [abs(x) for x in vec]\n"
"[4, 2, 0, 2, 4]\n"
">>> # call a method on each element\n"
">>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']\n"
">>> [weapon.strip() for weapon in freshfruit]\n"
"['banana', 'loganberry', 'passion fruit']\n"
">>> # create a list of 2-tuples like (number, square)\n"
">>> [(x, x**2) for x in range(6)]\n"
"[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]\n"
">>> # the tuple must be parenthesized, otherwise an error is raised\n"
">>> [x, x**2 for x in range(6)]\n"
"  File \"<stdin>\", line 1\n"
"    [x, x**2 برای x در محدوده (6)]\n"
"     ^^^^^^^\n"
"SyntaxError: آیا پرانتزهای اطراف هدف درک مطلب را فراموش کرده اید؟\n"
">>> # یک لیست را با استفاده از یک listcomp با دو \"برای\" مسطح کنید\n"
">>> vec = [[1,2,3], [4,5,6], [7,8,9]]\n"
">>> [num برای elem در vec برای num in elem]\n"
"[1, 2, 3, 4, 5, 6, 7, 8, 9]"

#: ../../tutorial/datastructures.rst:279
msgid ""
"List comprehensions can contain complex expressions and nested functions::"
msgstr "درک لیست می تواند شامل عبارات پیچیده و توابع تو در تو باشد:"

#: ../../tutorial/datastructures.rst:281
msgid ""
">>> from math import pi\n"
">>> [str(round(pi, i)) for i in range(1, 6)]\n"
"['3.1', '3.14', '3.142', '3.1416', '3.14159']"
msgstr ""
">>> from math import pi\n"
">>> [str(round(pi, i)) for i in range(1, 6)]\n"
"['3.1', '3.14', '3.142', '3.1416', '3.14159']"

#: ../../tutorial/datastructures.rst:286
msgid "Nested List Comprehensions"
msgstr "درک لیست تودرتو"

#: ../../tutorial/datastructures.rst:288
msgid ""
"The initial expression in a list comprehension can be any arbitrary "
"expression, including another list comprehension."
msgstr ""
"عبارت اولیه در درک لیست می تواند هر عبارت دلخواه، از جمله درک لیست دیگری "
"باشد."

#: ../../tutorial/datastructures.rst:291
msgid ""
"Consider the following example of a 3x4 matrix implemented as a list of 3 "
"lists of length 4::"
msgstr ""
"مثال زیر را از یک ماتریس 3x4 در نظر بگیرید که به صورت لیستی از 3 لیست با طول "
"4 پیاده سازی شده است:"

#: ../../tutorial/datastructures.rst:294
msgid ""
">>> matrix = [\n"
"...     [1, 2, 3, 4],\n"
"...     [5, 6, 7, 8],\n"
"...     [9, 10, 11, 12],\n"
"... ]"
msgstr ""
">>> matrix = [\n"
"...     [1, 2, 3, 4],\n"
"...     [5, 6, 7, 8],\n"
"...     [9, 10, 11, 12],\n"
"... ]"

#: ../../tutorial/datastructures.rst:300
msgid "The following list comprehension will transpose rows and columns::"
msgstr "درک لیست زیر سطرها و ستون ها را جابجا می کند:"

#: ../../tutorial/datastructures.rst:302
msgid ""
">>> [[row[i] for row in matrix] for i in range(4)]\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"
msgstr ""
">>> [[row[i] for row in matrix] for i in range(4)]\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"

#: ../../tutorial/datastructures.rst:305
msgid ""
"As we saw in the previous section, the inner list comprehension is evaluated "
"in the context of the :keyword:`for` that follows it, so this example is "
"equivalent to::"
msgstr ""
"همانطور که در بخش قبل دیدیم، درک فهرست داخلی در زمینه :keyword:`for` که به "
"دنبال آن است، ارزیابی می شود، بنابراین این مثال معادل:"

#: ../../tutorial/datastructures.rst:309
msgid ""
">>> transposed = []\n"
">>> for i in range(4):\n"
"...     transposed.append([row[i] for row in matrix])\n"
"...\n"
">>> transposed\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"
msgstr ""
">>> transposed = []\n"
">>> for i in range(4):\n"
"...     transposed.append([row[i] for row in matrix])\n"
"...\n"
">>> transposed\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"

#: ../../tutorial/datastructures.rst:316
msgid "which, in turn, is the same as::"
msgstr "که به نوبه خود همان است که:"

#: ../../tutorial/datastructures.rst:318
msgid ""
">>> transposed = []\n"
">>> for i in range(4):\n"
"...     # the following 3 lines implement the nested listcomp\n"
"...     transposed_row = []\n"
"...     for row in matrix:\n"
"...         transposed_row.append(row[i])\n"
"...     transposed.append(transposed_row)\n"
"...\n"
">>> transposed\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"
msgstr ""
">>> transposed = []\n"
">>> for i in range(4):\n"
"...     # the following 3 lines implement the nested listcomp\n"
"...     transposed_row = []\n"
"...     for row in matrix:\n"
"...         transposed_row.append(row[i])\n"
"...     transposed.append(transposed_row)\n"
"...\n"
">>> transposed\n"
"[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]"

#: ../../tutorial/datastructures.rst:329
msgid ""
"In the real world, you should prefer built-in functions to complex flow "
"statements. The :func:`zip` function would do a great job for this use case::"
msgstr ""
"در دنیای واقعی، شما باید توابع داخلی را به دستورات جریان پیچیده ترجیح دهید. "
"تابع :func:`zip` کار بسیار خوبی برای این مورد استفاده می کند:"

#: ../../tutorial/datastructures.rst:332
msgid ""
">>> list(zip(*matrix))\n"
"[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]"
msgstr ""
">>> list(zip(*matrix))\n"
"[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]"

#: ../../tutorial/datastructures.rst:335
msgid ""
"See :ref:`tut-unpacking-arguments` for details on the asterisk in this line."
msgstr ""
"برای جزئیات بیشتر در مورد ستاره در این خط به :ref:`tut-unpacking-arguments` "
"مراجعه کنید."

#: ../../tutorial/datastructures.rst:340
msgid "The :keyword:`!del` statement"
msgstr "بیانیه :keyword:`!del`"

#: ../../tutorial/datastructures.rst:342
msgid ""
"There is a way to remove an item from a list given its index instead of its "
"value: the :keyword:`del` statement.  This differs from the :meth:`!pop` "
"method which returns a value.  The :keyword:`!del` statement can also be "
"used to remove slices from a list or clear the entire list (which we did "
"earlier by assignment of an empty list to the slice).  For example::"
msgstr ""
"راهی برای حذف یک آیتم از فهرست با توجه به شاخص آن به جای مقدار آن وجود دارد: "
"عبارت :keyword:`del`.  این با روش :meth:`!pop` که مقداری را برمی گرداند "
"متفاوت است.  دستور :keyword:`!del` همچنین می تواند برای حذف برش ها از یک "
"لیست یا پاک کردن کل لیست استفاده شود (که قبلاً با اختصاص یک لیست خالی به برش "
"انجام دادیم).  به عنوان مثال::"

#: ../../tutorial/datastructures.rst:348
msgid ""
">>> a = [-1, 1, 66.25, 333, 333, 1234.5]\n"
">>> del a[0]\n"
">>> a\n"
"[1, 66.25, 333, 333, 1234.5]\n"
">>> del a[2:4]\n"
">>> a\n"
"[1, 66.25, 1234.5]\n"
">>> del a[:]\n"
">>> a\n"
"[]"
msgstr ""
">>> a = [-1, 1, 66.25, 333, 333, 1234.5]\n"
">>> del a[0]\n"
">>> a\n"
"[1, 66.25, 333, 333, 1234.5]\n"
">>> del a[2:4]\n"
">>> a\n"
"[1, 66.25, 1234.5]\n"
">>> del a[:]\n"
">>> a\n"
"[]"

#: ../../tutorial/datastructures.rst:359
msgid ":keyword:`del` can also be used to delete entire variables::"
msgstr ":keyword:`del` همچنین می تواند برای حذف کل متغیرها استفاده شود:"

#: ../../tutorial/datastructures.rst:361
msgid ">>> del a"
msgstr ">>> del a"

#: ../../tutorial/datastructures.rst:363
msgid ""
"Referencing the name ``a`` hereafter is an error (at least until another "
"value is assigned to it).  We'll find other uses for :keyword:`del` later."
msgstr ""
"ارجاع به نام ``a`` از این پس یک خطا است (حداقل تا زمانی که مقدار دیگری به آن "
"اختصاص داده شود).  ما بعداً کاربردهای دیگری برای :keyword:`del` پیدا خواهیم "
"کرد."

#: ../../tutorial/datastructures.rst:370
msgid "Tuples and Sequences"
msgstr "Tuples and Sequences"

#: ../../tutorial/datastructures.rst:372
msgid ""
"We saw that lists and strings have many common properties, such as indexing "
"and slicing operations.  They are two examples of *sequence* data types "
"(see :ref:`typesseq`).  Since Python is an evolving language, other sequence "
"data types may be added.  There is also another standard sequence data type: "
"the *tuple*."
msgstr ""
"دیدیم که لیست‌ها و رشته‌ها ویژگی‌های مشترک زیادی دارند، مانند عملیات فهرست‌سازی "
"و برش.  آنها دو نمونه از انواع داده *sequence* هستند (به :ref:`typesseq` "
"مراجعه کنید).  از آنجایی که پایتون یک زبان در حال تکامل است، ممکن است انواع "
"داده های توالی دیگری اضافه شود.  نوع داده توالی استاندارد دیگری نیز وجود "
"دارد: *tuple*."

#: ../../tutorial/datastructures.rst:378
msgid ""
"A tuple consists of a number of values separated by commas, for instance::"
msgstr ""
"یک تاپل از تعدادی مقدار تشکیل شده است که با کاما از هم جدا شده اند، به عنوان "
"مثال:"

#: ../../tutorial/datastructures.rst:380
msgid ""
">>> t = 12345, 54321, 'hello!'\n"
">>> t[0]\n"
"12345\n"
">>> t\n"
"(12345, 54321, 'hello!')\n"
">>> # Tuples may be nested:\n"
">>> u = t, (1, 2, 3, 4, 5)\n"
">>> u\n"
"((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))\n"
">>> # Tuples are immutable:\n"
">>> t[0] = 88888\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"TypeError: 'tuple' object does not support item assignment\n"
">>> # but they can contain mutable objects:\n"
">>> v = ([1, 2, 3], [3, 2, 1])\n"
">>> v\n"
"([1, 2, 3], [3, 2, 1])"
msgstr ""
">>> t = 12345, 54321, 'سلام!'\n"
">>> t[0]\n"
"12345\n"
">>> ت\n"
"(12345, 54321, 'سلام!')\n"
">>> # تاپل ممکن است تو در تو باشد:\n"
">>> u = t, (1, 2, 3, 4, 5)\n"
">>> تو\n"
"((12345, 54321, 'سلام!')، (1, 2, 3, 4, 5))\n"
">>> # تاپل تغییرناپذیر است:\n"
">>> t[0] = 88888\n"
"ردیابی (آخرین تماس اخیر):\n"
"  فایل \"<stdin>\", خط 1، در <module>\n"
"TypeError: شیء 'tuple' از انتساب آیتم پشتیبانی نمی کند\n"
">>> # اما می توانند شامل اشیاء قابل تغییر باشند:\n"
">>> v = ([1, 2, 3], [3, 2, 1])\n"
">>> v\n"
"([1, 2, 3], [3, 2, 1])"

#: ../../tutorial/datastructures.rst:400
msgid ""
"As you see, on output tuples are always enclosed in parentheses, so that "
"nested tuples are interpreted correctly; they may be input with or without "
"surrounding parentheses, although often parentheses are necessary anyway (if "
"the tuple is part of a larger expression).  It is not possible to assign to "
"the individual items of a tuple, however it is possible to create tuples "
"which contain mutable objects, such as lists."
msgstr ""
"همانطور که می بینید، تاپل های خروجی همیشه در داخل پرانتز قرار می گیرند، به "
"طوری که تاپل های تو در تو به درستی تفسیر می شوند. آنها ممکن است با یا بدون "
"پرانتزهای اطراف وارد شوند، اگرچه اغلب پرانتزها به هر حال ضروری هستند (اگر "
"تاپل بخشی از یک عبارت بزرگتر باشد).  نمی‌توان به تک تک آیتم‌های یک تاپل اختصاص "
"داد، با این حال می‌توان تاپل‌هایی ایجاد کرد که حاوی اشیاء قابل تغییر، مانند "
"لیست‌ها هستند."

#: ../../tutorial/datastructures.rst:407
msgid ""
"Though tuples may seem similar to lists, they are often used in different "
"situations and for different purposes. Tuples are :term:`immutable`, and "
"usually contain a heterogeneous sequence of elements that are accessed via "
"unpacking (see later in this section) or indexing (or even by attribute in "
"the case of :func:`namedtuples <collections.namedtuple>`). Lists are :term:"
"`mutable`, and their elements are usually homogeneous and are accessed by "
"iterating over the list."
msgstr ""
"اگرچه تاپل ها ممکن است شبیه به لیست ها به نظر برسند، اما اغلب در موقعیت های "
"مختلف و برای اهداف مختلف استفاده می شوند. تاپل ها :term:`immutable` هستند و "
"معمولاً شامل یک توالی ناهمگن از عناصر هستند که از طریق باز کردن بسته بندی (به "
"بعد در این بخش مراجعه کنید) یا نمایه سازی (یا حتی با ویژگی در مورد :func:"
"`namedtuples <collections.namedtuple>`) قابل دسترسی هستند. لیست ها :term:"
"`mutable` هستند و عناصر آنها معمولاً همگن هستند و با تکرار در لیست قابل "
"دسترسی هستند."

#: ../../tutorial/datastructures.rst:415
msgid ""
"A special problem is the construction of tuples containing 0 or 1 items: the "
"syntax has some extra quirks to accommodate these.  Empty tuples are "
"constructed by an empty pair of parentheses; a tuple with one item is "
"constructed by following a value with a comma (it is not sufficient to "
"enclose a single value in parentheses). Ugly, but effective.  For example::"
msgstr ""
"یک مشکل خاص ساخت تاپل هایی است که حاوی 0 یا 1 آیتم هستند: نحو دارای برخی "
"ویژگی های عجیب و غریب برای جا دادن این موارد است.  تاپل های خالی با یک جفت "
"پرانتز خالی ساخته می شوند. یک تاپل با یک آیتم با دنبال کردن یک مقدار با کاما "
"ساخته می‌شود (اینکه یک مقدار را در پرانتز قرار دهید کافی نیست). زشت، اما "
"موثر.  به عنوان مثال::"

#: ../../tutorial/datastructures.rst:421
msgid ""
">>> empty = ()\n"
">>> singleton = 'hello',    # <-- note trailing comma\n"
">>> len(empty)\n"
"0\n"
">>> len(singleton)\n"
"1\n"
">>> singleton\n"
"('hello',)"
msgstr ""
">>> empty = ()\n"
">>> singleton = 'hello',    # <-- note trailing comma\n"
">>> len(empty)\n"
"0\n"
">>> len(singleton)\n"
"1\n"
">>> singleton\n"
"('hello',)"

#: ../../tutorial/datastructures.rst:430
msgid ""
"The statement ``t = 12345, 54321, 'hello!'`` is an example of *tuple "
"packing*: the values ``12345``, ``54321`` and ``'hello!'`` are packed "
"together in a tuple. The reverse operation is also possible::"
msgstr ""
"عبارت ``t = 12345, 54321, 'hello!'`` نمونه ای از *tuple packing* است: مقادیر "
"``12345``، ``54321`` و ``'hello!'`` در یک تاپیک با هم بسته بندی شده اند. "
"عملیات معکوس نیز امکان پذیر است:"

#: ../../tutorial/datastructures.rst:434
msgid ">>> x, y, z = t"
msgstr ">>> x, y, z = t"

#: ../../tutorial/datastructures.rst:436
msgid ""
"This is called, appropriately enough, *sequence unpacking* and works for any "
"sequence on the right-hand side.  Sequence unpacking requires that there are "
"as many variables on the left side of the equals sign as there are elements "
"in the sequence.  Note that multiple assignment is really just a combination "
"of tuple packing and sequence unpacking."
msgstr ""
"این به اندازه کافی *sequence unpacking* نامیده می شود و برای هر دنباله ای در "
"سمت راست کار می کند.  باز کردن توالی مستلزم آن است که به تعداد عناصر موجود "
"در دنباله، در سمت چپ علامت تساوی متغیر وجود داشته باشد.  توجه داشته باشید که "
"تخصیص چندگانه در واقع فقط ترکیبی از بسته بندی چندگانه و باز کردن توالی است."

#: ../../tutorial/datastructures.rst:446
msgid "Sets"
msgstr "مجموعه ها"

#: ../../tutorial/datastructures.rst:448
msgid ""
"Python also includes a data type for *sets*.  A set is an unordered "
"collection with no duplicate elements.  Basic uses include membership "
"testing and eliminating duplicate entries.  Set objects also support "
"mathematical operations like union, intersection, difference, and symmetric "
"difference."
msgstr ""
"پایتون همچنین شامل یک نوع داده برای *sets* است.  مجموعه یک مجموعه نامرتب و "
"بدون عناصر تکراری است.  کاربردهای اصلی شامل تست عضویت و حذف ورودی های تکراری "
"است.  اشیاء مجموعه همچنین از عملیات ریاضی مانند اتحاد، تقاطع، تفاوت و تفاوت "
"متقارن پشتیبانی می کنند."

#: ../../tutorial/datastructures.rst:453
msgid ""
"Curly braces or the :func:`set` function can be used to create sets.  Note: "
"to create an empty set you have to use ``set()``, not ``{}``; the latter "
"creates an empty dictionary, a data structure that we discuss in the next "
"section."
msgstr ""
"برای ایجاد مجموعه می توان از بریس های فرفری یا تابع :func:`set` استفاده "
"کرد.  توجه: برای ایجاد یک مجموعه خالی باید از ``set()`` استفاده کنید نه ``{}"
"``. دومی یک فرهنگ لغت خالی ایجاد می کند، یک ساختار داده که در بخش بعدی به آن "
"می پردازیم."

#: ../../tutorial/datastructures.rst:457
msgid "Here is a brief demonstration::"
msgstr "در اینجا یک نمایش کوتاه وجود دارد:"

#: ../../tutorial/datastructures.rst:459
msgid ""
">>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}\n"
">>> print(basket)                      # show that duplicates have been "
"removed\n"
"{'orange', 'banana', 'pear', 'apple'}\n"
">>> 'orange' in basket                 # fast membership testing\n"
"True\n"
">>> 'crabgrass' in basket\n"
"False\n"
"\n"
">>> # Demonstrate set operations on unique letters from two words\n"
">>>\n"
">>> a = set('abracadabra')\n"
">>> b = set('alacazam')\n"
">>> a                                  # unique letters in a\n"
"{'a', 'r', 'b', 'c', 'd'}\n"
">>> a - b                              # letters in a but not in b\n"
"{'r', 'd', 'b'}\n"
">>> a | b                              # letters in a or b or both\n"
"{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}\n"
">>> a & b                              # letters in both a and b\n"
"{'a', 'c'}\n"
">>> a ^ b                              # letters in a or b but not both\n"
"{'r', 'd', 'b', 'm', 'z', 'l'}"
msgstr ""
">>> سبد = {'سیب', 'پرتقال', 'سیب', 'گلابی', 'پرتقال', 'موز'}\n"
">>> print(basket) # نشان می دهد که موارد تکراری حذف شده اند\n"
"{'پرتقال', 'موز', 'گلابی', 'سیب'}\n"
">>> 'نارنجی' در سبد # تست عضویت سریع\n"
"درست است\n"
">>> 'خرچنگ' در سبد\n"
"نادرست\n"
"\n"
">>> # عملیات مجموعه را روی حروف منحصر به فرد از دو کلمه نشان دهید\n"
">>>\n"
">>> a = مجموعه ('abracadabra')\n"
">>> b = مجموعه ('alacazam')\n"
">>> یک # حرف منحصر به فرد در a\n"
"{'a', 'r', 'b', 'c', 'd'}\n"
">>> a - b # حرف در a اما نه در b\n"
"{'r', 'd', 'b'}\n"
">>> یک | b # حروف در a یا b یا هر دو\n"
"{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}\n"
">>> a & b # حروف در هر دو a و b\n"
"{'a', 'c'}\n"
">>> a ^ b # حروف a یا b اما نه هر دو\n"
"{'r', 'd', 'b', 'm', 'z', 'l'}"

#: ../../tutorial/datastructures.rst:482
msgid ""
"Similarly to :ref:`list comprehensions <tut-listcomps>`, set comprehensions "
"are also supported::"
msgstr ""
"مانند :ref:`list comprehensions <tut-listcomps>`، درک مجموعه نیز پشتیبانی می "
"شود:"

#: ../../tutorial/datastructures.rst:485
msgid ""
">>> a = {x for x in 'abracadabra' if x not in 'abc'}\n"
">>> a\n"
"{'r', 'd'}"
msgstr ""
">>> a = {x for x in 'abracadabra' if x not in 'abc'}\n"
">>> a\n"
"{'r', 'd'}"

#: ../../tutorial/datastructures.rst:493
msgid "Dictionaries"
msgstr "لغت نامه ها"

#: ../../tutorial/datastructures.rst:495
msgid ""
"Another useful data type built into Python is the *dictionary* (see :ref:"
"`typesmapping`). Dictionaries are sometimes found in other languages as "
"\"associative memories\" or \"associative arrays\".  Unlike sequences, which "
"are indexed by a range of numbers, dictionaries are indexed by *keys*, which "
"can be any immutable type; strings and numbers can always be keys.  Tuples "
"can be used as keys if they contain only strings, numbers, or tuples; if a "
"tuple contains any mutable object either directly or indirectly, it cannot "
"be used as a key. You can't use lists as keys, since lists can be modified "
"in place using index assignments, slice assignments, or methods like :meth:`!"
"append` and :meth:`!extend`."
msgstr ""
"نوع داده مفید دیگری که در پایتون تعبیه شده است، *dictionary* است (به :ref:"
"`typesmapping` مراجعه کنید). واژه‌نامه‌ها گاهی در زبان‌های دیگر به‌عنوان «خاطرات "
"انجمنی» یا «آرایه‌های انجمنی» یافت می‌شوند.  بر خلاف دنباله‌ها که با طیفی از "
"اعداد نمایه می‌شوند، لغتنامه‌ها با *keys* نمایه می‌شوند که می‌تواند هر نوع "
"تغییرناپذیری باشد. رشته ها و اعداد همیشه می توانند کلید باشند.  اگر تاپل ها "
"فقط شامل رشته ها، اعداد یا تاپل ها باشند، می توانند به عنوان کلید استفاده "
"شوند. اگر یک تاپل حاوی هر شیء قابل تغییر به طور مستقیم یا غیر مستقیم باشد، "
"نمی توان از آن به عنوان کلید استفاده کرد. نمی‌توانید از فهرست‌ها به عنوان کلید "
"استفاده کنید، زیرا فهرست‌ها را می‌توان با استفاده از تخصیص فهرست، تخصیص برش یا "
"روش‌هایی مانند :meth:`!append` و :meth:`!extend` تغییر داد."

#: ../../tutorial/datastructures.rst:506
msgid ""
"It is best to think of a dictionary as a set of *key: value* pairs, with the "
"requirement that the keys are unique (within one dictionary). A pair of "
"braces creates an empty dictionary: ``{}``. Placing a comma-separated list "
"of key:value pairs within the braces adds initial key:value pairs to the "
"dictionary; this is also the way dictionaries are written on output."
msgstr ""
"بهتر است دیکشنری را مجموعه‌ای از جفت‌های *key: value* در نظر بگیرید، با این "
"شرط که کلیدها منحصر به فرد باشند (در یک فرهنگ لغت). یک جفت بریس یک فرهنگ لغت "
"خالی ایجاد می کند: ``{}``. قرار دادن یک لیست جدا شده با کاما از جفت های کلید:"
"مقدار در داخل پرانتز، جفت های کلید:مقدار اولیه را به فرهنگ لغت اضافه می کند. "
"این روشی است که دیکشنری ها روی خروجی نوشته می شوند."

#: ../../tutorial/datastructures.rst:512
msgid ""
"The main operations on a dictionary are storing a value with some key and "
"extracting the value given the key.  It is also possible to delete a key:"
"value pair with ``del``. If you store using a key that is already in use, "
"the old value associated with that key is forgotten.  It is an error to "
"extract a value using a non-existent key."
msgstr ""
"عملیات اصلی در یک فرهنگ لغت، ذخیره یک مقدار با مقداری کلید و استخراج مقدار "
"داده شده کلید است.  همچنین امکان حذف یک جفت کلید: ارزش با ``del`` وجود دارد. "
"اگر با استفاده از کلیدی که قبلاً در حال استفاده است ذخیره کنید، مقدار قدیمی "
"مرتبط با آن کلید فراموش می شود.  استخراج یک مقدار با استفاده از کلیدی که "
"وجود ندارد یک خطا است."

#: ../../tutorial/datastructures.rst:518
msgid ""
"Performing ``list(d)`` on a dictionary returns a list of all the keys used "
"in the dictionary, in insertion order (if you want it sorted, just use "
"``sorted(d)`` instead). To check whether a single key is in the dictionary, "
"use the :keyword:`in` keyword."
msgstr ""
"اجرای ``list(d)`` در دیکشنری فهرستی از تمام کلیدهای استفاده شده در فرهنگ لغت "
"را به ترتیب درج برمی گرداند (اگر می خواهید مرتب شود, فقط از ``sorted(d)`` "
"استفاده کنید). برای بررسی اینکه آیا یک کلید در فرهنگ لغت وجود دارد یا خیر، "
"از کلمه کلیدی :keyword:`in` استفاده کنید."

#: ../../tutorial/datastructures.rst:523
msgid "Here is a small example using a dictionary::"
msgstr "در اینجا یک مثال کوچک با استفاده از فرهنگ لغت آورده شده است:"

#: ../../tutorial/datastructures.rst:525
msgid ""
">>> tel = {'jack': 4098, 'sape': 4139}\n"
">>> tel['guido'] = 4127\n"
">>> tel\n"
"{'jack': 4098, 'sape': 4139, 'guido': 4127}\n"
">>> tel['jack']\n"
"4098\n"
">>> del tel['sape']\n"
">>> tel['irv'] = 4127\n"
">>> tel\n"
"{'jack': 4098, 'guido': 4127, 'irv': 4127}\n"
">>> list(tel)\n"
"['jack', 'guido', 'irv']\n"
">>> sorted(tel)\n"
"['guido', 'irv', 'jack']\n"
">>> 'guido' in tel\n"
"True\n"
">>> 'jack' not in tel\n"
"False"
msgstr ""
">>> tel = {'jack': 4098, 'sape': 4139}\n"
">>> tel['guido'] = 4127\n"
">>> tel\n"
"{'jack': 4098, 'sape': 4139, 'guido': 4127}\n"
">>> tel['jack']\n"
"4098\n"
">>> del tel['sape']\n"
">>> tel['irv'] = 4127\n"
">>> tel\n"
"{'jack': 4098, 'guido': 4127, 'irv': 4127}\n"
">>> list(tel)\n"
"['jack', 'guido', 'irv']\n"
">>> sorted(tel)\n"
"['guido', 'irv', 'jack']\n"
">>> 'guido' in tel\n"
"True\n"
">>> 'jack' not in tel\n"
"False"

#: ../../tutorial/datastructures.rst:544
msgid ""
"The :func:`dict` constructor builds dictionaries directly from sequences of "
"key-value pairs::"
msgstr ""
"سازنده :func:`dict` دیکشنری ها را مستقیماً از دنباله های جفت کلید-مقدار می "
"سازد:"

#: ../../tutorial/datastructures.rst:547
msgid ""
">>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n"
"{'sape': 4139, 'guido': 4127, 'jack': 4098}"
msgstr ""
">>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n"
"{'sape': 4139, 'guido': 4127, 'jack': 4098}"

#: ../../tutorial/datastructures.rst:550
msgid ""
"In addition, dict comprehensions can be used to create dictionaries from "
"arbitrary key and value expressions::"
msgstr ""
"علاوه بر این، درک دیکت می تواند برای ایجاد فرهنگ لغت از عبارات کلیدی و "
"مقادیر دلخواه استفاده شود:"

#: ../../tutorial/datastructures.rst:553
msgid ""
">>> {x: x**2 for x in (2, 4, 6)}\n"
"{2: 4, 4: 16, 6: 36}"
msgstr ""
">>> {x: x**2 for x in (2, 4, 6)}\n"
"{2: 4, 4: 16, 6: 36}"

#: ../../tutorial/datastructures.rst:556
msgid ""
"When the keys are simple strings, it is sometimes easier to specify pairs "
"using keyword arguments::"
msgstr ""
"وقتی کلیدها رشته های ساده ای هستند، گاهی اوقات تعیین جفت ها با استفاده از "
"آرگومان های کلیدواژه آسان تر است:"

#: ../../tutorial/datastructures.rst:559
msgid ""
">>> dict(sape=4139, guido=4127, jack=4098)\n"
"{'sape': 4139, 'guido': 4127, 'jack': 4098}"
msgstr ""
">>> dict(sape=4139, guido=4127, jack=4098)\n"
"{'sape': 4139, 'guido': 4127, 'jack': 4098}"

#: ../../tutorial/datastructures.rst:566
msgid "Looping Techniques"
msgstr "تکنیک های حلقه زدن"

#: ../../tutorial/datastructures.rst:568
msgid ""
"When looping through dictionaries, the key and corresponding value can be "
"retrieved at the same time using the :meth:`~dict.items` method. ::"
msgstr ""
"هنگام حلقه زدن در فرهنگ لغت، کلید و مقدار مربوطه را می توان همزمان با "
"استفاده از روش :meth:`~dict.items` بازیابی کرد. ::"

#: ../../tutorial/datastructures.rst:571
msgid ""
">>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}\n"
">>> for k, v in knights.items():\n"
"...     print(k, v)\n"
"...\n"
"gallahad the pure\n"
"robin the brave"
msgstr ""
">>> شوالیه ها = {'gallahad': 'پاک', 'robin': 'شجاع'}\n"
">>> برای k, v در knights.items():\n"
"... چاپ (k, v)\n"
"...\n"
"گالاهاد ناب\n"
"رابین شجاع"

#: ../../tutorial/datastructures.rst:578
msgid ""
"When looping through a sequence, the position index and corresponding value "
"can be retrieved at the same time using the :func:`enumerate` function. ::"
msgstr ""
"هنگام حلقه زدن از طریق یک دنباله، شاخص موقعیت و مقدار مربوطه را می توان "
"همزمان با استفاده از تابع :func:`enumerate` بازیابی کرد. ::"

#: ../../tutorial/datastructures.rst:581
msgid ""
">>> for i, v in enumerate(['tic', 'tac', 'toe']):\n"
"...     print(i, v)\n"
"...\n"
"0 tic\n"
"1 tac\n"
"2 toe"
msgstr ""
">>> برای i, v در enumerate(['tic', 'tac', 'toe']):\n"
"... چاپ (i, v)\n"
"...\n"
"0 تیک\n"
"1 تاک\n"
"2 انگشت پا"

#: ../../tutorial/datastructures.rst:588
msgid ""
"To loop over two or more sequences at the same time, the entries can be "
"paired with the :func:`zip` function. ::"
msgstr ""
"برای حلقه روی دو یا چند دنباله به طور همزمان، ورودی ها را می توان با تابع :"
"func:`zip` جفت کرد. ::"

#: ../../tutorial/datastructures.rst:591
msgid ""
">>> questions = ['name', 'quest', 'favorite color']\n"
">>> answers = ['lancelot', 'the holy grail', 'blue']\n"
">>> for q, a in zip(questions, answers):\n"
"...     print('What is your {0}?  It is {1}.'.format(q, a))\n"
"...\n"
"What is your name?  It is lancelot.\n"
"What is your quest?  It is the holy grail.\n"
"What is your favorite color?  It is blue."
msgstr ""
">>> سوالات = ['نام', 'پرسش', 'رنگ مورد علاقه']\n"
">>> پاسخ ها = ['Lancelot', 'Grail مقدس', 'Blue']\n"
">>> برای q, a در zip (سوالات, پاسخ):\n"
"... print('{0} شما چیست؟ {1} است.'.format(q, a))\n"
"...\n"
"نام شما چیست؟  لانسلوت است.\n"
"جستجوی شما چیست؟  جام مقدس است.\n"
"رنگ مورد علاقه شما چیست؟  آبی است."

#: ../../tutorial/datastructures.rst:600
msgid ""
"To loop over a sequence in reverse, first specify the sequence in a forward "
"direction and then call the :func:`reversed` function. ::"
msgstr ""
"برای چرخش بر روی یک دنباله به صورت معکوس، ابتدا دنباله را در جهت جلو مشخص "
"کنید و سپس تابع :func:`reversed` را فراخوانی کنید. ::"

#: ../../tutorial/datastructures.rst:603
msgid ""
">>> for i in reversed(range(1, 10, 2)):\n"
"...     print(i)\n"
"...\n"
"9\n"
"7\n"
"5\n"
"3\n"
"1"
msgstr ""
">>> for i in reversed(range(1, 10, 2)):\n"
"...     print(i)\n"
"...\n"
"9\n"
"7\n"
"5\n"
"3\n"
"1"

#: ../../tutorial/datastructures.rst:612
msgid ""
"To loop over a sequence in sorted order, use the :func:`sorted` function "
"which returns a new sorted list while leaving the source unaltered. ::"
msgstr ""
"برای حلقه زدن روی یک دنباله به ترتیب مرتب شده، از تابع :func:`sorted` "
"استفاده کنید که یک لیست مرتب شده جدید را برمی گرداند در حالی که منبع را بدون "
"تغییر باقی می گذارد. ::"

#: ../../tutorial/datastructures.rst:615
msgid ""
">>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n"
">>> for i in sorted(basket):\n"
"...     print(i)\n"
"...\n"
"apple\n"
"apple\n"
"banana\n"
"orange\n"
"orange\n"
"pear"
msgstr ""
">>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n"
">>> for i in sorted(basket):\n"
"...     print(i)\n"
"...\n"
"apple\n"
"apple\n"
"banana\n"
"orange\n"
"orange\n"
"pear"

#: ../../tutorial/datastructures.rst:626
msgid ""
"Using :func:`set` on a sequence eliminates duplicate elements. The use of :"
"func:`sorted` in combination with :func:`set` over a sequence is an "
"idiomatic way to loop over unique elements of the sequence in sorted "
"order. ::"
msgstr ""
"استفاده از :func:`set` روی یک دنباله، عناصر تکراری را حذف می کند. استفاده "
"از :func:`sorted` در ترکیب با :func:`set` روی یک دنباله، روشی اصطلاحی برای "
"حلقه زدن عناصر منحصر به فرد دنباله به ترتیب مرتب شده است. ::"

#: ../../tutorial/datastructures.rst:630
msgid ""
">>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n"
">>> for f in sorted(set(basket)):\n"
"...     print(f)\n"
"...\n"
"apple\n"
"banana\n"
"orange\n"
"pear"
msgstr ""
">>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']\n"
">>> for f in sorted(set(basket)):\n"
"...     print(f)\n"
"...\n"
"apple\n"
"banana\n"
"orange\n"
"pear"

#: ../../tutorial/datastructures.rst:639
msgid ""
"It is sometimes tempting to change a list while you are looping over it; "
"however, it is often simpler and safer to create a new list instead. ::"
msgstr ""
"گاهی اوقات وسوسه انگیز است که یک لیست را در حالی که در حال بررسی آن هستید "
"تغییر دهید. با این حال، ایجاد یک لیست جدید اغلب ساده تر و ایمن تر است. ::"

#: ../../tutorial/datastructures.rst:642
msgid ""
">>> import math\n"
">>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]\n"
">>> filtered_data = []\n"
">>> for value in raw_data:\n"
"...     if not math.isnan(value):\n"
"...         filtered_data.append(value)\n"
"...\n"
">>> filtered_data\n"
"[56.2, 51.7, 55.3, 52.5, 47.8]"
msgstr ""
">>> import math\n"
">>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]\n"
">>> filtered_data = []\n"
">>> for value in raw_data:\n"
"...     if not math.isnan(value):\n"
"...         filtered_data.append(value)\n"
"...\n"
">>> filtered_data\n"
"[56.2, 51.7, 55.3, 52.5, 47.8]"

#: ../../tutorial/datastructures.rst:656
msgid "More on Conditions"
msgstr "بیشتر در مورد شرایط"

#: ../../tutorial/datastructures.rst:658
msgid ""
"The conditions used in ``while`` and ``if`` statements can contain any "
"operators, not just comparisons."
msgstr ""
"شرایط استفاده شده در دستورات ``while`` و ``if`` می تواند شامل هر عملگر باشد، "
"نه فقط مقایسه."

#: ../../tutorial/datastructures.rst:662
msgid ""
"The comparison operators ``in`` and ``not in`` are membership tests that "
"determine whether a value is in (or not in) a container.  The operators "
"``is`` and ``is not`` compare whether two objects are really the same "
"object.  All comparison operators have the same priority, which is lower "
"than that of all numerical operators."
msgstr ""
"عملگرهای مقایسه ``in`` و ``not in`` تست های عضویت هستند که تعیین می کنند آیا "
"یک مقدار در (یا نه) یک ظرف است.  عملگرهای ``is`` و ``is not`` مقایسه می کنند "
"که آیا دو شی واقعاً یک شی هستند یا خیر.  همه عملگرهای مقایسه دارای اولویت "
"یکسانی هستند که از همه عملگرهای عددی کمتر است."

#: ../../tutorial/datastructures.rst:668
msgid ""
"Comparisons can be chained.  For example, ``a < b == c`` tests whether ``a`` "
"is less than ``b`` and moreover ``b`` equals ``c``."
msgstr ""
"مقایسه ها را می توان زنجیره ای کرد.  به عنوان مثال، ``a < b == c`` تست می "
"کند که آیا ``a`` کمتر از ``b`` است و علاوه بر این، ``b`` برابر با ``c`` است."

#: ../../tutorial/datastructures.rst:671
msgid ""
"Comparisons may be combined using the Boolean operators ``and`` and ``or``, "
"and the outcome of a comparison (or of any other Boolean expression) may be "
"negated with ``not``.  These have lower priorities than comparison "
"operators; between them, ``not`` has the highest priority and ``or`` the "
"lowest, so that ``A and not B or C`` is equivalent to ``(A and (not B)) or "
"C``. As always, parentheses can be used to express the desired composition."
msgstr ""
"مقایسه ها ممکن است با استفاده از عملگرهای بولی ``and`` و ``or`` ترکیب شوند و "
"نتیجه مقایسه (یا هر عبارت بولی دیگر) با ``not`` نفی شود.  اینها نسبت به "
"اپراتورهای مقایسه اولویت کمتری دارند. در بین آنها ``not`` بیشترین اولویت و "
"``or`` کمترین اولویت را دارد به طوری که ``A and not B or C`` معادل ``(A and "
"(not B)) or C`` است. مثل همیشه می توان از پرانتز برای بیان ترکیب مورد نظر "
"استفاده کرد."

#: ../../tutorial/datastructures.rst:678
msgid ""
"The Boolean operators ``and`` and ``or`` are so-called *short-circuit* "
"operators: their arguments are evaluated from left to right, and evaluation "
"stops as soon as the outcome is determined.  For example, if ``A`` and ``C`` "
"are true but ``B`` is false, ``A and B and C`` does not evaluate the "
"expression ``C``.  When used as a general value and not as a Boolean, the "
"return value of a short-circuit operator is the last evaluated argument."
msgstr ""
"عملگرهای Boolean ``and`` و ``or`` اصطلاحاً عملگرهای *short-circuit* هستند: "
"آرگومان های آنها از چپ به راست ارزیابی می شوند و به محض تعیین نتیجه ارزیابی "
"متوقف می شود.  به عنوان مثال، اگر ``A`` و ``C`` درست باشند اما ``B`` نادرست "
"باشد، ``A and B and C`` عبارت ``C`` را ارزیابی نمی کند.  هنگامی که به عنوان "
"یک مقدار کلی و نه به عنوان یک بولی استفاده می شود، مقدار بازگشتی یک اپراتور "
"اتصال کوتاه آخرین آرگومان ارزیابی شده است."

#: ../../tutorial/datastructures.rst:685
msgid ""
"It is possible to assign the result of a comparison or other Boolean "
"expression to a variable.  For example, ::"
msgstr ""
"می توان نتیجه یک مقایسه یا عبارت بولی دیگر را به یک متغیر اختصاص داد.  به "
"عنوان مثال، ::"

#: ../../tutorial/datastructures.rst:688
msgid ""
">>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'\n"
">>> non_null = string1 or string2 or string3\n"
">>> non_null\n"
"'Trondheim'"
msgstr ""
">>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'\n"
">>> non_null = string1 or string2 or string3\n"
">>> non_null\n"
"'Trondheim'"

#: ../../tutorial/datastructures.rst:693
msgid ""
"Note that in Python, unlike C, assignment inside expressions must be done "
"explicitly with the :ref:`walrus operator <why-can-t-i-use-an-assignment-in-"
"an-expression>` ``:=``. This avoids a common class of problems encountered "
"in C programs: typing ``=`` in an expression when ``==`` was intended."
msgstr ""
"توجه داشته باشید که در پایتون، برخلاف C، تخصیص درون عبارات باید به طور صریح "
"با :ref:`walrus operator <why-can-t-i-use-an-assignment-in-an-expression>` "
"``:=`` انجام شود. با این کار از یک کلاس رایج از مشکلاتی که در برنامه‌های C با "
"آن مواجه می‌شوید جلوگیری می‌شود: تایپ ``=`` در یک عبارت زمانی که ``==`` در نظر "
"گرفته شده بود."

#: ../../tutorial/datastructures.rst:703
msgid "Comparing Sequences and Other Types"
msgstr "مقایسه توالی ها و انواع دیگر"

#: ../../tutorial/datastructures.rst:704
msgid ""
"Sequence objects typically may be compared to other objects with the same "
"sequence type. The comparison uses *lexicographical* ordering: first the "
"first two items are compared, and if they differ this determines the outcome "
"of the comparison; if they are equal, the next two items are compared, and "
"so on, until either sequence is exhausted. If two items to be compared are "
"themselves sequences of the same type, the lexicographical comparison is "
"carried out recursively.  If all items of two sequences compare equal, the "
"sequences are considered equal. If one sequence is an initial sub-sequence "
"of the other, the shorter sequence is the smaller (lesser) one.  "
"Lexicographical ordering for strings uses the Unicode code point number to "
"order individual characters. Some examples of comparisons between sequences "
"of the same type::"
msgstr ""
"اشیاء دنباله معمولاً ممکن است با اشیاء دیگر با همان نوع توالی مقایسه شوند. "
"مقایسه از ترتیب *lexicographical* استفاده می کند: ابتدا دو مورد اول با هم "
"مقایسه می شوند و اگر متفاوت باشند، نتیجه مقایسه را مشخص می کند. اگر مساوی "
"باشند، دو مورد بعدی با هم مقایسه می شوند، و به همین ترتیب، تا زمانی که هر یک "
"از دنباله ها تمام شود. اگر دو مورد برای مقایسه، خود توالی هایی از یک نوع "
"باشند، مقایسه واژگانی به صورت بازگشتی انجام می شود.  اگر همه آیتم های دو "
"دنباله با هم برابر باشند، دنباله ها برابر در نظر گرفته می شوند. اگر یک "
"دنباله زیر دنباله ابتدایی دیگری باشد، دنباله کوتاهتر کوچکتر (کوچکتر) است.  "
"ترتیب واژگانی رشته‌ها از شماره نقطه کد یونیکد برای مرتب کردن کاراکترها "
"استفاده می‌کند. چند نمونه از مقایسه بین دنباله هایی از یک نوع::"

#: ../../tutorial/datastructures.rst:716
msgid ""
"(1, 2, 3)              < (1, 2, 4)\n"
"[1, 2, 3]              < [1, 2, 4]\n"
"'ABC' < 'C' < 'Pascal' < 'Python'\n"
"(1, 2, 3, 4)           < (1, 2, 4)\n"
"(1, 2)                 < (1, 2, -1)\n"
"(1, 2, 3)             == (1.0, 2.0, 3.0)\n"
"(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)"
msgstr ""
"(1, 2, 3)              < (1, 2, 4)\n"
"[1, 2, 3]              < [1, 2, 4]\n"
"'ABC' < 'C' < 'Pascal' < 'Python'\n"
"(1, 2, 3, 4)           < (1, 2, 4)\n"
"(1, 2)                 < (1, 2, -1)\n"
"(1, 2, 3)             == (1.0, 2.0, 3.0)\n"
"(1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)"

#: ../../tutorial/datastructures.rst:724
msgid ""
"Note that comparing objects of different types with ``<`` or ``>`` is legal "
"provided that the objects have appropriate comparison methods.  For example, "
"mixed numeric types are compared according to their numeric value, so 0 "
"equals 0.0, etc.  Otherwise, rather than providing an arbitrary ordering, "
"the interpreter will raise a :exc:`TypeError` exception."
msgstr ""
"توجه داشته باشید که مقایسه اشیاء از انواع مختلف با ``<`` یا ``>`` قانونی است "
"مشروط بر اینکه اشیاء دارای روش های مقایسه مناسب باشند.  به عنوان مثال، انواع "
"عددی مختلط با توجه به مقدار عددی آنها مقایسه می شوند، بنابراین 0 برابر با "
"0.0 و غیره است. در غیر این صورت، به جای ارائه یک ترتیب دلخواه، مفسر یک "
"استثنا :exc:`TypeError` را ایجاد می کند."

#: ../../tutorial/datastructures.rst:732
msgid "Footnotes"
msgstr "پاورقی ها"

#: ../../tutorial/datastructures.rst:733
msgid ""
"Other languages may return the mutated object, which allows method chaining, "
"such as ``d->insert(\"a\")->remove(\"b\")->sort();``."
msgstr ""
"زبان های دیگر ممکن است شی جهش یافته را برگردانند، که امکان زنجیره متد را "
"فراهم می کند، مانند ``d->insert(\"a\")->remove(\"b\")->sort();``."
