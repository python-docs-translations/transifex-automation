# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# Maciej Olko <maciej.olko@gmail.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-06-02 14:49+0000\n"
"PO-Revision-Date: 2019-09-01 02:41+0000\n"
"Last-Translator: Maciej Olko <maciej.olko@gmail.com>, 2021\n"
"Language-Team: Polish (https://app.transifex.com/python-doc/teams/5390/pl/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pl\n"
"Plural-Forms: nplurals=4; plural=(n==1 ? 0 : (n%10>=2 && n%10<=4) && (n%100<12 || n%100>14) ? 1 : n!=1 && (n%10>=0 && n%10<=1) || (n%10>=5 && n%10<=9) || (n%100>=12 && n%100<=14) ? 2 : 3);\n"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:5
msgid "Data Structures"
msgstr "Struktury danych"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:7
msgid ""
"This chapter describes some things you've learned about already in more "
"detail, and adds some new things as well."
msgstr ""
"Ten rozdział opisuje bardziej szczegółowo niektóre rzeczy, które już "
"poznaliście, oraz również wprowadza nowe elementy."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:13
msgid "More on Lists"
msgstr "Więcej na temat list"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:15
msgid ""
"The list data type has some more methods.  Here are all of the methods of "
"list objects:"
msgstr ""
"Typ danych listy ma kilka więcej metod. To wszystkie metody obiektów list:"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:22
msgid ""
"Add an item to the end of the list.  Equivalent to ``a[len(a):] = [x]``."
msgstr "Dodaje element na końcu listy. Ekwiwalent ``a[len(a):] = [x]``."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:28
msgid ""
"Extend the list by appending all the items from the iterable.  Equivalent to"
" ``a[len(a):] = iterable``."
msgstr ""
"Rozszerza listę przez dodanie wszystkich elementów iterable'a. Ekwiwalent "
"``a[len(a):] = iterable``."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:35
msgid ""
"Insert an item at a given position.  The first argument is the index of the "
"element before which to insert, so ``a.insert(0, x)`` inserts at the front "
"of the list, and ``a.insert(len(a), x)`` is equivalent to ``a.append(x)``."
msgstr ""
"Wstawia element na podaną pozycję. Pierwszy argument jest indeksem elementu,"
" przed którym wstawiamy, więc ``a.insert(0, x)`` wstawia na początek listy a"
" ``a.insert(len(a), x)`` odpowiada ``a.append(x)``."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:43
msgid ""
"Remove the first item from the list whose value is equal to *x*.  It raises "
"a :exc:`ValueError` if there is no such item."
msgstr ""
"Usuń pierwszy element z listy, którego wartość jest równa *x*. Rzuca "
":exc:`ValueError`, jeśli nie ma takiego elementu."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:50
msgid ""
"Remove the item at the given position in the list, and return it.  If no "
"index is specified, ``a.pop()`` removes and returns the last item in the "
"list.  (The square brackets around the *i* in the method signature denote "
"that the parameter is optional, not that you should type square brackets at "
"that position.  You will see this notation frequently in the Python Library "
"Reference.)"
msgstr ""
"Usuwa element z podanej pozycji na liście i zwraca go. Jeśli indeks nie jest"
" podany, ``a.pop()`` usuwa i zwraca ostatni element listy. (Nawiasy "
"kwadratowe dookoła *i* w sygnaturze metody oznaczają, że ten parametr jest "
"opcjonalny, nie że powinieneś wpisać nawiasy kwadratowe w tym miejscu. Taką "
"notację będziesz często widzieć w dokumentacji biblioteki Pythona.)"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:60
msgid "Remove all items from the list.  Equivalent to ``del a[:]``."
msgstr "Usuwa wszystkie elementy z listy. Ekwiwalent ``del a[:]``."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:66
msgid ""
"Return zero-based index in the list of the first item whose value is equal "
"to *x*. Raises a :exc:`ValueError` if there is no such item."
msgstr ""
"Zwraca indeks (liczony od zera) pierwszego elementu na liście, którego "
"wartość jest równa *x*. Rzuca :exc:`ValueError`, jeśli nie ma takiego "
"elementu."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:69
msgid ""
"The optional arguments *start* and *end* are interpreted as in the slice "
"notation and are used to limit the search to a particular subsequence of the"
" list.  The returned index is computed relative to the beginning of the full"
" sequence rather than the *start* argument."
msgstr ""
"Opcjonalne argumenty *start* i *end* są interpretowane jak w notacji slice i"
" służą do ograniczenia wyszukiwania do szczególnej podsekwencji listy. "
"Zwracany indeks jest wyliczany względem początku pełnej sekwencji, nie "
"względem argumentu *start*."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:78
msgid "Return the number of times *x* appears in the list."
msgstr "Zwraca liczbę razy, jaką *x* występuje  liście."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:84
msgid ""
"Sort the items of the list in place (the arguments can be used for sort "
"customization, see :func:`sorted` for their explanation)."
msgstr ""
"Sortuje elementy listy w miejscu (argumenty mogą służyć do dostosowania "
"sortowania, patrz :func:`sorted` po ich wyjaśnienie)."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:91
msgid "Reverse the elements of the list in place."
msgstr "Odwraca elementy listy w miejscu."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:97
msgid "Return a shallow copy of the list.  Equivalent to ``a[:]``."
msgstr "Zwraca płytką kopię listy. Ekwiwalent ``a[:]``."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:100
msgid "An example that uses most of the list methods::"
msgstr "Przykład, który używa większość metod listy:"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:123
msgid ""
"You might have noticed that methods like ``insert``, ``remove`` or ``sort`` "
"that only modify the list have no return value printed -- they return the "
"default ``None``. [1]_  This is a design principle for all mutable data "
"structures in Python."
msgstr ""
"Mogłeś(-aś) zauważyć, że metod takie jak ``insert``, ``remove`` lub "
"``sort``, które tylko modyfikują listę, nie mają wyświetlonej zwracanej "
"wartości -- zwracają one domyślne ``None``. [1]_ To zasada projektowa dla "
"wszystkich mutowalnych typów danych w Pythonie."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:132
msgid "Using Lists as Stacks"
msgstr "Używanie list jako stosów"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:137
msgid ""
"The list methods make it very easy to use a list as a stack, where the last "
"element added is the first element retrieved (\"last-in, first-out\").  To "
"add an item to the top of the stack, use :meth:`append`.  To retrieve an "
"item from the top of the stack, use :meth:`pop` without an explicit index.  "
"For example::"
msgstr ""
"Metody listy ułatwiają używanie listy jako stosu, gdzie ostatni element "
"dodany jest pierwszym elementem pobieranym („last-in, first-out”). Aby dodać"
" element na wierzch stosu, użyj :meth:`append`. Aby pobrać element z "
"wierzchu stosu, użyj :meth:`pop` bez podanego indeksu. Na przykład::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:162
msgid "Using Lists as Queues"
msgstr "Używanie list jako kolejek"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:166
msgid ""
"It is also possible to use a list as a queue, where the first element added "
"is the first element retrieved (\"first-in, first-out\"); however, lists are"
" not efficient for this purpose.  While appends and pops from the end of "
"list are fast, doing inserts or pops from the beginning of a list is slow "
"(because all of the other elements have to be shifted by one)."
msgstr ""
"Można też używać list jako kolejek, gdzie pierwszy element dodany jest "
"pierwszym elementem pobieranym („first-in, first-out”); jednakże listy nie "
"są wydajne do tego celu. Appendy i popy na końcu listy są szybkie, lecz "
"inserty i popy na początku listy są wolne (ponieważ wszystkie inne elementy "
"muszą zostać przesunięte o jeden)."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:172
msgid ""
"To implement a queue, use :class:`collections.deque` which was designed to "
"have fast appends and pops from both ends.  For example::"
msgstr ""
"Aby zaimplementować kolejkę, użyj :class:`collections.deque`, która została "
"zaprojektowana, by mieć szybkie appendy i popy na obu końcach. Na przykład::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:190
msgid "List Comprehensions"
msgstr "List comprehensions"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:192
msgid ""
"List comprehensions provide a concise way to create lists. Common "
"applications are to make new lists where each element is the result of some "
"operations applied to each member of another sequence or iterable, or to "
"create a subsequence of those elements that satisfy a certain condition."
msgstr ""
"List comprehensions są zwięzłym sposobem na tworzenie list. Powszechne "
"zastosowania to tworzenie nowych list, gdzie każdy element jest wynikiem "
"jakichś operacji zastosowanych do każdego elementu innej sekwencji lub "
"iterable'a lub do tworzenia podsekwencji tych elementów, które spełniają "
"określony warunek."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:197
msgid "For example, assume we want to create a list of squares, like::"
msgstr "Na przykład załóżmy, że chcemy stworzyć listę kwadratów, jak tu::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:206
msgid ""
"Note that this creates (or overwrites) a variable named ``x`` that still "
"exists after the loop completes.  We can calculate the list of squares "
"without any side effects using::"
msgstr ""
"Zwróć uwagę, że ten kod tworzy (lub nadpisuje) zmienną o nazwie ``x``, która"
" wciąż istnieje po wykonaniu pętli. Możemy obliczyć listę kwadratów bez "
"żadnych efektów ubocznych w następujący sposób::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:212
msgid "or, equivalently::"
msgstr "lub równoważnie::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:216
msgid "which is more concise and readable."
msgstr "co jest bardziej zwięzłe i czytelne."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:218
msgid ""
"A list comprehension consists of brackets containing an expression followed "
"by a :keyword:`!for` clause, then zero or more :keyword:`!for` or "
":keyword:`!if` clauses.  The result will be a new list resulting from "
"evaluating the expression in the context of the :keyword:`!for` and "
":keyword:`!if` clauses which follow it. For example, this listcomp combines "
"the elements of two lists if they are not equal::"
msgstr ""
"Wyrażenie listowe składa się z nawiasów zawierających wyrażenie oraz "
"klauzulę :keyword:`!for`, następnie zero lub więcej klauzul :keyword:`!for` "
"lub :keyword:`!if`. Rezultatem będzie nowa lista powstała z obliczenia "
"wyrażenia w kontekście klauzul :keyword:`!for` i :keyword:`!if`, które po "
"nim następują. Na przykład to wyrażenie listowe łączy elementy dwóch list, "
"jeśli nie są równe::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:228
msgid "and it's equivalent to::"
msgstr "i jest odpowiednikiem::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:239
msgid ""
"Note how the order of the :keyword:`for` and :keyword:`if` statements is the"
" same in both these snippets."
msgstr ""
"Zwróć uwagę, że kolejność instrukcji :keyword:`for` i :keyword:`if` jest "
"taka sama w obu fragmentach kodu."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:242
msgid ""
"If the expression is a tuple (e.g. the ``(x, y)`` in the previous example), "
"it must be parenthesized. ::"
msgstr ""
"Jeśli wyrażenie jest krotką (tak jak ``(x, y)`` w poprzednim przykładzie), "
"musi być wzięte w nawias. ::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:273
msgid ""
"List comprehensions can contain complex expressions and nested functions::"
msgstr ""
"Wyrażenia listowe mogą zawierać złożone wyrażenia i zagnieżdżone funkcje::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:280
msgid "Nested List Comprehensions"
msgstr "Zagnieżdżone wyrażenia listowe"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:282
msgid ""
"The initial expression in a list comprehension can be any arbitrary "
"expression, including another list comprehension."
msgstr ""
"Wyrażeniem wyjściowym w wyrażeniu listowym może być każde arbitralne "
"wyrażenie, włączając inne wyrażenie listowe."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:285
msgid ""
"Consider the following example of a 3x4 matrix implemented as a list of 3 "
"lists of length 4::"
msgstr ""
"Rozważmy następujący przykład macierzy 3-na-4 zaimplementowanej jako lista "
"trzech list o długości 4::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:294
msgid "The following list comprehension will transpose rows and columns::"
msgstr "Następujące wyrażenie listowe przetransponuje wiersze i kolumny::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:299
msgid ""
"As we saw in the previous section, the nested listcomp is evaluated in the "
"context of the :keyword:`for` that follows it, so this example is equivalent"
" to::"
msgstr ""
"Jak widzieliśmy w poprzedniej sekcji, zagnieżdżone wyrażenie listowe jest "
"ewaluowane w kontekście :keyword:`for`, które po nim następuje, więc ten "
"przykład jest równoważny temu::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:310
msgid "which, in turn, is the same as::"
msgstr "który z kolei jest taki sam jak::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:323
msgid ""
"In the real world, you should prefer built-in functions to complex flow "
"statements. The :func:`zip` function would do a great job for this use "
"case::"
msgstr ""
"W prawdziwym świecie powinieneś(-nnaś) preferować wbudowane funkcje w "
"złożonych instrukcjach przepływu. Funkcja :func:`zip` bardzo się przyda w "
"tym przypadku::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:329
msgid ""
"See :ref:`tut-unpacking-arguments` for details on the asterisk in this line."
msgstr ""
"W :ref:`tut-unpacking-arguments` znajdziesz wyjaśnienie znaku gwiazdki w tej"
" linii."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:334
msgid "The :keyword:`!del` statement"
msgstr "Instrukcja :keyword:`!del`"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:336
msgid ""
"There is a way to remove an item from a list given its index instead of its "
"value: the :keyword:`del` statement.  This differs from the :meth:`pop` "
"method which returns a value.  The :keyword:`!del` statement can also be "
"used to remove slices from a list or clear the entire list (which we did "
"earlier by assignment of an empty list to the slice).  For example::"
msgstr ""
"Element można usunąć z listy mając jego indeks zamiast wartości: instrukcją "
":keyword:`del`. Jest ona różna od metody :meth:`pop`, która zwraca wartość. "
"Instrukcji :keyword:`del` można też użyć do usunięcia slice'ów lub "
"wyczyszczenia całej listy (zrobiliśmy to wcześniej przypisując pustą listę "
"do slice'a). Na przykład::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:353
msgid ":keyword:`del` can also be used to delete entire variables::"
msgstr ":keyword:`del` można również użyć do usuwania całych zmiennych::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:357
msgid ""
"Referencing the name ``a`` hereafter is an error (at least until another "
"value is assigned to it).  We'll find other uses for :keyword:`del` later."
msgstr ""
"Odniesienie się do nazwy ``a`` odtąd jest błędem (przynajmniej dopóki nie "
"przypisana jest do niej inna wartość). Później odnajdziemy więcej zastosowań"
" dla :keyword:`del`."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:364
msgid "Tuples and Sequences"
msgstr "Krotki i sekwencje"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:366
msgid ""
"We saw that lists and strings have many common properties, such as indexing "
"and slicing operations.  They are two examples of *sequence* data types (see"
" :ref:`typesseq`).  Since Python is an evolving language, other sequence "
"data types may be added.  There is also another standard sequence data type:"
" the *tuple*."
msgstr ""
"Widzieliśmy, że listy i ciągi znaków mają wiele wspólnych własności, takich "
"jak indeksowanie i operacje slice. Są one dwoma przykładami *sekwencyjnych* "
"typów danych (patrz :ref:`typesseq`). Jako że Python jest ewoluującym "
"językiem, mogą zostać dodane inne sekwencyjne typy danych. Jest też inny "
"standardowy sekwencyjny typ danych: *krotka*."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:372
msgid ""
"A tuple consists of a number of values separated by commas, for instance::"
msgstr ""
"Krotka składa się z kilku wartości rozdzielonych przecinkami, na przykład::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:394
msgid ""
"As you see, on output tuples are always enclosed in parentheses, so that "
"nested tuples are interpreted correctly; they may be input with or without "
"surrounding parentheses, although often parentheses are necessary anyway (if"
" the tuple is part of a larger expression).  It is not possible to assign to"
" the individual items of a tuple, however it is possible to create tuples "
"which contain mutable objects, such as lists."
msgstr ""
"Jak widzisz na wyjściu krotki zawsze są otoczone nawiasami, tak aby "
"zagnieżdżone krotki były poprawnie interpretowane; wpisać je można z lub bez"
" otaczających nawiasów, chociaż często nawiasy są i tak potrzebne (jeśli "
"krotka jest częścią większego wyrażenia). Nie da się przypisać wartości do "
"pojedynczych elementów krotki, ale da się stworzyć krotki, które zawierają "
"mutowalne obiekty, takie jak listy."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:401
msgid ""
"Though tuples may seem similar to lists, they are often used in different "
"situations and for different purposes. Tuples are :term:`immutable`, and "
"usually contain a heterogeneous sequence of elements that are accessed via "
"unpacking (see later in this section) or indexing (or even by attribute in "
"the case of :func:`namedtuples <collections.namedtuple>`). Lists are "
":term:`mutable`, and their elements are usually homogeneous and are accessed"
" by iterating over the list."
msgstr ""
"Mimo że krotki mogą wydawać się podobne do list, często są używane w innych "
"sytuacjach i do innych celów. Krotki są :term:`niemutowalne <immutable>` i "
"zazwyczaj zawierają heterogeniczne sekwencje elementów, do których dostęp "
"uzyskuje się przez rozpakowywanie (patrz później w tej sekcji) lub "
"indeksowanie (lub nawet przez atrybut w przypadku :func:`namedtuples "
"<collections.namedtuple>`). Listy są :term:`mutowalne <mutable>` i ich "
"elementy są zazwyczaj homogeniczne i dostęp do nich uzyskuje się przez "
"iterowanie po liście."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:409
msgid ""
"A special problem is the construction of tuples containing 0 or 1 items: the"
" syntax has some extra quirks to accommodate these.  Empty tuples are "
"constructed by an empty pair of parentheses; a tuple with one item is "
"constructed by following a value with a comma (it is not sufficient to "
"enclose a single value in parentheses). Ugly, but effective.  For example::"
msgstr ""
"Specjalnym problemem jest konstrukcja krotek zawierających 0 lub 1 element: "
"składnia przewiduje na to kilka sposobów. Puste krotki można konstruować "
"pustą parą nawiasów; krotkę z jednym elementem można skonstruować "
"umieszczając przecinek za wartością (nie wystarczy otoczyć pojedynczej "
"wartości nawiasami). Brzydkie, ale działa. Na przykład::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:424
msgid ""
"The statement ``t = 12345, 54321, 'hello!'`` is an example of *tuple "
"packing*: the values ``12345``, ``54321`` and ``'hello!'`` are packed "
"together in a tuple. The reverse operation is also possible::"
msgstr ""
"Instrukcja ``t = 12345, 54321, 'hello!'`` jest przykładem *pakowania "
"krotki*: wartości ``12345``, ``54321`` i ``'hello!'`` są razem zapakowane w "
"krotkę. Możliwa jest również odwrotna operacja::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:430
msgid ""
"This is called, appropriately enough, *sequence unpacking* and works for any"
" sequence on the right-hand side.  Sequence unpacking requires that there "
"are as many variables on the left side of the equals sign as there are "
"elements in the sequence.  Note that multiple assignment is really just a "
"combination of tuple packing and sequence unpacking."
msgstr ""
"Takie coś nazywane jest, odpowiednio, *rozpakowywaniem sekwencji*. Takie "
"rozpakowywanie wymaga, aby po lewej stronie znaku równości było tyle samo "
"zmiennych, ile jest elementów w sekwencji. Zauważcie, że wielokrotne "
"przypisanie jest kombinacją pakowania i rozpakowywania sekwencji."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:440
msgid "Sets"
msgstr "Zbiory"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:442
msgid ""
"Python also includes a data type for *sets*.  A set is an unordered "
"collection with no duplicate elements.  Basic uses include membership "
"testing and eliminating duplicate entries.  Set objects also support "
"mathematical operations like union, intersection, difference, and symmetric "
"difference."
msgstr ""
"Python ma również typ danych dla zbiorów. Zbiór jest nieuporządkowaną "
"kolekcją bez zduplikowanych elementów. Podstawowe użycia to sprawdzenie "
"zawierania i eliminacja duplikatów. Obiekty zbiorów wspierają też operacje "
"matematyczne jak suma, iloczyn, różnica i różnica symetryczna zbiorów."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:447
msgid ""
"Curly braces or the :func:`set` function can be used to create sets.  Note: "
"to create an empty set you have to use ``set()``, not ``{}``; the latter "
"creates an empty dictionary, a data structure that we discuss in the next "
"section."
msgstr ""
"Zbiory można stworzyć używając nawiasów klamrowych lub funkcji :func:`set`. "
"Uwaga: aby stworzyć pusty zbiór, musisz użyć ``set()``, nie ``{}``; to "
"drugie tworzy pusty słownik, strukturę danych, którą omówimy w następnej "
"sekcji."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:451
msgid "Here is a brief demonstration::"
msgstr "Poniżej krótka demonstracja::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:476
msgid ""
"Similarly to :ref:`list comprehensions <tut-listcomps>`, set comprehensions "
"are also supported::"
msgstr ""
"Podobnie do :ref:`wyrażeń listowych <tut-listcomps>`, są wspierane również "
"wyrażenia zbiorów::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:487
msgid "Dictionaries"
msgstr "Słowniki"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:489
msgid ""
"Another useful data type built into Python is the *dictionary* (see "
":ref:`typesmapping`). Dictionaries are sometimes found in other languages as"
" \"associative memories\" or \"associative arrays\".  Unlike sequences, "
"which are indexed by a range of numbers, dictionaries are indexed by *keys*,"
" which can be any immutable type; strings and numbers can always be keys.  "
"Tuples can be used as keys if they contain only strings, numbers, or tuples;"
" if a tuple contains any mutable object either directly or indirectly, it "
"cannot be used as a key. You can't use lists as keys, since lists can be "
"modified in place using index assignments, slice assignments, or methods "
"like :meth:`append` and :meth:`extend`."
msgstr ""
"Innym przydatnym typem danych wbudowanym w Pythona jest *słownik* (patrz "
":ref:`typesmapping`). Słowniki w innych językach czasem występują jako "
"„pamięci asocjacyjne” albo „tablice asocjacyjne”. W przeciwieństwie do "
"sekwencji, które są indeksowane zakresem liczb, słowniki są indeksowane "
"przez *klucze*, które mogą być dowolnym niemutowalnym typem; ciągi znaków i "
"liczby zawsze mogą być kluczami. Można użyć krotek, jeśli zawierają tylko "
"ciągi znaków, liczby lub krotki; jeśli krotka zawiera choć jeden mutowalny "
"obiekt, bezpośrednio lub pośrednio, nie można jej użyć jako klucza. Nie "
"możesz używać list jako kluczy, jako że listy mogą być modyfikowane „w "
"miejscu” przy użyciu przypisań do indeksu, przypisań do slice'ów lub metod "
"jak :meth:`append` i :meth:`extend`."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:500
msgid ""
"It is best to think of a dictionary as a set of *key: value* pairs, with the"
" requirement that the keys are unique (within one dictionary). A pair of "
"braces creates an empty dictionary: ``{}``. Placing a comma-separated list "
"of key:value pairs within the braces adds initial key:value pairs to the "
"dictionary; this is also the way dictionaries are written on output."
msgstr ""
"Najlepiej jest myśleć o słowniku jako zbiorze par *klucz: wartość*, z "
"wymaganiem aby klucze były unikalne (w obrębie jednego słownika). Para "
"nawiasów klamrowych tworzy pusty słownik: ``{}``. Umieszczenie listy par "
"klucz:wartość rozdzielonych przecinkami dodaje początkowe pary do słownika; "
"w ten sposób również słowniki są wypisywane na wyjściu."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:506
msgid ""
"The main operations on a dictionary are storing a value with some key and "
"extracting the value given the key.  It is also possible to delete a "
"key:value pair with ``del``. If you store using a key that is already in "
"use, the old value associated with that key is forgotten.  It is an error to"
" extract a value using a non-existent key."
msgstr ""
"Głównymi operacjami na słowniku są umieszczanie wartości  pod jakimś kluczem"
" oraz wyciąganie wartości dla podanego klucza. Możliwe jest również "
"usunięcie pary klucz:wartość przy użyciu ``del``. Jeśli umieścisz wartość "
"używając klucza, który już jest w użyciu, stara wartość powiązana z tym "
"kluczem zostanie zapomniana. Próba wyciągnięcia wartości przy użyciu "
"nieistniejącego klucza zakończy się błędem."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:512
msgid ""
"Performing ``list(d)`` on a dictionary returns a list of all the keys used "
"in the dictionary, in insertion order (if you want it sorted, just use "
"``sorted(d)`` instead). To check whether a single key is in the dictionary, "
"use the :keyword:`in` keyword."
msgstr ""
"Wykonanie ``list(d)`` na słowniku zwraca listę wszystkich kluczy używanych w"
" słowniku, w kolejności wstawiania (jeśli chcesz je posortować, użyj "
"``sorted(d)``). Aby sprawdzić, czy pojedynczy klucz jest w słowniku, użyj "
"słowa kluczowego :keyword:`in`."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:517
msgid "Here is a small example using a dictionary::"
msgstr "Mały przykład z użyciem słownika::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:538
msgid ""
"The :func:`dict` constructor builds dictionaries directly from sequences of "
"key-value pairs::"
msgstr ""
"Konstruktor :func:`dict` buduje słowniki bezpośrednio z sekwencji par klucz-"
"wartość::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:544
msgid ""
"In addition, dict comprehensions can be used to create dictionaries from "
"arbitrary key and value expressions::"
msgstr ""
"Dodatkowo można użyć wyrażeń słownikowych to tworzenia słowników z podanych "
"wyrażeń klucza i wartości::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:550
msgid ""
"When the keys are simple strings, it is sometimes easier to specify pairs "
"using keyword arguments::"
msgstr ""
"Kiedy klucze są prostymi ciągami znaków, czasem łatwiej jest podać pary "
"używając argumentów nazwanych::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:560
msgid "Looping Techniques"
msgstr "Techniki pętli"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:562
msgid ""
"When looping through dictionaries, the key and corresponding value can be "
"retrieved at the same time using the :meth:`items` method. ::"
msgstr ""
"Podczas iterowania po słownikach, klucz i odpowiadającą mu wartość można "
"pobrać w tym samym czasie używając metody :meth:`items`. ::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:572
msgid ""
"When looping through a sequence, the position index and corresponding value "
"can be retrieved at the same time using the :func:`enumerate` function. ::"
msgstr ""
"Przy iterowaniu po sekwencji, indeks pozycyjny i odpowiadającą mu wartość "
"można pobrać w tym samym czasie używając funkcji :func:`enumerate`. ::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:582
msgid ""
"To loop over two or more sequences at the same time, the entries can be "
"paired with the :func:`zip` function. ::"
msgstr ""
"Aby przeiterować po dwóch lub więcej sekwencjach w tym samym czasie, "
"elementy mogą zostać zgrupowane funkcją :func:`zip`. ::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:594
msgid ""
"To loop over a sequence in reverse, first specify the sequence in a forward "
"direction and then call the :func:`reversed` function. ::"
msgstr ""
"Aby przeiterować po sekwencji od końca, najpierw określ sekwencję w kierunku"
" „do przodu” a następnie wywołaj funkcję :func:`reversed`. ::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:606
msgid ""
"To loop over a sequence in sorted order, use the :func:`sorted` function "
"which returns a new sorted list while leaving the source unaltered. ::"
msgstr ""
"Aby przeiterować po sekwencji w posortowanej kolejności, użyj funkcji "
":func:`sorted`, która zwraca nową posortowaną listę pozostawiając listę "
"źródłową niezmienioną. ::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:618
msgid ""
"It is sometimes tempting to change a list while you are looping over it; "
"however, it is often simpler and safer to create a new list instead. ::"
msgstr ""
"Czasem kusi, żeby zmienić listę podczas iterowania po niej; jednak często "
"prościej i bezpieczniej jest stworzyć nową listę. ::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:635
msgid "More on Conditions"
msgstr "Więcej na temat warunków"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:637
msgid ""
"The conditions used in ``while`` and ``if`` statements can contain any "
"operators, not just comparisons."
msgstr ""
"Warunki użyte w instrukcjach ``while`` i ``if`` mogą zawierać dowolne "
"operatory, nie tylko porównania."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:640
msgid ""
"The comparison operators ``in`` and ``not in`` check whether a value occurs "
"(does not occur) in a sequence.  The operators ``is`` and ``is not`` compare"
" whether two objects are really the same object; this only matters for "
"mutable objects like lists.  All comparison operators have the same "
"priority, which is lower than that of all numerical operators."
msgstr ""

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:646
msgid ""
"Comparisons can be chained.  For example, ``a < b == c`` tests whether ``a``"
" is less than ``b`` and moreover ``b`` equals ``c``."
msgstr ""
"Porównania mogą być układane w łańcuchy. Na przykład ``a < b == c`` "
"sprawdza, czy ``a`` jest mniejsze od ``b`` i ponadto czy ``b`` równa się "
"``c``."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:649
msgid ""
"Comparisons may be combined using the Boolean operators ``and`` and ``or``, "
"and the outcome of a comparison (or of any other Boolean expression) may be "
"negated with ``not``.  These have lower priorities than comparison "
"operators; between them, ``not`` has the highest priority and ``or`` the "
"lowest, so that ``A and not B or C`` is equivalent to ``(A and (not B)) or "
"C``. As always, parentheses can be used to express the desired composition."
msgstr ""
"Porównania można łączyć używając operatorów boolowskich ``and`` i ``or``. "
"Wynik porównania (lub jakiegokolwiek innego wyrażenia boolowskiego) można "
"zanegować używając ``not``. Operatory te mają mniejszy priorytet niż "
"operatory porównania; wśród nich ``not`` ma najwyższy priorytet a ``or`` "
"najniższy, więc ``A and not B or C`` jest ekwiwalentem ``(A and (not B)) or "
"C``. Jak zwykle można użyć nawiasów, aby wyrazić pożądaną kolejność "
"kompozycji wyrażenia."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:656
msgid ""
"The Boolean operators ``and`` and ``or`` are so-called *short-circuit* "
"operators: their arguments are evaluated from left to right, and evaluation "
"stops as soon as the outcome is determined.  For example, if ``A`` and ``C``"
" are true but ``B`` is false, ``A and B and C`` does not evaluate the "
"expression ``C``.  When used as a general value and not as a Boolean, the "
"return value of a short-circuit operator is the last evaluated argument."
msgstr ""
"Argumenty operatorów boolowskich ``and`` i ``or`` są ewaluowane od lewej do "
"prawej. Ewaluacja kończy się w momencie ustalenia wyniku. Na przykład, jeśli"
" ``A`` i ``C`` są prawdą, ale ``B`` jest fałszem, ``A and B and C`` nie "
"zewaluuje wyrażenia ``C``. Przy użyciu ogólnej wartości, nie jako boolean, "
"wartość zwracana tych operatorów to ostatnio ewaluowany argument."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:663
msgid ""
"It is possible to assign the result of a comparison or other Boolean "
"expression to a variable.  For example, ::"
msgstr ""
"Da się przypisać wynik porównania lub inne wyrażenie boolowskie do zmiennej."
" Na przykład, ::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:671
msgid ""
"Note that in Python, unlike C, assignment cannot occur inside expressions. C"
" programmers may grumble about this, but it avoids a common class of "
"problems encountered in C programs: typing ``=`` in an expression when "
"``==`` was intended."
msgstr ""

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:680
msgid "Comparing Sequences and Other Types"
msgstr "Porównywanie sekwencji i innych typów"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:682
msgid ""
"Sequence objects may be compared to other objects with the same sequence "
"type. The comparison uses *lexicographical* ordering: first the first two "
"items are compared, and if they differ this determines the outcome of the "
"comparison; if they are equal, the next two items are compared, and so on, "
"until either sequence is exhausted. If two items to be compared are "
"themselves sequences of the same type, the lexicographical comparison is "
"carried out recursively.  If all items of two sequences compare equal, the "
"sequences are considered equal. If one sequence is an initial sub-sequence "
"of the other, the shorter sequence is the smaller (lesser) one.  "
"Lexicographical ordering for strings uses the Unicode code point number to "
"order individual characters.  Some examples of comparisons between sequences"
" of the same type::"
msgstr ""

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:702
msgid ""
"Note that comparing objects of different types with ``<`` or ``>`` is legal "
"provided that the objects have appropriate comparison methods.  For example,"
" mixed numeric types are compared according to their numeric value, so 0 "
"equals 0.0, etc.  Otherwise, rather than providing an arbitrary ordering, "
"the interpreter will raise a :exc:`TypeError` exception."
msgstr ""
"Zwróć uwagę, że porównywanie obiektów innych typów przy użyciu ``<`` lub "
"``>`` jest dozwolone pod warunkiem, że te obiekty mają odpowiednie metody "
"porównań. Na przykład mieszane typy numeryczne są porównywane w oparciu o "
"ich wartość numeryczną, tak że 0 równa się 0.0 i tak dalej. W innych "
"przypadkach, zamiast zwracać arbitralny porządek, interpreter zgłosi wyjątek"
" :exc:`TypeError`."

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:710
msgid "Footnotes"
msgstr "Przypisy"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/tutorial/datastructures.rst:711
msgid ""
"Other languages may return the mutated object, which allows method chaining,"
" such as ``d->insert(\"a\")->remove(\"b\")->sort();``."
msgstr ""
"Inne języki mogą zwracać zmieniony obiekt, co pozwala na łańcuchowanie "
"metod, na przykład ``d->insert(\"a\")->remove(\"b\")->sort();``."
