# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# telnetning <telnetning@gmail.com>, 2021
# Shengjing Zhu <zsj950618@gmail.com>, 2021
# df2dc1c92e792f7ae8417c51df43db8f_594d92a <0f49be28017426edb1db1a2ab6e67088_717605>, 2021
# Dai Xu <daixu61@hotmail.com>, 2022
# Bryan不可思议, 2023
# stone jing <stonejing1817@gmail.com>, 2023
# ppcfish <ppcfish@gmail.com>, 2023
# Alpha Du <alphanow@gmail.com>, 2023
# Freesand Leo <yuqinju@163.com>, 2023
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-07-28 14:13+0000\n"
"PO-Revision-Date: 2021-06-28 00:52+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2023\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/"
"teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/clinic.rst:7
msgid "Argument Clinic How-To"
msgstr "Argument Clinic 的用法"

#: ../../howto/clinic.rst:0
msgid "author"
msgstr "作者"

#: ../../howto/clinic.rst:9
msgid "Larry Hastings"
msgstr "Larry Hastings"

#: ../../howto/clinic.rst:11
msgid "**Source code:** :source:`Tools/clinic/clinic.py`."
msgstr "**源代码:** :source:`Tools/clinic/clinic.py`。"

#: ../../howto/clinic.rst:7
msgid "Abstract"
msgstr "摘要"

#: ../../howto/clinic.rst:15
msgid ""
"Argument Clinic is a preprocessor for CPython C files. Its purpose is to "
"automate all the boilerplate involved with writing argument parsing code for "
"\"builtins\", module level functions, and class methods. This document is "
"divided in four major sections:"
msgstr ""
"Argument Clinic 是一个针对 CPython 的 C 文件预处理器。 其目标是自动处理所有"
"与“内置函数”、模块层级函数和类方法的参数解析相关的代码。 本文档分为四个主要小"
"节:"

#: ../../howto/clinic.rst:21
msgid ""
":ref:`clinic-background` talks about the basic concepts and goals of "
"Argument Clinic."
msgstr ":ref:`clinic-background` 谈论有关 Argument Clinic 的基本概念和目标。"

#: ../../howto/clinic.rst:23
msgid ""
":ref:`clinic-reference` describes the command-line interface and Argument "
"Clinic terminology."
msgstr ":ref:`clinic-reference` 描述了命令行接口和 Argument Clinic 相关术语。"

#: ../../howto/clinic.rst:25
msgid ""
":ref:`clinic-tutorial` guides you through all the steps required to adapt an "
"existing C function to Argument Clinic."
msgstr ""
":ref:`clinic-tutorial` 指导你熟悉将现有 C 函数适配至 Argument Clinic 所需的所"
"有步骤。"

#: ../../howto/clinic.rst:27
msgid ":ref:`clinic-howtos` details how to handle specific tasks."
msgstr ":ref:`clinic-howtos` 详细介绍如何处理一些特定的任务。"

#: ../../howto/clinic.rst:32
msgid ""
"Argument Clinic is considered internal-only for CPython.  Its use is not "
"supported for files outside CPython, and no guarantees are made regarding "
"backwards compatibility for future versions.  In other words: if you "
"maintain an external C extension for CPython, you're welcome to experiment "
"with Argument Clinic in your own code.  But the version of Argument Clinic "
"that ships with the next version of CPython *could* be totally incompatible "
"and break all your code."
msgstr ""
"Argument Clinic 被视为仅供 CPython 内部使用。 它不支持在 CPython 以外的文件中"
"使用，也不保证未来版本会向下兼容。 换句话说：如果维护的是 CPython 的外部 C 扩"
"展，欢迎在你自己的代码中试用 Argument Clinic. 但是 Argument Clinic 当前版本与"
"新版 CPython 附带的版本 *可能* 完全不兼容并会破坏你的所有代码。"

#: ../../howto/clinic.rst:45
msgid "Background"
msgstr "背景"

#: ../../howto/clinic.rst:49
msgid "The goals of Argument Clinic"
msgstr "Argument Clinic 的设计目标"

#: ../../howto/clinic.rst:51
msgid ""
"Argument Clinic's primary goal is to take over responsibility for all "
"argument parsing code inside CPython.  This means that, when you convert a "
"function to work with Argument Clinic, that function should no longer do any "
"of its own argument parsing—the code generated by Argument Clinic should be "
"a \"black box\" to you, where CPython calls in at the top, and your code "
"gets called at the bottom, with ``PyObject *args`` (and maybe ``PyObject "
"*kwargs``) magically converted into the C variables and types you need."
msgstr ""
"Argument Clinic 的主要目标，是接管 CPython 中的所有参数解析代码。这意味着，如"
"果要把某个函数转换为配合 Argument Clinic一起工作，则该函数不应再作任何参数解"
"析工作——Argument Clinic 生成的代码应该是个“黑盒”，CPython 会在顶部发起调用，"
"底部则调用自己的代码， ``PyObject *args`` （也许还有 ``PyObject *kwargs`` ）"
"会神奇地转换成所需的 C 变量和类型。"

#: ../../howto/clinic.rst:61
msgid ""
"In order for Argument Clinic to accomplish its primary goal, it must be easy "
"to use.  Currently, working with CPython's argument parsing library is a "
"chore, requiring maintaining redundant information in a surprising number of "
"places. When you use Argument Clinic, you don't have to repeat yourself."
msgstr ""
"Argument Clinic 为了能完成主要目标，用起来必须方便。目前，使用 CPython 的参数"
"解析库是一件苦差事，需要在很多地方维护冗余信息。如果使用 Argument Clinic，则"
"不必再重复代码了。"

#: ../../howto/clinic.rst:67
msgid ""
"Obviously, no one would want to use Argument Clinic unless it's solving "
"their problem—and without creating new problems of its own. So it's "
"paramount that Argument Clinic generate correct code. It'd be nice if the "
"code was faster, too, but at the very least it should not introduce a major "
"speed regression.  (Eventually Argument Clinic *should* make a major speedup "
"possible—we could rewrite its code generator to produce tailor-made argument "
"parsing code, rather than calling the general-purpose CPython argument "
"parsing library.  That would make for the fastest argument parsing possible!)"
msgstr ""
"显然，除非 Argument Clinic 解决了自身的问题，且没有产生新的问题，否则没有人会"
"愿意用它。所以，Argument Clinic 最重要的事情就是生成正确的代码。如果能加速代"
"码的运行当然更好，但至少不应引入明显的减速。（最终 Argument Clinic *应该* 可"
"以实现较大的速度提升——代码生成器可以重写一下，以产生量身定做的参数解析代码，"
"而不是调用通用的 CPython 参数解析库。 这会让参数解析达到最佳速度！）"

#: ../../howto/clinic.rst:79
msgid ""
"Additionally, Argument Clinic must be flexible enough to work with any "
"approach to argument parsing.  Python has some functions with some very "
"strange parsing behaviors; Argument Clinic's goal is to support all of them."
msgstr ""
"此外，Argument Clinic 必须足够灵活，能够与任何参数解析的方法一起工作。Python "
"有一些函数具备一些非常奇怪的解析行为；Argument Clinic 的目标是支持所有这些函"
"数。"

#: ../../howto/clinic.rst:84
msgid ""
"Finally, the original motivation for Argument Clinic was to provide "
"introspection \"signatures\" for CPython builtins. It used to be, the "
"introspection query functions would throw an exception if you passed in a "
"builtin.  With Argument Clinic, that's a thing of the past!"
msgstr ""
"最后，Argument Clinic 的初衷是为 CPython 内置程序提供内省“签名”。以前如果传入"
"一个内置函数，内省查询函数会抛出异常。有了 Argument Clinic，再不会发生这种问"
"题了！"

#: ../../howto/clinic.rst:90
msgid ""
"One idea you should keep in mind, as you work with Argument Clinic: the more "
"information you give it, the better job it'll be able to do. Argument Clinic "
"is admittedly relatively simple right now.  But as it evolves it will get "
"more sophisticated, and it should be able to do many interesting and smart "
"things with all the information you give it."
msgstr ""
"在与 Argument Clinic 合作时，应该牢记一个理念：给它的信息越多，它做得就会越"
"好。诚然，Argument Clinic 现在还比较简单。但会演变得越来越复杂，应该能够利用"
"给出的全部信息干很多聪明而有趣的事情。"

#: ../../howto/clinic.rst:100
msgid "Basic concepts"
msgstr ""

#: ../../howto/clinic.rst:102
msgid ""
"When Argument Clinic is run on a file, either via the :ref:`clinic-cli` or "
"via ``make clinic``, it will scan over the input files looking for :term:"
"`start lines <start line>`:"
msgstr ""

#: ../../howto/clinic.rst:110
msgid "When it finds one, it reads everything up to the :term:`end line`:"
msgstr ""

#: ../../howto/clinic.rst:116
msgid ""
"Everything in between these two lines is Argument Clinic :term:`input`. When "
"Argument Clinic parses input, it generates :term:`output`. The output is "
"rewritten into the C file immediately after the input, followed by a :term:"
"`checksum line`. All of these lines, including the :term:`start line` and :"
"term:`checksum line`, are collectively called an Argument Clinic :term:"
"`block`:"
msgstr ""

#: ../../howto/clinic.rst:131
msgid ""
"If you run Argument Clinic on the same file a second time, Argument Clinic "
"will discard the old :term:`output` and write out the new output with a "
"fresh :term:`checksum line`. If the :term:`input` hasn't changed, the output "
"won't change either."
msgstr ""

#: ../../howto/clinic.rst:138
msgid ""
"You should never modify the output of an Argument Clinic block, as any "
"change will be lost in future Argument Clinic runs; Argument Clinic will "
"detect an output checksum mismatch and regenerate the correct output. If you "
"are not happy with the generated output, you should instead change the input "
"until it produces the output you want."
msgstr ""

#: ../../howto/clinic.rst:149
msgid "Reference"
msgstr "参考"

#: ../../howto/clinic.rst:155
msgid "Terminology"
msgstr "术语"

#: ../../howto/clinic.rst:158
msgid "start line"
msgstr ""

#: ../../howto/clinic.rst:160
msgid ""
"The line ``/*[clinic input]``. This line marks the beginning of Argument "
"Clinic input. Note that the *start line* opens a C block comment."
msgstr ""

#: ../../howto/clinic.rst:163
msgid "end line"
msgstr ""

#: ../../howto/clinic.rst:165
msgid ""
"The line ``[clinic start generated code]*/``. The *end line* marks the _end_ "
"of Argument Clinic :term:`input`, but at the same time marks the _start_ of "
"Argument Clinic :term:`output`, thus the text *\"clinic start start "
"generated code\"* Note that the *end line* closes the C block comment opened "
"by the *start line*."
msgstr ""

#: ../../howto/clinic.rst:171
msgid "checksum"
msgstr "checksum"

#: ../../howto/clinic.rst:173
msgid ""
"A hash to distinguish unique :term:`inputs <input>` and :term:`outputs "
"<output>`."
msgstr ""

#: ../../howto/clinic.rst:175
msgid "checksum line"
msgstr ""

#: ../../howto/clinic.rst:177
msgid ""
"A line that looks like ``/*[clinic end generated code: ...]*/``. The three "
"dots will be replaced by a :term:`checksum` generated from the :term:"
"`input`, and a :term:`checksum` generated from the :term:`output`. The "
"checksum line marks the end of Argument Clinic generated code, and is used "
"by Argument Clinic to determine if it needs to regenerate output."
msgstr ""

#: ../../howto/clinic.rst:183
msgid "input"
msgstr "输入"

#: ../../howto/clinic.rst:185
msgid ""
"The text between the :term:`start line` and the :term:`end line`. Note that "
"the start and end lines open and close a C block comment; the *input* is "
"thus a part of that same C block comment."
msgstr ""

#: ../../howto/clinic.rst:188
msgid "output"
msgstr "output"

#: ../../howto/clinic.rst:190
msgid "The text between the :term:`end line` and the :term:`checksum line`."
msgstr ""

#: ../../howto/clinic.rst:191
msgid "block"
msgstr "block"

#: ../../howto/clinic.rst:193
msgid ""
"All text from the :term:`start line` to the :term:`checksum line` "
"inclusively."
msgstr ""

#: ../../howto/clinic.rst:199
msgid "Command-line interface"
msgstr ""

#: ../../howto/clinic.rst:201
msgid ""
"The Argument Clinic :abbr:`CLI (Command-Line Interface)` is typically used "
"to process a single source file, like this:"
msgstr ""

#: ../../howto/clinic.rst:208
msgid "The CLI supports the following options:"
msgstr ""

#: ../../howto/clinic.rst:215
msgid "Print CLI usage."
msgstr ""

#: ../../howto/clinic.rst:219
msgid "Force output regeneration."
msgstr ""

#: ../../howto/clinic.rst:223
msgid "Redirect file output to OUTPUT"
msgstr ""

#: ../../howto/clinic.rst:227
msgid "Enable verbose mode."
msgstr ""

#: ../../howto/clinic.rst:231
msgid "Print a list of all supported converters and return converters."
msgstr ""

#: ../../howto/clinic.rst:235
msgid "Walk :option:`--srcdir` to run over all relevant files."
msgstr ""

#: ../../howto/clinic.rst:239
msgid "The directory tree to walk in :option:`--make` mode."
msgstr ""

#: ../../howto/clinic.rst:243
msgid "The list of files to process."
msgstr ""

#: ../../howto/clinic.rst:249
msgid "Tutorial"
msgstr "教程"

#: ../../howto/clinic.rst:251
msgid ""
"The best way to get a sense of how Argument Clinic works is to convert a "
"function to work with it.  Here, then, are the bare minimum steps you'd need "
"to follow to convert a function to work with Argument Clinic.  Note that for "
"code you plan to check in to CPython, you really should take the conversion "
"farther, using some of the :ref:`advanced concepts <clinic-howtos>` you'll "
"see later on in the document, like :ref:`clinic-howto-return-converters` "
"and :ref:`clinic-howto-self-converter`. But we'll keep it simple for this "
"walkthrough so you can learn."
msgstr ""

#: ../../howto/clinic.rst:262
msgid ""
"First, make sure you're working with a freshly updated checkout of the "
"CPython trunk."
msgstr ""

#: ../../howto/clinic.rst:265
msgid ""
"Next, find a Python builtin that calls either :c:func:`PyArg_ParseTuple` or :"
"c:func:`PyArg_ParseTupleAndKeywords`, and hasn't been converted to work with "
"Argument Clinic yet. For this tutorial, we'll be using :py:meth:`_pickle."
"Pickler.dump <pickle.Pickler.dump>`."
msgstr ""

#: ../../howto/clinic.rst:271
msgid ""
"If the call to the :c:func:`!PyArg_Parse*` function uses any of the "
"following format units...:"
msgstr ""

#: ../../howto/clinic.rst:283
msgid ""
"... or if it has multiple calls to :c:func:`PyArg_ParseTuple`, you should "
"choose a different function. (See :ref:`clinic-howto-advanced-converters` "
"for those scenarios.)"
msgstr ""

#: ../../howto/clinic.rst:287
msgid ""
"Also, if the function has multiple calls to :c:func:`!PyArg_ParseTuple` or :"
"c:func:`PyArg_ParseTupleAndKeywords` where it supports different types for "
"the same argument, or if the function uses something besides :c:func:`!"
"PyArg_Parse*` functions to parse its arguments, it probably isn't suitable "
"for conversion to Argument Clinic.  Argument Clinic doesn't support generic "
"functions or polymorphic parameters."
msgstr ""

#: ../../howto/clinic.rst:294
msgid ""
"Next, add the following boilerplate above the function, creating our input "
"block::"
msgstr ""

#: ../../howto/clinic.rst:300
msgid ""
"Cut the docstring and paste it in between the ``[clinic]`` lines, removing "
"all the junk that makes it a properly quoted C string. When you're done you "
"should have just the text, based at the left margin, with no line wider than "
"80 characters. Argument Clinic will preserve indents inside the docstring."
msgstr ""

#: ../../howto/clinic.rst:306
msgid ""
"If the old docstring had a first line that looked like a function signature, "
"throw that line away; The docstring doesn't need it anymore --- when you "
"use :py:func:`help` on your builtin in the future, the first line will be "
"built automatically based on the function's signature."
msgstr ""

#: ../../howto/clinic.rst:311
msgid "Example docstring summary line::"
msgstr ""

#: ../../howto/clinic.rst:317
msgid ""
"If your docstring doesn't have a \"summary\" line, Argument Clinic will "
"complain, so let's make sure it has one.  The \"summary\" line should be a "
"paragraph consisting of a single 80-column line at the beginning of the "
"docstring. (See :pep:`257` regarding docstring conventions.)"
msgstr ""

#: ../../howto/clinic.rst:323
msgid ""
"Our example docstring consists solely of a summary line, so the sample code "
"doesn't have to change for this step."
msgstr ""

#: ../../howto/clinic.rst:326
msgid ""
"Now, above the docstring, enter the name of the function, followed by a "
"blank line.  This should be the Python name of the function, and should be "
"the full dotted path to the function --- it should start with the name of "
"the module, include any sub-modules, and if the function is a method on a "
"class it should include the class name too."
msgstr ""

#: ../../howto/clinic.rst:333
msgid ""
"In our example, :mod:`!_pickle` is the module, :py:class:`!Pickler` is the "
"class, and :py:meth:`!dump` is the method, so the name becomes :py:meth:`!"
"_pickle.Pickler.dump`::"
msgstr ""

#: ../../howto/clinic.rst:343
msgid ""
"If this is the first time that module or class has been used with Argument "
"Clinic in this C file, you must declare the module and/or class.  Proper "
"Argument Clinic hygiene prefers declaring these in a separate block "
"somewhere near the top of the C file, in the same way that include files and "
"statics go at the top. In our sample code we'll just show the two blocks "
"next to each other."
msgstr ""

#: ../../howto/clinic.rst:351
msgid ""
"The name of the class and module should be the same as the one seen by "
"Python.  Check the name defined in the :c:type:`PyModuleDef` or :c:type:"
"`PyTypeObject` as appropriate."
msgstr ""
"类和模块的名称应与暴露给 Python 的相同。请适时检查 :c:type:`PyModuleDef` 或 :"
"c:type:`PyTypeObject` 中定义的名称。"

#: ../../howto/clinic.rst:355
msgid ""
"When you declare a class, you must also specify two aspects of its type in "
"C: the type declaration you'd use for a pointer to an instance of this "
"class, and a pointer to the :c:type:`!PyTypeObject` for this class::"
msgstr ""

#: ../../howto/clinic.rst:370
msgid ""
"Declare each of the parameters to the function.  Each parameter should get "
"its own line.  All the parameter lines should be indented from the function "
"name and the docstring. The general form of these parameter lines is as "
"follows:"
msgstr ""

#: ../../howto/clinic.rst:379
msgid "If the parameter has a default value, add that after the converter:"
msgstr "如果参数带有缺省值，请加在转换器之后："

#: ../../howto/clinic.rst:386
msgid ""
"Argument Clinic's support for \"default values\" is quite sophisticated; "
"see :ref:`clinic-howto-default-values` for more information."
msgstr ""

#: ../../howto/clinic.rst:389
msgid "Next, add a blank line below the parameters."
msgstr ""

#: ../../howto/clinic.rst:391
msgid ""
"What's a \"converter\"? It establishes both the type of the variable used in "
"C, and the method to convert the Python value into a C value at runtime. For "
"now you're going to use what's called a \"legacy converter\" --- a "
"convenience syntax intended to make porting old code into Argument Clinic "
"easier."
msgstr ""

#: ../../howto/clinic.rst:398
msgid ""
"For each parameter, copy the \"format unit\" for that parameter from the :c:"
"func:`PyArg_Parse` format argument and specify *that* as its converter, as a "
"quoted string. The \"format unit\" is the formal name for the one-to-three "
"character substring of the *format* parameter that tells the argument "
"parsing function what the type of the variable is and how to convert it. For "
"more on format units please see :ref:`arg-parsing`."
msgstr ""

#: ../../howto/clinic.rst:407
msgid ""
"For multicharacter format units like ``z#``, use the entire two-or-three "
"character string."
msgstr "对于像 ``z#`` 这样的多字符格式单元，要使用2-3个字符组成的整个字符串。"

#: ../../howto/clinic.rst:410 ../../howto/clinic.rst:445
#: ../../howto/clinic.rst:473 ../../howto/clinic.rst:579
#: ../../howto/clinic.rst:632
msgid "Sample::"
msgstr "示例："

#: ../../howto/clinic.rst:425
msgid ""
"If your function has ``|`` in the format string, meaning some parameters "
"have default values, you can ignore it. Argument Clinic infers which "
"parameters are optional based on whether or not they have default values."
msgstr ""

#: ../../howto/clinic.rst:430
msgid ""
"If your function has ``$`` in the format string, meaning it takes keyword-"
"only arguments, specify ``*`` on a line by itself before the first keyword-"
"only argument, indented the same as the parameter lines."
msgstr ""
"如果函数的格式字符串中包含 $，意味着只接受关键字参数，请在第一个关键字参数之"
"前单独给出一行 ``*``，缩进与参数行对齐。"

#: ../../howto/clinic.rst:435
msgid ""
":py:meth:`!_pickle.Pickler.dump` has neither, so our sample is unchanged."
msgstr ""

#: ../../howto/clinic.rst:437
msgid ""
"Next, if the existing C function calls :c:func:`PyArg_ParseTuple` (as "
"opposed to :c:func:`PyArg_ParseTupleAndKeywords`), then all its arguments "
"are positional-only."
msgstr ""

#: ../../howto/clinic.rst:441
msgid ""
"To mark parameters as positional-only in Argument Clinic, add a ``/`` on a "
"line by itself after the last positional-only parameter, indented the same "
"as the parameter lines."
msgstr ""

#: ../../howto/clinic.rst:461
msgid ""
"It can be helpful to write a per-parameter docstring for each parameter. "
"Since per-parameter docstrings are optional, you can skip this step if you "
"prefer."
msgstr ""

#: ../../howto/clinic.rst:465
msgid ""
"Nevertheless, here's how to add a per-parameter docstring. The first line of "
"the per-parameter docstring must be indented further than the parameter "
"definition. The left margin of this first line establishes the left margin "
"for the whole per-parameter docstring; all the text you write will be "
"outdented by this amount. You can write as much text as you like, across "
"multiple lines if you wish."
msgstr ""

#: ../../howto/clinic.rst:490
msgid ""
"Save and close the file, then run ``Tools/clinic/clinic.py`` on it. With "
"luck everything worked---your block now has output, and a :file:`.c.h` file "
"has been generated! Reload the file in your text editor to see the generated "
"code::"
msgstr ""

#: ../../howto/clinic.rst:509
msgid ""
"Obviously, if Argument Clinic didn't produce any output, it's because it "
"found an error in your input. Keep fixing your errors and retrying until "
"Argument Clinic processes your file without complaint."
msgstr ""

#: ../../howto/clinic.rst:514
msgid ""
"For readability, most of the glue code has been generated to a :file:`.c.h` "
"file.  You'll need to include that in your original :file:`.c` file, "
"typically right after the clinic module block::"
msgstr ""

#: ../../howto/clinic.rst:520
msgid ""
"Double-check that the argument-parsing code Argument Clinic generated looks "
"basically the same as the existing code."
msgstr ""
"请仔细检查 Argument Clinic 生成的参数解析代码，是否与原有代码基本相同。"

#: ../../howto/clinic.rst:523
msgid ""
"First, ensure both places use the same argument-parsing function. The "
"existing code must call either :c:func:`PyArg_ParseTuple` or :c:func:"
"`PyArg_ParseTupleAndKeywords`; ensure that the code generated by Argument "
"Clinic calls the *exact* same function."
msgstr ""
"首先，确保两种代码使用相同的参数解析函数。原有代码必须调用  :c:func:"
"`PyArg_ParseTuple` 或 :c:func:`PyArg_ParseTupleAndKeywords` ；确保 Argument "
"Clinic 生成的代码调用 *完全* 相同的函数。"

#: ../../howto/clinic.rst:529
msgid ""
"Second, the format string passed in to :c:func:`!PyArg_ParseTuple` or :c:"
"func:`!PyArg_ParseTupleAndKeywords` should be *exactly* the same as the hand-"
"written one in the existing function, up to the colon or semi-colon."
msgstr ""

#: ../../howto/clinic.rst:534
msgid ""
"Argument Clinic always generates its format strings with a ``:`` followed by "
"the name of the function. If the existing code's format string ends with ``;"
"``, to provide usage help, this change is harmless --- don't worry about it."
msgstr ""

#: ../../howto/clinic.rst:539
msgid ""
"Third, for parameters whose format units require two arguments, like a "
"length variable, an encoding string, or a pointer to a conversion function, "
"ensure that the second argument is *exactly* the same between the two "
"invocations."
msgstr ""

#: ../../howto/clinic.rst:544
msgid ""
"Fourth, inside the output portion of the block, you'll find a preprocessor "
"macro defining the appropriate static :c:type:`PyMethodDef` structure for "
"this builtin::"
msgstr ""

#: ../../howto/clinic.rst:551
msgid ""
"This static structure should be *exactly* the same as the existing static :c:"
"type:`!PyMethodDef` structure for this builtin."
msgstr ""

#: ../../howto/clinic.rst:554
msgid ""
"If any of these items differ in *any way*, adjust your Argument Clinic "
"function specification and rerun ``Tools/clinic/clinic.py`` until they *are* "
"the same."
msgstr ""
"只要上述这几点存在不一致，请调整 Argument Clinic 函数定义，并重新运行 "
"``Tools/clinic/clinic.py`` ，直至 *完全* 相同。"

#: ../../howto/clinic.rst:558
msgid ""
"Notice that the last line of its output is the declaration of your \"impl\" "
"function.  This is where the builtin's implementation goes. Delete the "
"existing prototype of the function you're modifying, but leave the opening "
"curly brace.  Now delete its argument parsing code and the declarations of "
"all the variables it dumps the arguments into. Notice how the Python "
"arguments are now arguments to this impl function; if the implementation "
"used different names for these variables, fix it."
msgstr ""
"注意，输出部分的最后一行是“实现”函数的声明。也就是该内置函数的实现代码所在。"
"删除需要修改的函数的现有原型，但保留开头的大括号。再删除其参数解析代码和输入"
"变量的所有声明。注意现在 Python 所见的参数即为此实现函数的参数；如果实现代码"
"给这些变量采用了不同的命名，请进行修正。"

#: ../../howto/clinic.rst:566
msgid ""
"Let's reiterate, just because it's kind of weird. Your code should now look "
"like this::"
msgstr ""

#: ../../howto/clinic.rst:575
msgid ""
"Argument Clinic generated the checksum line and the function prototype just "
"above it.  You should write the opening and closing curly braces for the "
"function, and the implementation inside."
msgstr ""

#: ../../howto/clinic.rst:621
msgid ""
"Remember the macro with the :c:type:`PyMethodDef` structure for this "
"function? Find the existing :c:type:`!PyMethodDef` structure for this "
"function and replace it with a reference to the macro.  If the builtin is at "
"module scope, this will probably be very near the end of the file; if the "
"builtin is a class method, this will probably be below but relatively near "
"to the implementation."
msgstr ""

#: ../../howto/clinic.rst:628
msgid ""
"Note that the body of the macro contains a trailing comma; when you replace "
"the existing static :c:type:`!PyMethodDef` structure with the macro, *don't* "
"add a comma to the end."
msgstr ""

#: ../../howto/clinic.rst:640
msgid "Argument Clinic may generate new instances of ``_Py_ID``. For example::"
msgstr "Argument Clinic 可能生成新的 ``_Py_ID`` 实例。 举例来说::"

#: ../../howto/clinic.rst:644
msgid ""
"If it does, you'll have to run ``make regen-global-objects`` to regenerate "
"the list of precompiled identifiers at this point."
msgstr ""

#: ../../howto/clinic.rst:647
msgid ""
"Finally, compile, then run the relevant portions of the regression-test "
"suite. This change should not introduce any new compile-time warnings or "
"errors, and there should be no externally visible change to Python's "
"behavior, except for one difference: :py:func:`inspect.signature` run on "
"your function should now provide a valid signature!"
msgstr ""

#: ../../howto/clinic.rst:653
msgid ""
"Congratulations, you've ported your first function to work with Argument "
"Clinic!"
msgstr "祝贺你，现在已经用 Argument Clinic 移植了第一个函数。"

#: ../../howto/clinic.rst:659
msgid "How-to guides"
msgstr "常用方案指引"

#: ../../howto/clinic.rst:663
msgid "How to rename C functions and variables generated by Argument Clinic"
msgstr ""

#: ../../howto/clinic.rst:665
msgid ""
"Argument Clinic automatically names the functions it generates for you. "
"Occasionally this may cause a problem, if the generated name collides with "
"the name of an existing C function.  There's an easy solution: override the "
"names used for the C functions.  Just add the keyword ``\"as\"`` to your "
"function declaration line, followed by the function name you wish to use. "
"Argument Clinic will use that function name for the base (generated) "
"function, then add ``\"_impl\"`` to the end and use that for the name of the "
"impl function."
msgstr ""
"Argument Clinic 会自动为其生成的函数命名。如果生成的名称与现有的 C 函数冲突，"
"这偶尔可能会造成问题，有一个简单的解决方案：覆盖 C 函数的名称。只要在函数声明"
"中加入关键字 ``\"as\"`` ，然后再加上要使用的函数名。Argument Clinic 将以该函"
"数名为基础作为（生成的）函数名，然后在后面加上 ``\"_impl\"``，并用作实现函数"
"的名称。"

#: ../../howto/clinic.rst:673
msgid ""
"For example, if we wanted to rename the C function names generated for :py:"
"meth:`pickle.Pickler.dump`, it'd look like this::"
msgstr ""

#: ../../howto/clinic.rst:681
msgid ""
"The base function would now be named :c:func:`!pickler_dumper`, and the impl "
"function would now be named :c:func:`!pickler_dumper_impl`."
msgstr ""

#: ../../howto/clinic.rst:685
msgid ""
"Similarly, you may have a problem where you want to give a parameter a "
"specific Python name, but that name may be inconvenient in C.  Argument "
"Clinic allows you to give a parameter different names in Python and in C, "
"using the same ``\"as\"`` syntax::"
msgstr ""
"同样的问题依然会出现：想给某个参数取个 Python 用名，但在 C 语言中可能用不了。"
"Argument Clinic 允许在 Python 和 C 中为同一个参数取不同的名字，依然是利用 "
"``\"as\"`` 语法："

#: ../../howto/clinic.rst:699
msgid ""
"Here, the name used in Python (in the signature and the ``keywords`` array) "
"would be *file*, but the C variable would be named ``file_obj``."
msgstr ""

#: ../../howto/clinic.rst:702
msgid "You can use this to rename the *self* parameter too!"
msgstr ""

#: ../../howto/clinic.rst:706
msgid "How to convert functions using ``PyArg_UnpackTuple``"
msgstr "如何转换使用 ``PyArg_UnpackTuple`` 的函数"

#: ../../howto/clinic.rst:708
msgid ""
"To convert a function parsing its arguments with :c:func:"
"`PyArg_UnpackTuple`, simply write out all the arguments, specifying each as "
"an ``object``.  You may specify the *type* argument to cast the type as "
"appropriate.  All arguments should be marked positional-only (add a ``/`` on "
"a line by itself after the last argument)."
msgstr ""

#: ../../howto/clinic.rst:714
msgid ""
"Currently the generated code will use :c:func:`PyArg_ParseTuple`, but this "
"will change soon."
msgstr ""
"目前，所生成的代码将会用到 :c:func:`PyArg_ParseTuple` ，但很快会做出改动。"

#: ../../howto/clinic.rst:719
msgid "How to use optional groups"
msgstr "如何使用可选分组"

#: ../../howto/clinic.rst:721
msgid ""
"Some legacy functions have a tricky approach to parsing their arguments: "
"they count the number of positional arguments, then use a ``switch`` "
"statement to call one of several different :c:func:`PyArg_ParseTuple` calls "
"depending on how many positional arguments there are.  (These functions "
"cannot accept keyword-only arguments.)  This approach was used to simulate "
"optional arguments back before :c:func:`PyArg_ParseTupleAndKeywords` was "
"created."
msgstr ""
"有些过时的函数用到了一种让人头疼的函数解析方式：计算位置参数的数量，据此用 "
"``switch`` 语句进行各个不同的 :c:func:`PyArg_ParseTuple` 调用。（这些函数不能"
"接受只认关键字的参数。）在没有 :c:func:`PyArg_ParseTupleAndKeywords` 之前，这"
"种方式曾被用于模拟可选参数。"

#: ../../howto/clinic.rst:728
msgid ""
"While functions using this approach can often be converted to use :c:func:`!"
"PyArg_ParseTupleAndKeywords`, optional arguments, and default values, it's "
"not always possible.  Some of these legacy functions have behaviors :c:func:"
"`!PyArg_ParseTupleAndKeywords` doesn't directly support. The most obvious "
"example is the builtin function :py:func:`range`, which has an optional "
"argument on the *left* side of its required argument! Another example is :py:"
"meth:`curses.window.addch`, which has a group of two arguments that must "
"always be specified together.  (The arguments are called *x* and *y*; if you "
"call the function passing in *x*, you must also pass in *y* — and if you "
"don't pass in *x* you may not pass in *y* either.)"
msgstr ""

#: ../../howto/clinic.rst:740
msgid ""
"In any case, the goal of Argument Clinic is to support argument parsing for "
"all existing CPython builtins without changing their semantics. Therefore "
"Argument Clinic supports this alternate approach to parsing, using what are "
"called *optional groups*. Optional groups are groups of arguments that must "
"all be passed in together. They can be to the left or the right of the "
"required arguments.  They can *only* be used with positional-only parameters."
msgstr ""
"不管怎么说，Argument Clinic 的目标就是在不改变语义的情况下支持所有现有 "
"CPython 内置参数的解析。因此，Argument Clinic 采用所谓的 *可选组* 方案来支持"
"这种解析方式。可选组是必须一起传入的参数组。他们可以在必需参数的左边或右边，*"
"只能* 用于只认位置的参数。"

#: ../../howto/clinic.rst:748
msgid ""
"Optional groups are *only* intended for use when converting functions that "
"make multiple calls to :c:func:`PyArg_ParseTuple`! Functions that use *any* "
"other approach for parsing arguments should *almost never* be converted to "
"Argument Clinic using optional groups.  Functions using optional groups "
"currently cannot have accurate signatures in Python, because Python just "
"doesn't understand the concept.  Please avoid using optional groups wherever "
"possible."
msgstr ""
"可选组 *仅* 适用于多次调用 :c:func:`PyArg_ParseTuple` 的函数！采用 *任何* 其"
"他方式解析参数的函数，应该 *几乎不* 采用可选组转换为 Argument Clinic 解析。目"
"前，采用可选组的函数在 Python 中无法获得准确的签名，因为 Python 不能理解这个"
"概念。请尽可能避免使用可选组。"

#: ../../howto/clinic.rst:757
msgid ""
"To specify an optional group, add a ``[`` on a line by itself before the "
"parameters you wish to group together, and a ``]`` on a line by itself after "
"these parameters.  As an example, here's how :py:meth:`curses.window.addch` "
"uses optional groups to make the first two parameters and the last parameter "
"optional::"
msgstr ""

#: ../../howto/clinic.rst:786
msgid "Notes:"
msgstr "注："

#: ../../howto/clinic.rst:788
msgid ""
"For every optional group, one additional parameter will be passed into the "
"impl function representing the group.  The parameter will be an int named "
"``group_{direction}_{number}``, where ``{direction}`` is either ``right`` or "
"``left`` depending on whether the group is before or after the required "
"parameters, and ``{number}`` is a monotonically increasing number (starting "
"at 1) indicating how far away the group is from the required parameters.  "
"When the impl is called, this parameter will be set to zero if this group "
"was unused, and set to non-zero if this group was used. (By used or unused, "
"I mean whether or not the parameters received arguments in this invocation.)"
msgstr ""
"每一个可选组，都会额外传入一个代表分组的参数。 参数为 int 型，名为 "
"``group_{direction}_{number}``，其中 ``{direction}`` 取决于此参数组位于必需参"
"数 ``right`` 还是 ``left``，而 ``{number}`` 是一个递增数字（从 1 开始），表示"
"此参数组与必需参数之间的距离。 在调用函数时，若未用到此参数组则此参数将设为"
"零，若用到了参数组则该参数为非零。 所谓的用到或未用到，是指在本次调用中形参是"
"否收到了实参。"

#: ../../howto/clinic.rst:799
msgid ""
"If there are no required arguments, the optional groups will behave as if "
"they're to the right of the required arguments."
msgstr "如果不存在必需参数，可选组的行为等同于出现在必需参数的右侧。"

#: ../../howto/clinic.rst:802
msgid ""
"In the case of ambiguity, the argument parsing code favors parameters on the "
"left (before the required parameters)."
msgstr "在模棱两可的情况下，参数解析代码更倾向于参数左侧（在必需参数之前）。"

#: ../../howto/clinic.rst:805
msgid "Optional groups can only contain positional-only parameters."
msgstr "可选组只能包含只认位置的参数。"

#: ../../howto/clinic.rst:807
msgid ""
"Optional groups are *only* intended for legacy code.  Please do not use "
"optional groups for new code."
msgstr "可选组 *仅限* 用于过时代码。请勿在新的代码中使用可选组。"

#: ../../howto/clinic.rst:812
msgid ""
"How to use real Argument Clinic converters, instead of \"legacy converters\""
msgstr "如何使用真正的 Argument Clinic 转换器，而不是“旧式转换器”"

#: ../../howto/clinic.rst:814
msgid ""
"To save time, and to minimize how much you need to learn to achieve your "
"first port to Argument Clinic, the walkthrough above tells you to use "
"\"legacy converters\".  \"Legacy converters\" are a convenience, designed "
"explicitly to make porting existing code to Argument Clinic easier.  And to "
"be clear, their use is acceptable when porting code for Python 3.4."
msgstr ""
"为了节省时间，尽量减少要学习的内容，实现第一次适用 Argument Clinic 的移植，上"
"述练习简述的是“传统转换器”的用法。“传统转换器”只是一种简便用法，目的就是更容"
"易地让现有代码移植为适用于 Argument Clinic 。说白了，在移植 Python 3.4 的代码"
"时，可以考虑采用。"

#: ../../howto/clinic.rst:821
msgid ""
"However, in the long term we probably want all our blocks to use Argument "
"Clinic's real syntax for converters.  Why?  A couple reasons:"
msgstr ""
"不过从长远来看，可能希望所有代码块都采用真正的 Argument Clinic 转换器语法。原"
"因如下："

#: ../../howto/clinic.rst:825
msgid ""
"The proper converters are far easier to read and clearer in their intent."
msgstr "合适的转换器可读性更好，意图也更清晰。"

#: ../../howto/clinic.rst:826
msgid ""
"There are some format units that are unsupported as \"legacy converters\", "
"because they require arguments, and the legacy converter syntax doesn't "
"support specifying arguments."
msgstr ""
"有些格式单元是“传统转换器”无法支持的，因为这些格式需要带上参数，而传统转换器"
"的语法不支持指定参数。"

#: ../../howto/clinic.rst:829
msgid ""
"In the future we may have a new argument parsing library that isn't "
"restricted to what :c:func:`PyArg_ParseTuple` supports; this flexibility "
"won't be available to parameters using legacy converters."
msgstr ""
"后续可能会有新版的参数解析库，提供超过 :c:func:`PyArg_ParseTuple` 支持的功"
"能；而这种灵活性将无法适用于传统转换器转换的参数。"

#: ../../howto/clinic.rst:833
msgid ""
"Therefore, if you don't mind a little extra effort, please use the normal "
"converters instead of legacy converters."
msgstr "因此，若是不介意多花一点精力，请使用正常的转换器，而不是传统转换器。"

#: ../../howto/clinic.rst:836
msgid ""
"In a nutshell, the syntax for Argument Clinic (non-legacy) converters looks "
"like a Python function call.  However, if there are no explicit arguments to "
"the function (all functions take their default values), you may omit the "
"parentheses.  Thus ``bool`` and ``bool()`` are exactly the same converters."
msgstr ""
"简而言之，Argument Clinic（非传统）转换器的语法看起来像是 Python 函数调用。但"
"如果函数没有明确的参数（所有函数都取默认值），则可以省略括号。因此 ``bool`` "
"和 ``bool()`` 是完全相同的转换器。"

#: ../../howto/clinic.rst:842
msgid ""
"All arguments to Argument Clinic converters are keyword-only. All Argument "
"Clinic converters accept the following arguments:"
msgstr ""
"Argument Clinic 转换器的所有参数都只认关键字。所有 Argument Clinic 转换器均可"
"接受以下参数："

#: ../../howto/clinic.rst:850
msgid "*c_default*"
msgstr ""

#: ../../howto/clinic.rst:846
msgid ""
"The default value for this parameter when defined in C. Specifically, this "
"will be the initializer for the variable declared in the \"parse "
"function\".  See :ref:`the section on default values <default_values>` for "
"how to use this. Specified as a string."
msgstr ""
"该参数在 C 语言中的默认值。具体来说，将是在“解析函数”中声明的变量的初始化器。"
"用法参见 :ref:`the section on default values <default_values>` 。定义为字符"
"串。"

#: ../../howto/clinic.rst:855
msgid "*annotation*"
msgstr ""

#: ../../howto/clinic.rst:853
msgid ""
"The annotation value for this parameter.  Not currently supported, because :"
"pep:`8` mandates that the Python library may not use annotations."
msgstr "参数的注解值。目前尚不支持，因为 :pep:`8` 规定 Python 库不得使用注解。"

#: ../../howto/clinic.rst:858
msgid "*unused*"
msgstr ""

#: ../../howto/clinic.rst:858
msgid ""
"Wrap the argument with :c:macro:`Py_UNUSED` in the impl function signature."
msgstr "在 impl 函数签名中用 :c:macro:`Py_UNUSED` 来包装函数。"

#: ../../howto/clinic.rst:860
msgid ""
"In addition, some converters accept additional arguments.  Here is a list of "
"these arguments, along with their meanings:"
msgstr "此外，某些转换器还可接受额外的参数。下面列出了这些额外参数及其含义："

#: ../../howto/clinic.rst:869
msgid "*accept*"
msgstr ""

#: ../../howto/clinic.rst:864
msgid ""
"A set of Python types (and possibly pseudo-types); this restricts the "
"allowable Python argument to values of these types. (This is not a general-"
"purpose facility; as a rule it only supports specific lists of types as "
"shown in the legacy converter table.)"
msgstr ""
"一些 Python 类型的集合（可能还有伪类型）；用于限制只接受这些类型的 Python 参"
"数。（并非通用特性；只支持传统转换器列表中给出的类型）。"

#: ../../howto/clinic.rst:869
msgid "To accept ``None``, add ``NoneType`` to this set."
msgstr "若要能接受 ``None``，请在集合中添加 ``NoneType``。"

#: ../../howto/clinic.rst:874
msgid "*bitwise*"
msgstr ""

#: ../../howto/clinic.rst:872
msgid ""
"Only supported for unsigned integers.  The native integer value of this "
"Python argument will be written to the parameter without any range checking, "
"even for negative values."
msgstr ""
"仅用于无符号整数。写入形参的将是 Python 实参的原生整数值，不做任何越界检查，"
"即便是负值也一样。"

#: ../../howto/clinic.rst:879
msgid "*converter*"
msgstr ""

#: ../../howto/clinic.rst:877
msgid ""
"Only supported by the ``object`` converter.  Specifies the name of a :ref:`C "
"\"converter function\" <o_ampersand>` to use to convert this object to a "
"native type."
msgstr ""
"仅用于 ``object`` 转换器。为某个 :ref:`C 转换函数 <o_ampersand>` 指定名称，用"
"于将对象转换为原生类型。"

#: ../../howto/clinic.rst:884
msgid "*encoding*"
msgstr "*encoding*"

#: ../../howto/clinic.rst:882
msgid ""
"Only supported for strings.  Specifies the encoding to use when converting "
"this string from a Python str (Unicode) value into a C ``char *`` value."
msgstr ""
"仅用于字符串。指定将 Python str(Unicode) 转换为 C 语言的 ``char *`` 时应该采"
"用的编码。"

#: ../../howto/clinic.rst:888
msgid "*subclass_of*"
msgstr ""

#: ../../howto/clinic.rst:887
msgid ""
"Only supported for the ``object`` converter.  Requires that the Python value "
"be a subclass of a Python type, as expressed in C."
msgstr ""
"仅用于 ``object`` 转换器。要求 Python 值是 Python 类型的子类，用 C 语言表示。"

#: ../../howto/clinic.rst:893
msgid "*type*"
msgstr ""

#: ../../howto/clinic.rst:891
msgid ""
"Only supported for the ``object`` and ``self`` converters.  Specifies the C "
"type that will be used to declare the variable.  Default value is "
"``\"PyObject *\"``."
msgstr ""
"仅用于 ``object`` 和 ``self`` 转换器。指定用于声明变量的 C 类型。 默认值是 "
"``\"PyObject *\"``。"

#: ../../howto/clinic.rst:899
msgid "*zeroes*"
msgstr ""

#: ../../howto/clinic.rst:896
msgid ""
"Only supported for strings.  If true, embedded NUL bytes (``'\\\\0'``) are "
"permitted inside the value.  The length of the string will be passed in to "
"the impl function, just after the string parameter, as a parameter named "
"``<parameter_name>_length``."
msgstr ""
"仅用于字符串。如果为 True，则允许在值中嵌入 NUL 字节（``'\\\\0'``）。字符串的"
"长度将通过名为 ``<parameter_name>_length`` 的参数传入，跟在字符串参数的后面。"

#: ../../howto/clinic.rst:901
msgid ""
"Please note, not every possible combination of arguments will work. Usually "
"these arguments are implemented by specific :c:func:`PyArg_ParseTuple` "
"*format units*, with specific behavior.  For example, currently you cannot "
"call ``unsigned_short`` without also specifying ``bitwise=True``. Although "
"it's perfectly reasonable to think this would work, these semantics don't "
"map to any existing format unit.  So Argument Clinic doesn't support it.  "
"(Or, at least, not yet.)"
msgstr ""

#: ../../howto/clinic.rst:909
msgid ""
"Below is a table showing the mapping of legacy converters into real Argument "
"Clinic converters.  On the left is the legacy converter, on the right is the "
"text you'd replace it with."
msgstr ""
"下表列出了传统转换器与真正的 Argument Clinic 转换器之间的映射关系。左边是传统"
"的转换器，右边是应该换成的文本。"

#: ../../howto/clinic.rst:914
msgid "``'B'``"
msgstr "``'B'``"

#: ../../howto/clinic.rst:914
msgid "``unsigned_char(bitwise=True)``"
msgstr "``unsigned_char(bitwise=True)``"

#: ../../howto/clinic.rst:915
msgid "``'b'``"
msgstr "``'b'``"

#: ../../howto/clinic.rst:915
msgid "``unsigned_char``"
msgstr "``unsigned_char``"

#: ../../howto/clinic.rst:916
msgid "``'c'``"
msgstr "``'c'``"

#: ../../howto/clinic.rst:916
msgid "``char``"
msgstr "``char``"

#: ../../howto/clinic.rst:917
msgid "``'C'``"
msgstr "``'C'``"

#: ../../howto/clinic.rst:917
msgid "``int(accept={str})``"
msgstr "``int(accept={str})``"

#: ../../howto/clinic.rst:918
msgid "``'d'``"
msgstr "``'d'``"

#: ../../howto/clinic.rst:918
msgid "``double``"
msgstr "``double``"

#: ../../howto/clinic.rst:919
msgid "``'D'``"
msgstr "``'D'``"

#: ../../howto/clinic.rst:919
msgid "``Py_complex``"
msgstr "``Py_complex``"

#: ../../howto/clinic.rst:920
msgid "``'es'``"
msgstr "``'es'``"

#: ../../howto/clinic.rst:920
msgid "``str(encoding='name_of_encoding')``"
msgstr "``str(encoding='name_of_encoding')``"

#: ../../howto/clinic.rst:921
msgid "``'es#'``"
msgstr "``'es#'``"

#: ../../howto/clinic.rst:921
msgid "``str(encoding='name_of_encoding', zeroes=True)``"
msgstr "``str(encoding='name_of_encoding', zeroes=True)``"

#: ../../howto/clinic.rst:922
msgid "``'et'``"
msgstr "``'et'``"

#: ../../howto/clinic.rst:922
msgid "``str(encoding='name_of_encoding', accept={bytes, bytearray, str})``"
msgstr "``str(encoding='name_of_encoding', accept={bytes, bytearray, str})``"

#: ../../howto/clinic.rst:923
msgid "``'et#'``"
msgstr "``'et#'``"

#: ../../howto/clinic.rst:923
msgid ""
"``str(encoding='name_of_encoding', accept={bytes, bytearray, str}, "
"zeroes=True)``"
msgstr ""
"``str(encoding='name_of_encoding', accept={bytes, bytearray, str}, "
"zeroes=True)``"

#: ../../howto/clinic.rst:924
msgid "``'f'``"
msgstr "``'f'``"

#: ../../howto/clinic.rst:924
msgid "``float``"
msgstr "``float``"

#: ../../howto/clinic.rst:925
msgid "``'h'``"
msgstr "``'h'``"

#: ../../howto/clinic.rst:925
msgid "``short``"
msgstr "``short``"

#: ../../howto/clinic.rst:926
msgid "``'H'``"
msgstr "``'H'``"

#: ../../howto/clinic.rst:926
msgid "``unsigned_short(bitwise=True)``"
msgstr "``unsigned_short(bitwise=True)``"

#: ../../howto/clinic.rst:927
msgid "``'i'``"
msgstr "``'i'``"

#: ../../howto/clinic.rst:927
msgid "``int``"
msgstr "``int``"

#: ../../howto/clinic.rst:928
msgid "``'I'``"
msgstr "``'I'``"

#: ../../howto/clinic.rst:928
msgid "``unsigned_int(bitwise=True)``"
msgstr "``unsigned_int(bitwise=True)``"

#: ../../howto/clinic.rst:929
msgid "``'k'``"
msgstr "``'k'``"

#: ../../howto/clinic.rst:929
msgid "``unsigned_long(bitwise=True)``"
msgstr "``unsigned_long(bitwise=True)``"

#: ../../howto/clinic.rst:930
msgid "``'K'``"
msgstr "``'K'``"

#: ../../howto/clinic.rst:930
msgid "``unsigned_long_long(bitwise=True)``"
msgstr "``unsigned_long_long(bitwise=True)``"

#: ../../howto/clinic.rst:931
msgid "``'l'``"
msgstr "``'l'``"

#: ../../howto/clinic.rst:931
msgid "``long``"
msgstr "``long``"

#: ../../howto/clinic.rst:932
msgid "``'L'``"
msgstr "``'L'``"

#: ../../howto/clinic.rst:932
msgid "``long long``"
msgstr "``long long``"

#: ../../howto/clinic.rst:933
msgid "``'n'``"
msgstr "``'n'``"

#: ../../howto/clinic.rst:933
msgid "``Py_ssize_t``"
msgstr "``Py_ssize_t``"

#: ../../howto/clinic.rst:934
msgid "``'O'``"
msgstr "``'O'``"

#: ../../howto/clinic.rst:934
msgid "``object``"
msgstr "``object``"

#: ../../howto/clinic.rst:935
msgid "``'O!'``"
msgstr "``'O!'``"

#: ../../howto/clinic.rst:935
msgid "``object(subclass_of='&PySomething_Type')``"
msgstr "``object(subclass_of='&PySomething_Type')``"

#: ../../howto/clinic.rst:936
msgid "``'O&'``"
msgstr "``'O&'``"

#: ../../howto/clinic.rst:936
msgid "``object(converter='name_of_c_function')``"
msgstr "``object(converter='name_of_c_function')``"

#: ../../howto/clinic.rst:937
msgid "``'p'``"
msgstr "``'p'``"

#: ../../howto/clinic.rst:937
msgid "``bool``"
msgstr "``bool``"

#: ../../howto/clinic.rst:938
msgid "``'S'``"
msgstr "``'S'``"

#: ../../howto/clinic.rst:938
msgid "``PyBytesObject``"
msgstr "``PyBytesObject``"

#: ../../howto/clinic.rst:939
msgid "``'s'``"
msgstr "``'s'``"

#: ../../howto/clinic.rst:939
msgid "``str``"
msgstr "``str``"

#: ../../howto/clinic.rst:940
msgid "``'s#'``"
msgstr "``'s#'``"

#: ../../howto/clinic.rst:940
msgid "``str(zeroes=True)``"
msgstr "``str(zeroes=True)``"

#: ../../howto/clinic.rst:941
msgid "``'s*'``"
msgstr "``'s*'``"

#: ../../howto/clinic.rst:941
msgid "``Py_buffer(accept={buffer, str})``"
msgstr "``Py_buffer(accept={buffer, str})``"

#: ../../howto/clinic.rst:942
msgid "``'U'``"
msgstr "``'U'``"

#: ../../howto/clinic.rst:942
msgid "``unicode``"
msgstr "``unicode``"

#: ../../howto/clinic.rst:943
msgid "``'u'``"
msgstr "``'u'``"

#: ../../howto/clinic.rst:943
msgid "``wchar_t``"
msgstr "``wchar_t``"

#: ../../howto/clinic.rst:944
msgid "``'u#'``"
msgstr "``'u#'``"

#: ../../howto/clinic.rst:944
msgid "``wchar_t(zeroes=True)``"
msgstr "``wchar_t(zeroes=True)``"

#: ../../howto/clinic.rst:945
msgid "``'w*'``"
msgstr "``'w*'``"

#: ../../howto/clinic.rst:945
msgid "``Py_buffer(accept={rwbuffer})``"
msgstr "``Py_buffer(accept={rwbuffer})``"

#: ../../howto/clinic.rst:946
msgid "``'Y'``"
msgstr "``'Y'``"

#: ../../howto/clinic.rst:946
msgid "``PyByteArrayObject``"
msgstr "``PyByteArrayObject``"

#: ../../howto/clinic.rst:947
msgid "``'y'``"
msgstr "``'y'``"

#: ../../howto/clinic.rst:947
msgid "``str(accept={bytes})``"
msgstr "``str(accept={bytes})``"

#: ../../howto/clinic.rst:948
msgid "``'y#'``"
msgstr "``'y#'``"

#: ../../howto/clinic.rst:948
msgid "``str(accept={robuffer}, zeroes=True)``"
msgstr "``str(accept={robuffer}, zeroes=True)``"

#: ../../howto/clinic.rst:949
msgid "``'y*'``"
msgstr "``'y*'``"

#: ../../howto/clinic.rst:949
msgid "``Py_buffer``"
msgstr "``Py_buffer``"

#: ../../howto/clinic.rst:950
msgid "``'Z'``"
msgstr "``'Z'``"

#: ../../howto/clinic.rst:950
msgid "``wchar_t(accept={str, NoneType})``"
msgstr "``wchar_t(accept={str, NoneType})``"

#: ../../howto/clinic.rst:951
msgid "``'Z#'``"
msgstr "``'Z#'``"

#: ../../howto/clinic.rst:951
msgid "``wchar_t(accept={str, NoneType}, zeroes=True)``"
msgstr "``wchar_t(accept={str, NoneType}, zeroes=True)``"

#: ../../howto/clinic.rst:952
msgid "``'z'``"
msgstr "``'z'``"

#: ../../howto/clinic.rst:952
msgid "``str(accept={str, NoneType})``"
msgstr "``str(accept={str, NoneType})``"

#: ../../howto/clinic.rst:953
msgid "``'z#'``"
msgstr "``'z#'``"

#: ../../howto/clinic.rst:953
msgid "``str(accept={str, NoneType}, zeroes=True)``"
msgstr "``str(accept={str, NoneType}, zeroes=True)``"

#: ../../howto/clinic.rst:954
msgid "``'z*'``"
msgstr "``'z*'``"

#: ../../howto/clinic.rst:954
msgid "``Py_buffer(accept={buffer, str, NoneType})``"
msgstr "``Py_buffer(accept={buffer, str, NoneType})``"

#: ../../howto/clinic.rst:957
msgid ""
"As an example, here's our sample ``pickle.Pickler.dump`` using the proper "
"converter::"
msgstr "举个例子，下面是采用合适的转换器的例子 ``pickle.Pickler.dump``："

#: ../../howto/clinic.rst:970
msgid ""
"One advantage of real converters is that they're more flexible than legacy "
"converters.  For example, the ``unsigned_int`` converter (and all the "
"``unsigned_`` converters) can be specified without ``bitwise=True``.  Their "
"default behavior performs range checking on the value, and they won't accept "
"negative numbers.  You just can't do that with a legacy converter!"
msgstr ""
"真正的转换器有一个优点，就是比传统的转换器更加灵活。例如，``unsigned_int`` 转"
"换器（以及所有 ``unsigned_`` 转换器）可以不设置 ``bitwise=True`` 。 他们默认"
"会对数值进行范围检查，而且不会接受负数。 用传统转换器就做不到这一点。"

#: ../../howto/clinic.rst:976
msgid ""
"Argument Clinic will show you all the converters it has available.  For each "
"converter it'll show you all the parameters it accepts, along with the "
"default value for each parameter. Just run ``Tools/clinic/clinic.py --"
"converters`` to see the full list."
msgstr ""
"Argument Clinic 会列明其全部转换器。每个转换器都会给出可接受的全部参数，以及"
"每个参数的默认值。只要运行 ``Tools/clinic/clinic.py --converters`` 就能得到完"
"整的列表。"

#: ../../howto/clinic.rst:983
msgid "How to use the ``Py_buffer`` converter"
msgstr "如何使用 ``Py_buffer`` 转换器"

#: ../../howto/clinic.rst:985
msgid ""
"When using the ``Py_buffer`` converter (or the ``'s*'``, ``'w*'``, ``'*y'``, "
"or ``'z*'`` legacy converters), you *must* not call :c:func:"
"`PyBuffer_Release` on the provided buffer. Argument Clinic generates code "
"that does it for you (in the parsing function)."
msgstr ""
"在使用 ``Py_buffer`` 转换器（或者 ``'s*'``、``'w*'``、``'*y'`` 或 ``'z*'`` 传"
"统转换器）时，*不可* 在所提供的缓冲区上调用 :c:func:`PyBuffer_Release`。 "
"Argument Clinic 生成的代码会自动完成此操作（在解析函数中）。"

#: ../../howto/clinic.rst:994
msgid "How to use advanced converters"
msgstr "如何使用高级转换器"

#: ../../howto/clinic.rst:996
msgid ""
"Remember those format units you skipped for your first time because they "
"were advanced?  Here's how to handle those too."
msgstr ""
"还记得编写第一个函数时跳过的那些格式单元吗，因为他们是高级内容？下面就来介绍"
"这些内容。"

#: ../../howto/clinic.rst:999
msgid ""
"The trick is, all those format units take arguments—either conversion "
"functions, or types, or strings specifying an encoding. (But \"legacy "
"converters\" don't support arguments.  That's why we skipped them for your "
"first function.)  The argument you specified to the format unit is now an "
"argument to the converter; this argument is either *converter* (for ``O&``), "
"*subclass_of* (for ``O!``), or *encoding* (for all the format units that "
"start with ``e``)."
msgstr ""

#: ../../howto/clinic.rst:1007
msgid ""
"When using *subclass_of*, you may also want to use the other custom argument "
"for ``object()``: *type*, which lets you set the type actually used for the "
"parameter.  For example, if you want to ensure that the object is a subclass "
"of :c:var:`PyUnicode_Type`, you probably want to use the converter "
"``object(type='PyUnicodeObject *', subclass_of='&PyUnicode_Type')``."
msgstr ""

#: ../../howto/clinic.rst:1013
msgid ""
"One possible problem with using Argument Clinic: it takes away some possible "
"flexibility for the format units starting with ``e``.  When writing a :c:"
"func:`!PyArg_Parse*` call by hand, you could theoretically decide at runtime "
"what encoding string to pass to that call.   But now this string must be "
"hard-coded at Argument-Clinic-preprocessing-time.  This limitation is "
"deliberate; it made supporting this format unit much easier, and may allow "
"for future optimizations. This restriction doesn't seem unreasonable; "
"CPython itself always passes in static hard-coded encoding strings for "
"parameters whose format units start with ``e``."
msgstr ""

#: ../../howto/clinic.rst:1027
msgid "How to assign default values to parameter"
msgstr "如何给形参赋默认值"

#: ../../howto/clinic.rst:1029
msgid ""
"Default values for parameters can be any of a number of values. At their "
"simplest, they can be string, int, or float literals:"
msgstr ""
"参数的默认值可以是多个值中的一个。最简单的可以是字符串、int 或 float 字面量。"

#: ../../howto/clinic.rst:1038
msgid "They can also use any of Python's built-in constants:"
msgstr "还可以使用 Python 的任何内置常量。"

#: ../../howto/clinic.rst:1046
msgid ""
"There's also special support for a default value of ``NULL``, and for simple "
"expressions, documented in the following sections."
msgstr "对默认值 ``NULL`` 和简单表达式还提供特别的支持，下面将一一介绍。"

#: ../../howto/clinic.rst:1051
msgid "The ``NULL`` default value"
msgstr "默认值 ``NULL``"

#: ../../howto/clinic.rst:1053
msgid ""
"For string and object parameters, you can set them to ``None`` to indicate "
"that there's no default.  However, that means the C variable will be "
"initialized to ``Py_None``.  For convenience's sakes, there's a special "
"value called ``NULL`` for just this reason: from Python's perspective it "
"behaves like a default value of ``None``, but the C variable is initialized "
"with ``NULL``."
msgstr ""
"对于字符串和对象参数而言，可以设为 ``None``，表示没有默认值。但这意味着会将 "
"C 变量初始化为 ``Py_None``。为了方便起见，提供了一个特殊值 ``NULL``，目的就是"
"为了让 Python 认为默认值就是 ``None``，而 C 变量则会初始化为 ``NULL``。"

#: ../../howto/clinic.rst:1062
msgid "Symbolic default values"
msgstr "符号化默认值"

#: ../../howto/clinic.rst:1064
msgid ""
"The default value you provide for a parameter can't be any arbitrary "
"expression.  Currently the following are explicitly supported:"
msgstr "提供给参数的默认值不能是表达式。目前明确支持以下形式："

#: ../../howto/clinic.rst:1067
msgid "Numeric constants (integer and float)"
msgstr "数值型常数（整数和浮点数）。"

#: ../../howto/clinic.rst:1068
msgid "String constants"
msgstr "字符串常量"

#: ../../howto/clinic.rst:1069
msgid "``True``, ``False``, and ``None``"
msgstr "``True`` 、 ``False`` 和 ``None`` 。"

#: ../../howto/clinic.rst:1070
msgid ""
"Simple symbolic constants like :py:data:`sys.maxsize`, which must start with "
"the name of the module"
msgstr ""

#: ../../howto/clinic.rst:1073
msgid ""
"(In the future, this may need to get even more elaborate, to allow full "
"expressions like ``CONSTANT - 1``.)"
msgstr ""
"（未来可能需要加以细化，以便可以采用 ``CONSTANT - 1`` 之类的完整表达式。）"

#: ../../howto/clinic.rst:1078
msgid "Expressions as default values"
msgstr "表达式作为默认值"

#: ../../howto/clinic.rst:1080
msgid ""
"The default value for a parameter can be more than just a literal value. It "
"can be an entire expression, using math operators and looking up attributes "
"on objects.  However, this support isn't exactly simple, because of some non-"
"obvious semantics."
msgstr ""
"参数的默认值不仅可以是字面量。还可以是一个完整的表达式，可采用数学运算符及对"
"象的属性。但这种支持并没有那么简单，因为存在一些不明显的语义。"

#: ../../howto/clinic.rst:1085
msgid "Consider the following example:"
msgstr "请考虑以下例子："

#: ../../howto/clinic.rst:1091
msgid ""
":py:data:`sys.maxsize` can have different values on different platforms.  "
"Therefore Argument Clinic can't simply evaluate that expression locally and "
"hard-code it in C.  So it stores the default in such a way that it will get "
"evaluated at runtime, when the user asks for the function's signature."
msgstr ""

#: ../../howto/clinic.rst:1096
msgid ""
"What namespace is available when the expression is evaluated?  It's "
"evaluated in the context of the module the builtin came from.  So, if your "
"module has an attribute called :py:attr:`!max_widgets`, you may simply use "
"it:"
msgstr ""

#: ../../howto/clinic.rst:1104
msgid ""
"If the symbol isn't found in the current module, it fails over to looking "
"in :py:data:`sys.modules`.  That's how it can find :py:data:`sys.maxsize` "
"for example. (Since you don't know in advance what modules the user will "
"load into their interpreter, it's best to restrict yourself to modules that "
"are preloaded by Python itself.)"
msgstr ""

#: ../../howto/clinic.rst:1109
msgid ""
"Evaluating default values only at runtime means Argument Clinic can't "
"compute the correct equivalent C default value.  So you need to tell it "
"explicitly. When you use an expression, you must also specify the equivalent "
"expression in C, using the *c_default* parameter to the converter:"
msgstr ""

#: ../../howto/clinic.rst:1118
msgid ""
"Another complication: Argument Clinic can't know in advance whether or not "
"the expression you supply is valid.  It parses it to make sure it looks "
"legal, but it can't *actually* know.  You must be very careful when using "
"expressions to specify values that are guaranteed to be valid at runtime!"
msgstr ""
"还有一个问题也比较复杂。Argument Clinic 无法事先知道表达式是否有效。 解析只能"
"保证看起来是有效值，但无法 *实际* 知晓。在用表达式时须十分小心，确保在运行时"
"能得到有效值。"

#: ../../howto/clinic.rst:1123
msgid ""
"Finally, because expressions must be representable as static C values, there "
"are many restrictions on legal expressions.  Here's a list of Python "
"features you're not permitted to use:"
msgstr ""
"最后一点，由于表达式必须能表示为静态的 C 语言值，所以存在许多限制。 以下列出"
"了不得使用的 Python 特性："

#: ../../howto/clinic.rst:1127
msgid "Function calls."
msgstr "功能"

#: ../../howto/clinic.rst:1128
msgid "Inline if statements (``3 if foo else 5``)."
msgstr "行内 if 语句（``3 if foo else 5`` ）"

#: ../../howto/clinic.rst:1129
msgid "Automatic sequence unpacking (``*[1, 2, 3]``)."
msgstr "序列类自动解包（``*[1, 2, 3]``）"

#: ../../howto/clinic.rst:1130
msgid "List/set/dict comprehensions and generator expressions."
msgstr "列表、集合、字典的解析和生成器表达式。"

#: ../../howto/clinic.rst:1131
msgid "Tuple/list/set/dict literals."
msgstr "元组、列表、集合、字典的字面量"

#: ../../howto/clinic.rst:1137
msgid "How to use return converters"
msgstr "如何使用返回转换器"

#: ../../howto/clinic.rst:1139
msgid ""
"By default, the impl function Argument Clinic generates for you returns :c:"
"type:`PyObject * <PyObject>`. But your C function often computes some C "
"type, then converts it into the :c:type:`!PyObject *` at the last moment.  "
"Argument Clinic handles converting your inputs from Python types into native "
"C types—why not have it convert your return value from a native C type into "
"a Python type too?"
msgstr ""
"在默认情况下，Argument Clinic 生成的 impl 函数返回 :c:type:`PyObject * "
"<PyObject>`。 但是你的 C 函数往往要计算某个 C 类型，然后最终将其转换为 :c:"
"type:`!PyObject *`。 Argument Clinic 会负责将你的输入由 Python 类型转换为原"
"生 C 类型 — 为什么不让它将你的返回值也由原生 C 类型转换为 Python 类型呢？"

#: ../../howto/clinic.rst:1147
msgid ""
"That's what a \"return converter\" does.  It changes your impl function to "
"return some C type, then adds code to the generated (non-impl) function to "
"handle converting that value into the appropriate :c:type:`!PyObject *`."
msgstr ""
"这就是“返回值转换器”要做的事。 它将你的 impl 函数修改为返回某种 C 类型，然后"
"在生成的type, then adds code to the generated (非 impl) 函数中添加代码来处理"
"该值到相应 :c:type:`!PyObject *` 的转换。"

#: ../../howto/clinic.rst:1151
msgid ""
"The syntax for return converters is similar to that of parameter converters. "
"You specify the return converter like it was a return annotation on the "
"function itself, using ``->`` notation."
msgstr ""
"返回值转换器的语法类似于形参转换器。 你以为函数自身添加返回标注的形式来指定返"
"回值转换器，即使用 ``->`` 标注。"

#: ../../howto/clinic.rst:1155
msgid "For example:"
msgstr "例如:"

#: ../../howto/clinic.rst:1168
msgid ""
"Return converters behave much the same as parameter converters; they take "
"arguments, the arguments are all keyword-only, and if you're not changing "
"any of the default arguments you can omit the parentheses."
msgstr ""
"返回值转换器的行为和形参转换器基本一致；它们都接受一些参数，这些参数全部是仅"
"限关键字的，如果你不修改任何默认参数则可以省略括号。"

#: ../../howto/clinic.rst:1172
msgid ""
"(If you use both ``\"as\"`` *and* a return converter for your function, the "
"``\"as\"`` should come before the return converter.)"
msgstr ""
"（如果函数同时用到了 ``\"as\"`` 和返回值转换器， ``\"as\"`` 应位于返回值转换"
"器之前。）"

#: ../../howto/clinic.rst:1175
msgid ""
"There's one additional complication when using return converters: how do you "
"indicate an error has occurred?  Normally, a function returns a valid (non-"
"``NULL``) pointer for success, and ``NULL`` for failure.  But if you use an "
"integer return converter, all integers are valid.  How can Argument Clinic "
"detect an error?  Its solution: each return converter implicitly looks for a "
"special value that indicates an error.  If you return that value, and an "
"error has been set (c:func:`PyErr_Occurred` returns a true value), then the "
"generated code will propagate the error.  Otherwise it will encode the value "
"you return like normal."
msgstr ""

#: ../../howto/clinic.rst:1184
msgid "Currently Argument Clinic supports only a few return converters:"
msgstr "目前 Argument Clinic 只支持少数几种返回值转换器。"

#: ../../howto/clinic.rst:1198
msgid ""
"None of these take parameters. For all of these, return ``-1`` to indicate "
"error."
msgstr ""
"它们全都不接受形参。 它们全都返回 ``-1`` 来表示错误。to indicate error."

#: ../../howto/clinic.rst:1201
msgid ""
"To see all the return converters Argument Clinic supports, along with their "
"parameters (if any), just run ``Tools/clinic/clinic.py --converters`` for "
"the full list."
msgstr ""
"只要运行 ``Tools/clinic/clinic.py --converters`` ，即可查看 Argument Clinic "
"支持的所有返回值转换器，包括其参数。"

#: ../../howto/clinic.rst:1207
msgid "How to clone existing functions"
msgstr "如何克隆现有的函数"

#: ../../howto/clinic.rst:1209
msgid ""
"If you have a number of functions that look similar, you may be able to use "
"Clinic's \"clone\" feature.  When you clone an existing function, you reuse:"
msgstr ""
"如果已有一些函数比较相似，或许可以采用 Clinic 的“克隆”功能。 克隆之后能够复用"
"以下内容："

#: ../../howto/clinic.rst:1213
msgid "its parameters, including"
msgstr "参数，包括："

#: ../../howto/clinic.rst:1215
msgid "their names,"
msgstr "名称"

#: ../../howto/clinic.rst:1217
msgid "their converters, with all parameters,"
msgstr "转换器（带有全部参数）"

#: ../../howto/clinic.rst:1219
msgid "their default values,"
msgstr "默认值"

#: ../../howto/clinic.rst:1221
msgid "their per-parameter docstrings,"
msgstr "参数前的文档字符串"

#: ../../howto/clinic.rst:1223
msgid ""
"their *kind* (whether they're positional only, positional or keyword, or "
"keyword only), and"
msgstr "*类别* （只认位置、位置或关键字、只认关键字）"

#: ../../howto/clinic.rst:1226
msgid "its return converter."
msgstr "返回值转换器"

#: ../../howto/clinic.rst:1228
msgid ""
"The only thing not copied from the original function is its docstring; the "
"syntax allows you to specify a new docstring."
msgstr "唯一不从原函数中复制的是文档字符串；这样就能指定一个新的文档串。"

#: ../../howto/clinic.rst:1231
msgid "Here's the syntax for cloning a function::"
msgstr "下面是函数的克隆方法："

#: ../../howto/clinic.rst:1239
msgid ""
"(The functions can be in different modules or classes.  I wrote ``module."
"class`` in the sample just to illustrate that you must use the full path to "
"*both* functions.)"
msgstr ""
"（原函数可以位于不同的模块或类中。示例中的 ``module.class`` 只是为了说明，*两"
"个* 函数都必须使用全路径）。"

#: ../../howto/clinic.rst:1243
msgid ""
"Sorry, there's no syntax for partially cloning a function, or cloning a "
"function then modifying it.  Cloning is an all-or nothing proposition."
msgstr ""
"对不起，没有用于部分克隆某个函数、或克隆某个函数并对其进行修改的语法。 克隆是"
"一个只有全部和全无两种选项的操作。"

#: ../../howto/clinic.rst:1246
msgid ""
"Also, the function you are cloning from must have been previously defined in "
"the current file."
msgstr "另外，要克隆的函数必须在当前文件中已有定义。"

#: ../../howto/clinic.rst:1251
msgid "How to call Python code"
msgstr "如何调用 Python 代码"

#: ../../howto/clinic.rst:1253
msgid ""
"The rest of the advanced topics require you to write Python code which lives "
"inside your C file and modifies Argument Clinic's runtime state.  This is "
"simple: you simply define a Python block."
msgstr ""
"下面的高级内容需要编写 Python 代码，存于 C 文件中，并修改 Argument Clinic 的"
"运行状态。其实很简单：只需定义一个 Python 块。"

#: ../../howto/clinic.rst:1257
msgid ""
"A Python block uses different delimiter lines than an Argument Clinic "
"function block.  It looks like this::"
msgstr "Python 块的分隔线与 Argument Clinic 函数块不同。如下所示："

#: ../../howto/clinic.rst:1264
msgid ""
"All the code inside the Python block is executed at the time it's parsed.  "
"All text written to stdout inside the block is redirected into the "
"\"output\" after the block."
msgstr ""
"Python 块内的所有代码都会在解析时执行。块内写入 stdout 的所有文本都被重定向到"
"块后的“输出”部分。"

#: ../../howto/clinic.rst:1268
msgid ""
"As an example, here's a Python block that adds a static integer variable to "
"the C code::"
msgstr "以下例子包含了 Python 块，用于在 C 代码中添加一个静态整数变量："

#: ../../howto/clinic.rst:1281
msgid "How to use the \"self converter\""
msgstr "如何使用“自转换器”"

#: ../../howto/clinic.rst:1283
msgid ""
"Argument Clinic automatically adds a \"self\" parameter for you using a "
"default converter.  It automatically sets the ``type`` of this parameter to "
"the \"pointer to an instance\" you specified when you declared the type.  "
"However, you can override Argument Clinic's converter and specify one "
"yourself. Just add your own *self* parameter as the first parameter in a "
"block, and ensure that its converter is an instance of :class:`!"
"self_converter` or a subclass thereof."
msgstr ""

#: ../../howto/clinic.rst:1292
msgid ""
"What's the point?  This lets you override the type of ``self``, or give it a "
"different default name."
msgstr "这有什么用呢？可用于覆盖 ``self`` 的类型，或为其给个不同的默认名称。"

#: ../../howto/clinic.rst:1295
msgid ""
"How do you specify the custom type you want to cast ``self`` to? If you only "
"have one or two functions with the same type for ``self``, you can directly "
"use Argument Clinic's existing ``self`` converter, passing in the type you "
"want to use as the *type* parameter::"
msgstr ""

#: ../../howto/clinic.rst:1311
msgid ""
"On the other hand, if you have a lot of functions that will use the same "
"type for ``self``, it's best to create your own converter, subclassing :"
"class:`!self_converter` but overwriting the :py:attr:`!type` member::"
msgstr ""

#: ../../howto/clinic.rst:1333
msgid "How to use the \"defining class\" converter"
msgstr "如何使用“定义类”转换器"

#: ../../howto/clinic.rst:1335
msgid ""
"Argument Clinic facilitates gaining access to the defining class of a "
"method. This is useful for :ref:`heap type <heap-types>` methods that need "
"to fetch module level state.  Use :c:func:`PyType_FromModuleAndSpec` to "
"associate a new heap type with a module.  You can now use :c:func:"
"`PyType_GetModuleState` on the defining class to fetch the module state, for "
"example from a module method."
msgstr ""
"Argument Clinic 为访问方法定义所在的类提供了便利。因为 :ref:`heap type <heap-"
"types>` 方法需要获取模块级的运行状态，所以就十分有用。:c:func:"
"`PyType_FromModuleAndSpec` 会将堆类型与模块关联起来。然后类就可用 :c:func:"
"`PyType_GetModuleState` 获取模块状态了，比如利用模块的方法进行获取。"

#: ../../howto/clinic.rst:1341
msgid ""
"Example from :source:`Modules/zlibmodule.c`. First, ``defining_class`` is "
"added to the clinic input::"
msgstr ""

#: ../../howto/clinic.rst:1353
msgid ""
"After running the Argument Clinic tool, the following function signature is "
"generated::"
msgstr "运行 Argument Clinic 工具后，会生成以下函数签名："

#: ../../howto/clinic.rst:1363
msgid ""
"The following code can now use ``PyType_GetModuleState(cls)`` to fetch the "
"module state::"
msgstr "现在，以下代码可以用 ``PyType_GetModuleState(cls)`` 获取模块状态了："

#: ../../howto/clinic.rst:1369
msgid ""
"Each method may only have one argument using this converter, and it must "
"appear after ``self``, or, if ``self`` is not used, as the first argument.  "
"The argument will be of type ``PyTypeObject *``.  The argument will not "
"appear in the :py:attr:`!__text_signature__`."
msgstr ""

#: ../../howto/clinic.rst:1374
msgid ""
"The ``defining_class`` converter is not compatible with :py:meth:`!__init__` "
"and :py:meth:`!__new__` methods, which cannot use the :c:macro:`METH_METHOD` "
"convention."
msgstr ""

#: ../../howto/clinic.rst:1378
msgid ""
"It is not possible to use ``defining_class`` with slot methods.  In order to "
"fetch the module state from such methods, use :c:func:"
"`PyType_GetModuleByDef` to look up the module and then :c:func:"
"`PyModule_GetState` to fetch the module state.  Example from the "
"``setattro`` slot method in :source:`Modules/_threadmodule.c`::"
msgstr ""

#: ../../howto/clinic.rst:1393
msgid "See also :pep:`573`."
msgstr "参见  :pep:`573`。"

#: ../../howto/clinic.rst:1397
msgid "How to write a custom converter"
msgstr "如何编写自定义转换器"

#: ../../howto/clinic.rst:1399
msgid ""
"As we hinted at in the previous section... you can write your own "
"converters! A converter is simply a Python class that inherits from :py:"
"class:`!CConverter`. The main purpose of a custom converter is if you have a "
"parameter using the ``O&`` format unit—parsing this parameter means calling "
"a :c:func:`PyArg_ParseTuple` \"converter function\"."
msgstr ""

#: ../../howto/clinic.rst:1405
msgid ""
"Your converter class should be named ``*something*_converter``. If the name "
"follows this convention, then your converter class will be automatically "
"registered with Argument Clinic; its name will be the name of your class "
"with the ``_converter`` suffix stripped off.  (This is accomplished with a "
"metaclass.)"
msgstr ""
"自定义转换器类应命名为 ``*something*_converter``。只要按此规则命名，自定义转"
"换器类就会在 Argument Clinic 中自动注册；转换器的名称就是去除了 "
"``_converter`` 后缀的类名。（通过元类完成）。"

#: ../../howto/clinic.rst:1411
msgid ""
"You shouldn't subclass :py:meth:`!CConverter.__init__`.  Instead, you should "
"write a :py:meth:`!converter_init` function. :py:meth:`!converter_init` "
"always accepts a *self* parameter; after that, all additional parameters "
"*must* be keyword-only.  Any arguments passed in to the converter in "
"Argument Clinic will be passed along to your :py:meth:`!converter_init`."
msgstr ""

#: ../../howto/clinic.rst:1418
msgid ""
"There are some additional members of :py:class:`!CConverter` you may wish to "
"specify in your subclass.  Here's the current list:"
msgstr ""

#: ../../howto/clinic.rst:1427
msgid ""
"The C type to use for this variable. :attr:`!type` should be a Python string "
"specifying the type, e.g. ``'int'``. If this is a pointer type, the type "
"string should end with ``' *'``."
msgstr ""

#: ../../howto/clinic.rst:1434
msgid ""
"The Python default value for this parameter, as a Python value. Or the magic "
"value ``unspecified`` if there is no default."
msgstr "该参数的缺省值，为 Python 数据类型。若无缺省值，则为 ``unspecified``。"

#: ../../howto/clinic.rst:1439
msgid ""
":attr:`!default` as it should appear in Python code, as a string. Or "
"``None`` if there is no default."
msgstr ""

#: ../../howto/clinic.rst:1445
msgid ""
":attr:`!default` as it should appear in C code, as a string. Or ``None`` if "
"there is no default."
msgstr ""

#: ../../howto/clinic.rst:1451
msgid ""
"The default value used to initialize the C variable when there is no "
"default, but not specifying a default may result in an \"uninitialized "
"variable\" warning.  This can easily happen when using option groups—"
"although properly written code will never actually use this value, the "
"variable does get passed in to the impl, and the C compiler will complain "
"about the \"use\" of the uninitialized value.  This value should always be a "
"non-empty string."
msgstr ""
"在无默认值时用于初始化 C 变量的默认值，不指定默认值可能会导致 \"变量未初始化"
"\" 警告。 这在使用选项组时很容易发生 — 尽管编写合理的代码将永远不会真的使用这"
"个值，但该变量确实会被传入 impl，而 C 编译器将会报告 \"使用了\" 未初始化的"
"值。 这个值应当总是一个非空字符串。"

#: ../../howto/clinic.rst:1463
msgid "The name of the C converter function, as a string."
msgstr "C 转换器的名称，字符串类型。"

#: ../../howto/clinic.rst:1467
msgid ""
"A boolean value.  If true, Argument Clinic will add a ``&`` in front of the "
"name of the variable when passing it into the impl function."
msgstr ""
"布尔值。如果为 True，则 Argument Clinic 在将变量传入 impl 函数时，会在其名称"
"前加上一个 ``&``。"

#: ../../howto/clinic.rst:1473
msgid ""
"A boolean value.  If true, Argument Clinic will add a ``&`` in front of the "
"name of the variable when passing it into :c:func:`PyArg_ParseTuple`."
msgstr ""
"一个布尔值。 如果为真，则 Argument Clinic 在将其传入 :c:func:"
"`PyArg_ParseTuple` 时将在变量名之前添加一个 ``&``。"

#: ../../howto/clinic.rst:1478
msgid ""
"Here's the simplest example of a custom converter, from :source:`Modules/"
"zlibmodule.c`::"
msgstr ""

#: ../../howto/clinic.rst:1489
msgid ""
"This block adds a converter to Argument Clinic named ``ssize_t``.  "
"Parameters declared as ``ssize_t`` will be declared as type :c:type:"
"`Py_ssize_t`, and will be parsed by the ``'O&'`` format unit, which will "
"call the ``ssize_t_converter`` converter function.  ``ssize_t`` variables "
"automatically support default values."
msgstr ""
"这个代码块为 Argument Clinic 添加了一个名为 ``ssize_t`` 的转换器。 声明为 "
"``ssize_t`` 的形参将被声明为 :c:type:`Py_ssize_t` 类型，并将由 ``'O&'`` 格式"
"单元来解析，它将调用 ``ssize_t_converter`` 转换器函数。 ``ssize_t`` 变量会自"
"动支持默认值。"

#: ../../howto/clinic.rst:1495
msgid ""
"More sophisticated custom converters can insert custom C code to handle "
"initialization and cleanup. You can see more examples of custom converters "
"in the CPython source tree; grep the C files for the string :py:class:`!"
"CConverter`."
msgstr ""

#: ../../howto/clinic.rst:1502
msgid "How to write a custom return converter"
msgstr "如何编写自定义返回转换器"

#: ../../howto/clinic.rst:1504
msgid ""
"Writing a custom return converter is much like writing a custom converter.  "
"Except it's somewhat simpler, because return converters are themselves much "
"simpler."
msgstr ""
"自定义的返回值转换器的写法，与自定义的转换器十分类似。因为返回值转换器本身就"
"很简单，编写起来就简单一些。"

#: ../../howto/clinic.rst:1508
msgid ""
"Return converters must subclass :py:class:`!CReturnConverter`. There are no "
"examples yet of custom return converters, because they are not widely used "
"yet.  If you wish to write your own return converter, please read :source:"
"`Tools/clinic/clinic.py`, specifically the implementation of :py:class:`!"
"CReturnConverter` and all its subclasses."
msgstr ""

#: ../../howto/clinic.rst:1517
msgid "How to convert ``METH_O`` and ``METH_NOARGS`` functions"
msgstr "如何转换 ``METH_O`` 和 ``METH_NOARGS`` 函数"

#: ../../howto/clinic.rst:1519
msgid ""
"To convert a function using :c:macro:`METH_O`, make sure the function's "
"single argument is using the ``object`` converter, and mark the arguments as "
"positional-only::"
msgstr ""

#: ../../howto/clinic.rst:1531
msgid ""
"To convert a function using :c:macro:`METH_NOARGS`, just don't specify any "
"arguments."
msgstr ""

#: ../../howto/clinic.rst:1534
msgid ""
"You can still use a self converter, a return converter, and specify a *type* "
"argument to the object converter for :c:macro:`METH_O`."
msgstr ""

#: ../../howto/clinic.rst:1539
msgid "How to convert ``tp_new`` and ``tp_init`` functions"
msgstr "如何转换 ``tp_new`` 和 ``tp_init`` 函数"

#: ../../howto/clinic.rst:1541
msgid ""
"You can convert :c:member:`~PyTypeObject.tp_new` and :c:member:"
"`~PyTypeObject.tp_init` functions. Just name them ``__new__`` or "
"``__init__`` as appropriate.  Notes:"
msgstr ""

#: ../../howto/clinic.rst:1545
msgid ""
"The function name generated for ``__new__`` doesn't end in ``__new__`` like "
"it would by default.  It's just the name of the class, converted into a "
"valid C identifier."
msgstr ""
"为转换 ``__new__`` 而生成的函数名不会以其默认名称结尾。只会是转换为合法 C 标"
"识符的类名。"

#: ../../howto/clinic.rst:1549
msgid "No :c:type:`PyMethodDef` ``#define`` is generated for these functions."
msgstr ""

#: ../../howto/clinic.rst:1551
msgid "``__init__`` functions return ``int``, not ``PyObject *``."
msgstr "``__init__`` 函数将返回 ``int`` ，而不是 ``PyObject *`` 。"

#: ../../howto/clinic.rst:1553
msgid "Use the docstring as the class docstring."
msgstr "将文档字符串用作类文档字符串。"

#: ../../howto/clinic.rst:1555
msgid ""
"Although ``__new__`` and ``__init__`` functions must always accept both the "
"``args`` and ``kwargs`` objects, when converting you may specify any "
"signature for these functions that you like. (If your function doesn't "
"support keywords, the parsing function generated will throw an exception if "
"it receives any.)"
msgstr ""
"虽然 ``__new__`` 和 ``__init__`` 函数必须以 ``args`` 和 ``kwargs`` 对象作为参"
"数，但在转换时可按个人喜好定义函数签名。（如果原函数不支持关键字参数，则生成"
"的解析函数在收到关键字参数时会抛出异常）。"

#: ../../howto/clinic.rst:1563
msgid "How to change and redirect Clinic's output"
msgstr "如何修改和重定向 Clinic 的输出"

#: ../../howto/clinic.rst:1565
msgid ""
"It can be inconvenient to have Clinic's output interspersed with your "
"conventional hand-edited C code.  Luckily, Clinic is configurable: you can "
"buffer up its output for printing later (or earlier!), or write its output "
"to a separate file.  You can also add a prefix or suffix to every line of "
"Clinic's generated output."
msgstr ""
"若是让 Clinic 的输出与传统的手写 C 代码交织在一起，可能会不方便阅读。 幸好可"
"以对 Clinic 进行配置：可以将输出结果缓存起来以供输出，或将输出结果写入文件"
"中。针对 Clinic 生成的输出结果，还可以为每一行都加上前缀或后缀。"

#: ../../howto/clinic.rst:1571
msgid ""
"While changing Clinic's output in this manner can be a boon to readability, "
"it may result in Clinic code using types before they are defined, or your "
"code attempting to use Clinic-generated code before it is defined. These "
"problems can be easily solved by rearranging the declarations in your file, "
"or moving where Clinic's generated code goes.  (This is why the default "
"behavior of Clinic is to output everything into the current block; while "
"many people consider this hampers readability, it will never require "
"rearranging your code to fix definition-before-use problems.)"
msgstr ""
"虽然修改 Clinic 的输出提升了可读性，但可能会导致 Clinic 代码使用了未经定义的"
"类型，或者会提前用到 Clinic 生成的代码。通过重新安排声明在代码文件的位置，或"
"将 Clinic 生成的代码移个位置，即可轻松解决上述问题。（这就是 Clinic 默认是全"
"部输出到当前代码块的原因；虽然许多人认为降低了可读性，但这样就根本不用重新编"
"排代码来解决提前引用的问题）。"

#: ../../howto/clinic.rst:1580
msgid "Let's start with defining some terminology:"
msgstr "就从定义一些术语开始吧："

#: ../../howto/clinic.rst:1607
msgid "*field*"
msgstr "** 区块（field）**"

#: ../../howto/clinic.rst:1583
msgid ""
"A field, in this context, is a subsection of Clinic's output. For example, "
"the ``#define`` for the :c:type:`PyMethodDef` structure is a field, called "
"``methoddef_define``.  Clinic has seven different fields it can output per "
"function definition:"
msgstr ""

#: ../../howto/clinic.rst:1598
msgid ""
"All the names are of the form ``\"<a>_<b>\"``, where ``\"<a>\"`` is the "
"semantic object represented (the parsing function, the impl function, the "
"docstring, or the methoddef structure) and ``\"<b>\"`` represents what kind "
"of statement the field is.  Field names that end in ``\"_prototype\"`` "
"represent forward declarations of that thing, without the actual body/data "
"of the thing; field names that end in ``\"_definition\"`` represent the "
"actual definition of the thing, with the body/data of the thing.  "
"(``\"methoddef\"`` is special, it's the only one that ends with "
"``\"_define\"``, representing that it's a preprocessor #define.)"
msgstr ""
"区块均以 ``\"<a>_<b>\"`` 形式命名，其中 ``\"<a>\"`` 是所代表的语义对象（解析"
"函数、impl 函数、文档字符串或 methoddef 结构），``\"<b>\"`` 表示该区块的类"
"别。以 ``\"_prototype\"`` 结尾的区块名表示这只是个前向声明，没有实际的函数体"
"或数据；以 ``\"_definition\"`` 结尾的区块名则表示这是实际的函数定义，包含了函"
"数体和数据。（``\"methoddef\"`` 比较特殊，是唯一一个以 ``\"_define\"`` 结尾的"
"区块名，表明这是一个预处理器 #define。）"

#: ../../howto/clinic.rst:1641
msgid "*destination*"
msgstr "** 输出目标（destination）**"

#: ../../howto/clinic.rst:1610
msgid ""
"A destination is a place Clinic can write output to.  There are five built-"
"in destinations:"
msgstr "输出目标是 Clinic 可以进行输出的地方。内置的输出目标有5种："

#: ../../howto/clinic.rst:1615 ../../howto/clinic.rst:1690
#: ../../howto/clinic.rst:1768
msgid "``block``"
msgstr "``block``"

#: ../../howto/clinic.rst:1614
msgid ""
"The default destination: printed in the output section of the current Clinic "
"block."
msgstr "默认的输出目标：在 Clinic 当前代码块的输出区域进行输出。"

#: ../../howto/clinic.rst:1621 ../../howto/clinic.rst:1717
#: ../../howto/clinic.rst:1771
msgid "``buffer``"
msgstr "``buffer``"

#: ../../howto/clinic.rst:1618
msgid ""
"A text buffer where you can save text for later.  Text sent here is appended "
"to the end of any existing text.  It's an error to have any text left in the "
"buffer when Clinic finishes processing a file."
msgstr ""
"文本缓冲区，可将文本保存起来以便后续使用。输出的文本会加入现有文本的末尾。如"
"果 Clinic 处理完文件后缓冲区中还留有文本，则会报错。"

#: ../../howto/clinic.rst:1632 ../../howto/clinic.rst:1703
#: ../../howto/clinic.rst:1797
msgid "``file``"
msgstr "``file``"

#: ../../howto/clinic.rst:1624
msgid ""
"A separate \"clinic file\" that will be created automatically by Clinic. The "
"filename chosen for the file is ``{basename}.clinic{extension}``, where "
"``basename`` and ``extension`` were assigned the output from ``os.path."
"splitext()`` run on the current file.  (Example: the ``file`` destination "
"for :file:`_pickle.c` would be written to :file:`_pickle.clinic.c`.)"
msgstr ""

#: ../../howto/clinic.rst:1631
msgid ""
"**Important: When using a** ``file`` **destination, you** *must check in* "
"**the generated file!**"
msgstr ""
"**重点：若要使用 ** ``file`` ** 作为输出目标，你 ** *必须签入* ** 生成的文"
"件！**"

#: ../../howto/clinic.rst:1637 ../../howto/clinic.rst:1730
#: ../../howto/clinic.rst:1801
msgid "``two-pass``"
msgstr "``two-pass``"

#: ../../howto/clinic.rst:1635
msgid ""
"A buffer like ``buffer``.  However, a two-pass buffer can only be dumped "
"once, and it prints out all text sent to it during all processing, even from "
"Clinic blocks *after* the dumping point."
msgstr ""
"类似于 ``buffer`` 的缓冲区。不过 two-pass 缓冲区只能转储一次，将会输出处理过"
"程中发送给它的所有文本，甚至包括转储点**之后**的 Clinic 块。"

#: ../../howto/clinic.rst:1641 ../../howto/clinic.rst:1764
msgid "``suppress``"
msgstr "``suppress``"

#: ../../howto/clinic.rst:1640
msgid "The text is suppressed—thrown away."
msgstr "禁止输出文本——抛弃输出。"

#: ../../howto/clinic.rst:1643
msgid "Clinic defines five new directives that let you reconfigure its output."
msgstr "Clinic 定义了5个新的指令，以便修改输出方式。"

#: ../../howto/clinic.rst:1645
msgid "The first new directive is ``dump``:"
msgstr "第一个新指令是 ``dump``："

#: ../../howto/clinic.rst:1651
msgid ""
"This dumps the current contents of the named destination into the output of "
"the current block, and empties it.  This only works with ``buffer`` and "
"``two-pass`` destinations."
msgstr ""
"将指定输出目标的当前内容转储到当前块的输出中，并清空输出目标。仅适用于 "
"``buffer`` 和 ``two-pass`` 目标。"

#: ../../howto/clinic.rst:1655
msgid ""
"The second new directive is ``output``.  The most basic form of ``output`` "
"is like this:"
msgstr "第二个新指令是 ``output``。``output`` 最简单的格式如下所示："

#: ../../howto/clinic.rst:1662
msgid ""
"This tells Clinic to output *field* to *destination*.  ``output`` also "
"supports a special meta-destination, called ``everything``, which tells "
"Clinic to output *all* fields to that *destination*."
msgstr ""
"这会通知 Clinic 将指定**field**输出到指定**destination**中去。``output`` 还支"
"持一个特殊的元目标 ``everything``，通知 Clinic 将**所有**区块都输出到该**目标"
"**。"

#: ../../howto/clinic.rst:1666
msgid "``output`` has a number of other functions:"
msgstr "``output`` 还包含一些函数："

#: ../../howto/clinic.rst:1675
msgid ""
"``output push`` and ``output pop`` allow you to push and pop configurations "
"on an internal configuration stack, so that you can temporarily modify the "
"output configuration, then easily restore the previous configuration.  "
"Simply push before your change to save the current configuration, then pop "
"when you wish to restore the previous configuration."
msgstr ""
"``output push`` 和 ``output pop`` 能在内部的配置栈中压入和弹出配置，这样就可"
"以临时修改输出配置，然后再轻松恢复之前的配置。只需在修改前入栈保存当前配置，"
"在恢复配置时再弹出即可。"

#: ../../howto/clinic.rst:1682
msgid ""
"``output preset`` sets Clinic's output to one of several built-in preset "
"configurations, as follows:"
msgstr "``output preset`` 将 Clinic 的输出目标设为内置预设目标之一，如下所示："

#: ../../howto/clinic.rst:1686
msgid ""
"Clinic's original starting configuration.  Writes everything immediately "
"after the input block."
msgstr "Clinic 的初始设置。输入块后面紧接着写入所有内容。"

#: ../../howto/clinic.rst:1689
msgid ""
"Suppress the ``parser_prototype`` and ``docstring_prototype``, write "
"everything else to ``block``."
msgstr ""
"关闭 ``parser_prototype`` 和 ``docstring_prototype``，并将其他所有内容写入 "
"``block``。"

#: ../../howto/clinic.rst:1693
msgid ""
"Designed to write everything to the \"clinic file\" that it can. You then "
"``#include`` this file near the top of your file. You may need to rearrange "
"your file to make this work, though usually this just means creating forward "
"declarations for various ``typedef`` and ``PyTypeObject`` definitions."
msgstr ""
"目的是全部输出至 “Clinic 文件”中。然后在文件顶部附近 ``#include`` 该文件。可"
"能需要重新调整代码顺序才能正常运行，通常只要为  ``typedef``和"
"``PyTypeObject`` 定义创建前向声明即可。"

#: ../../howto/clinic.rst:1699
msgid ""
"Suppress the ``parser_prototype`` and ``docstring_prototype``, write the "
"``impl_definition`` to ``block``, and write everything else to ``file``."
msgstr ""
"关闭 ``parser_prototype`` 和 ``docstring_prototype`` ，将 "
"``impl_definition`` 写入 ``block``，其他内容写入 ``file`` 。"

#: ../../howto/clinic.rst:1703
msgid "The default filename is ``\"{dirname}/clinic/{basename}.h\"``."
msgstr "默认文件名为 ``\"{dirname}/clinic/{basename}.h\"`` 。"

#: ../../howto/clinic.rst:1706
msgid ""
"Save up most of the output from Clinic, to be written into your file near "
"the end.  For Python files implementing modules or builtin types, it's "
"recommended that you dump the buffer just above the static structures for "
"your module or builtin type; these are normally very near the end.  Using "
"``buffer`` may require even more editing than ``file``, if your file has "
"static ``PyMethodDef`` arrays defined in the middle of the file."
msgstr ""
"将 Clinic 的大部分输出保存起来，在快结束时写入文件。如果 Python 文件存放的是"
"编写模块或内置类型的代码，建议紧挨着模块或内置类型的静态结构之前对缓冲区进行"
"转储；这些结构通常位于结尾附近。如果在文件的中间位置定义了静态 "
"``PyMethodDef`` 数组，采用 ``buffer`` 输出所需的代码编辑工作可能比用 "
"``file`` 要多些。"

#: ../../howto/clinic.rst:1715
msgid ""
"Suppress the ``parser_prototype``, ``impl_prototype``, and "
"``docstring_prototype``, write the ``impl_definition`` to ``block``, and "
"write everything else to ``file``."
msgstr ""
"关闭 ``parser_prototype`` 、``impl_prototype`` 和 ``docstring_prototype``，"
"将 ``impl_definition`` 写入 ``block``，其他输出都写入 ``file``。"

#: ../../howto/clinic.rst:1720
msgid ""
"Similar to the ``buffer`` preset, but writes forward declarations to the "
"``two-pass`` buffer, and definitions to the ``buffer``. This is similar to "
"the ``buffer`` preset, but may require less editing than ``buffer``.  Dump "
"the ``two-pass`` buffer near the top of your file, and dump the ``buffer`` "
"near the end just like you would when using the ``buffer`` preset."
msgstr ""
"类似于预设的  ``buffer`` 输出，但会把前向声明写入 ``two-pass`` 缓冲区，将函数"
"定义写入 ``buffer``。这与预设的 ``buffer`` 类似，但所需的代码编辑工作可能会减"
"少。将 ``two-pass`` 缓冲区转储到文件的顶部，将 ``buffer`` 转储到文件末尾，就"
"像预设的 ``buffer`` 一样。"

#: ../../howto/clinic.rst:1727
msgid ""
"Suppresses the ``impl_prototype``, write the ``impl_definition`` to "
"``block``, write ``docstring_prototype``, ``methoddef_define``, and "
"``parser_prototype`` to ``two-pass``, write everything else to ``buffer``."
msgstr ""
"关闭 ``impl_prototype`` ，将 ``impl_definition`` 写入 ``block`` ，将 "
"``docstring_prototype`` 、 ``methoddef_define`` 和 ``parser_prototype`` 写入 "
"``two-pass``，其他输出都写入 ``buffer`` 。"

#: ../../howto/clinic.rst:1741
msgid "``partial-buffer``"
msgstr "``partial-buffer``"

#: ../../howto/clinic.rst:1733
msgid ""
"Similar to the ``buffer`` preset, but writes more things to ``block``, only "
"writing the really big chunks of generated code to ``buffer``. This avoids "
"the definition-before-use problem of ``buffer`` completely, at the small "
"cost of having slightly more stuff in the block's output. Dump the "
"``buffer`` near the end, just like you would when using the ``buffer`` "
"preset."
msgstr ""
"与预设的 ``buffer`` 类似，但会向 ``block`` 写入更多内容，而只向 ``buffer`` 写"
"入真正大块的生成代码。这样能完全避免 ``buffer`` 的提前引用问题，代价是输出到"
"代码块中的内容会稍有增加。在快结束时会转储 ``buffer``，就像采用预设的 "
"``buffer`` 配置一样。"

#: ../../howto/clinic.rst:1740
msgid ""
"Suppresses the ``impl_prototype``, write the ``docstring_definition`` and "
"``parser_definition`` to ``buffer``, write everything else to ``block``."
msgstr ""
"关闭 ``impl_prototype``，将 ``docstring_definition`` 和 "
"``parser_definition`` 写入 ``buffer``，其他输出都写入 ``block``。"

#: ../../howto/clinic.rst:1743
msgid "The third new directive is ``destination``:"
msgstr "第三个新指令是 ``destination``："

#: ../../howto/clinic.rst:1749
msgid "This performs an operation on the destination named ``name``."
msgstr "向名为 ``name`` 的目标执行输出。"

#: ../../howto/clinic.rst:1751
msgid "There are two defined subcommands: ``new`` and ``clear``."
msgstr "定义了两个子命令：``new`` 和 ``clear``。"

#: ../../howto/clinic.rst:1753
msgid "The ``new`` subcommand works like this:"
msgstr "子命令 ``new`` 工作方式如下："

#: ../../howto/clinic.rst:1759
msgid ""
"This creates a new destination with name ``<name>`` and type ``<type>``."
msgstr "新建一个目标，名称为 ``<name>``，类型为 ``<type>`` 。"

#: ../../howto/clinic.rst:1761
msgid "There are five destination types:"
msgstr "输出目标的类型有5种："

#: ../../howto/clinic.rst:1764
msgid "Throws the text away."
msgstr "忽略文本。"

#: ../../howto/clinic.rst:1767
msgid ""
"Writes the text to the current block.  This is what Clinic originally did."
msgstr "将文本写入当前代码块中。 这就是 Clinic 原来的做法。"

#: ../../howto/clinic.rst:1771
msgid "A simple text buffer, like the \"buffer\" builtin destination above."
msgstr "简单的文本缓冲区，就像上述的内置 “buffer” 目标。"

#: ../../howto/clinic.rst:1774
msgid ""
"A text file.  The file destination takes an extra argument, a template to "
"use for building the filename, like so:"
msgstr "文本文件。文件目标多了一个参数，模板用于生成文件名，类似于："

#: ../../howto/clinic.rst:1777
msgid "destination <name> new <type> <file_template>"
msgstr "destination <name> new <type> <file_template>"

#: ../../howto/clinic.rst:1779
msgid ""
"The template can use three strings internally that will be replaced by bits "
"of the filename:"
msgstr "模版可以引用3个内部字符串，将会用文件名的对应部分替代："

#: ../../howto/clinic.rst:1782
msgid "{path}"
msgstr "{path}"

#: ../../howto/clinic.rst:1783
msgid "The full path to the file, including directory and full filename."
msgstr "文件的全路径，包含文件夹和完整的文件名。"

#: ../../howto/clinic.rst:1784
msgid "{dirname}"
msgstr "{dirname}"

#: ../../howto/clinic.rst:1785
msgid "The name of the directory the file is in."
msgstr "文件所在文件夹名。"

#: ../../howto/clinic.rst:1786
msgid "{basename}"
msgstr "{basename}"

#: ../../howto/clinic.rst:1787
msgid "Just the name of the file, not including the directory."
msgstr "只有文件名，不含文件夹。"

#: ../../howto/clinic.rst:1789
msgid "{basename_root}"
msgstr "{basename_root}"

#: ../../howto/clinic.rst:1789
msgid ""
"Basename with the extension clipped off (everything up to but not including "
"the last '.')."
msgstr "去除了扩展名后的文件名（不含最后一个“.”）。"

#: ../../howto/clinic.rst:1793
msgid "{basename_extension}"
msgstr "{basename_extension}"

#: ../../howto/clinic.rst:1792
msgid ""
"The last '.' and everything after it.  If the basename does not contain a "
"period, this will be the empty string."
msgstr "包含最后一个“.”及后面的字符。如果文件名中不含句点，则为空字符串。"

#: ../../howto/clinic.rst:1795
msgid ""
"If there are no periods in the filename, {basename} and {filename} are the "
"same, and {extension} is empty.  \"{basename}{extension}\" is always exactly "
"the same as \"{filename}\".\""
msgstr ""
"如果文件名中不含句点符，{basename} 和 {basename_root} 是一样的，而 "
"{basename_extension} 则为空。“{basename_root}{basename_extension}” "
"与“{basename}”一定是完全相同的。（英文原文貌似有误）"

#: ../../howto/clinic.rst:1800
msgid "A two-pass buffer, like the \"two-pass\" builtin destination above."
msgstr "two-pass 缓冲区，类似于上述的内置“two-pass”输出目标。"

#: ../../howto/clinic.rst:1803
msgid "The ``clear`` subcommand works like this:"
msgstr "子命令 ``clear`` 的工作方式如下："

#: ../../howto/clinic.rst:1809
msgid ""
"It removes all the accumulated text up to this point in the destination. (I "
"don't know what you'd need this for, but I thought maybe it'd be useful "
"while someone's experimenting.)"
msgstr "清空输出目标中所有文本。（不知用途何在，但也许做实验时会有用吧。)"

#: ../../howto/clinic.rst:1813
msgid "The fourth new directive is ``set``:"
msgstr "第4个新指令是 ``set`` ："

#: ../../howto/clinic.rst:1820
msgid ""
"``set`` lets you set two internal variables in Clinic. ``line_prefix`` is a "
"string that will be prepended to every line of Clinic's output; "
"``line_suffix`` is a string that will be appended to every line of Clinic's "
"output."
msgstr ""
"`set' 能设置 Clinic 的两个内部变量值。``line_prefix`` 是 Clinic 每行输出的前"
"缀字符串；``line_suffix`` 是 Clinic 每行输出的后缀字符串。"

#: ../../howto/clinic.rst:1824
msgid "Both of these support two format strings:"
msgstr "两者都支持两种格式字符串："

#: ../../howto/clinic.rst:1827
msgid "``{block comment start}``"
msgstr "``{block comment start}``"

#: ../../howto/clinic.rst:1827
msgid ""
"Turns into the string ``/*``, the start-comment text sequence for C files."
msgstr "转成字符串 ``/*``，是 C 文件的注释起始标记。"

#: ../../howto/clinic.rst:1830
msgid "``{block comment end}``"
msgstr "``{block comment end}``"

#: ../../howto/clinic.rst:1830
msgid ""
"Turns into the string ``*/``, the end-comment text sequence for C files."
msgstr "转成字符串 ``*/``，是 C 文件的注释结束标记。"

#: ../../howto/clinic.rst:1832
msgid ""
"The final new directive is one you shouldn't need to use directly, called "
"``preserve``:"
msgstr "最后一个新指令是无需直接使用的 ``preserve``。"

#: ../../howto/clinic.rst:1839
msgid ""
"This tells Clinic that the current contents of the output should be kept, "
"unmodified. This is used internally by Clinic when dumping output into "
"``file`` files; wrapping it in a Clinic block lets Clinic use its existing "
"checksum functionality to ensure the file was not modified by hand before it "
"gets overwritten."
msgstr ""
"通知 Clinic 输出内容应保持原样。这是在转储至 ``file`` 文件中时，供 Clinic 内"
"部使用的；以便 Clinic 能利用已有的校验函数，确保文件在被覆盖之前没进行人工修"
"改过。"

#: ../../howto/clinic.rst:1846
msgid "How to use the ``#ifdef`` trick"
msgstr "如何使用 ``#ifdef`` 技巧"

#: ../../howto/clinic.rst:1848
msgid ""
"If you're converting a function that isn't available on all platforms, "
"there's a trick you can use to make life a little easier.  The existing code "
"probably looks like this::"
msgstr ""
"若要转换的函数并非通用于所有平台，可以采用一个技巧。当前代码可能如下所示："

#: ../../howto/clinic.rst:1859
msgid ""
"And then in the ``PyMethodDef`` structure at the bottom the existing code "
"will have:"
msgstr "在底部的 ``PyMethodDef`` 结构中，当前代码如下："

#: ../../howto/clinic.rst:1868
msgid ""
"In this scenario, you should enclose the body of your impl function inside "
"the ``#ifdef``, like so::"
msgstr "这时应将 impl 函数体用 ``#ifdef`` 包裹起来，如下所示："

#: ../../howto/clinic.rst:1882
msgid ""
"Then, remove those three lines from the :c:type:`PyMethodDef` structure, "
"replacing them with the macro Argument Clinic generated:"
msgstr ""

#: ../../howto/clinic.rst:1889
msgid ""
"(You can find the real name for this macro inside the generated code. Or you "
"can calculate it yourself: it's the name of your function as defined on the "
"first line of your block, but with periods changed to underscores, "
"uppercased, and ``\"_METHODDEF\"`` added to the end.)"
msgstr ""
"（在生成的代码中可找到宏的真实名称。或者可以自行求一下值：块的第一行定义的函"
"数名，句点改为下划线，全部大写，并在末尾加上 ``\"_METHODDEF\"`` ）"

#: ../../howto/clinic.rst:1894
msgid ""
"Perhaps you're wondering: what if ``HAVE_FUNCTIONNAME`` isn't defined? The "
"``MODULE_FUNCTIONNAME_METHODDEF`` macro won't be defined either!"
msgstr ""
"如果 ``HAVE_FUNCTIONNAME`` 未定义怎么办？ 那么 "
"``MODULE_FUNCTIONNAME_METHODDEF`` 宏也不会定义。"

#: ../../howto/clinic.rst:1897
msgid ""
"Here's where Argument Clinic gets very clever.  It actually detects that the "
"Argument Clinic block might be deactivated by the ``#ifdef``.  When that "
"happens, it generates a little extra code that looks like this::"
msgstr ""
"这正是 Argument Clinic 变聪明的地方。它其实能检测到 ``#ifdef`` 屏蔽了"
"Argument Clinic 块。于是会额外生成一小段代码，如下所示："

#: ../../howto/clinic.rst:1905
msgid ""
"That means the macro always works.  If the function is defined, this turns "
"into the correct structure, including the trailing comma.  If the function "
"is undefined, this turns into nothing."
msgstr ""
"这样宏总是会生效。如果定义了函数，则会转换为正确的结构，包括尾部的逗号。如果"
"函数未定义，就不做什么转换。"

#: ../../howto/clinic.rst:1909
msgid ""
"However, this causes one ticklish problem: where should Argument Clinic put "
"this extra code when using the \"block\" output preset?  It can't go in the "
"output block, because that could be deactivated by the ``#ifdef``.  (That's "
"the whole point!)"
msgstr ""
"不过，这导致了一个棘手的问题：当使用 \"block\" 输出预设时 Argument Clinic 应"
"该把额外的代码放到哪里呢？ 它不能放在输出代码块中，因为它可能会被 ``#ifdef`` "
"停用。 （它的作用就是这个！）"

#: ../../howto/clinic.rst:1913
msgid ""
"In this situation, Argument Clinic writes the extra code to the \"buffer\" "
"destination. This may mean that you get a complaint from Argument Clinic:"
msgstr ""
"在此情况下，Argument Clinic 会将额外的代码的写入目标设为 \"buffer\"。 这意味"
"着你可能会收到来自 Argument Clinic 的抱怨:"

#: ../../howto/clinic.rst:1921
msgid ""
"When this happens, just open your file, find the ``dump buffer`` block that "
"Argument Clinic added to your file (it'll be at the very bottom), then move "
"it above the :c:type:`PyMethodDef` structure where that macro is used."
msgstr ""

#: ../../howto/clinic.rst:1927
msgid "How to use Argument Clinic in Python files"
msgstr "如何在 Python 文件中使用 Argument Clinic"

#: ../../howto/clinic.rst:1929
msgid ""
"It's actually possible to use Argument Clinic to preprocess Python files. "
"There's no point to using Argument Clinic blocks, of course, as the output "
"wouldn't make any sense to the Python interpreter.  But using Argument "
"Clinic to run Python blocks lets you use Python as a Python preprocessor!"
msgstr ""
"实际上使用 Argument Clinic 来预处理 Python 文件也是可行的。 当然使用 "
"Argument Clinic 代码块并没有什么意义，因为其输出对于 Python 解释器来说是没有"
"意义的。 但是使用 Argument Clinic 来运行 Python 代码块可以让你将 Python 当作 "
"Python 预处理器来使用！"

#: ../../howto/clinic.rst:1934
msgid ""
"Since Python comments are different from C comments, Argument Clinic blocks "
"embedded in Python files look slightly different.  They look like this:"
msgstr ""
"由于 Python 注释不同于 C 注释，嵌入到 Python 文件的 Argument Clinic 代码块看"
"起来会有一点不同。 它们看起来像是这样:"
