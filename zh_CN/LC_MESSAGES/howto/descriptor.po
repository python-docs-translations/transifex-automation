# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# banxi <banxi1988@gmail.com>, 2020
# ww song <sww4718168@gmail.com>, 2020
# df2dc1c92e792f7ae8417c51df43db8f_594d92a <0f49be28017426edb1db1a2ab6e67088_717605>, 2020
# Freesand Leo <yuqinju@163.com>, 2020
# ppcfish <ppcfish@gmail.com>, 2020
# Siyuan Xu, 2020
# WH-2099 <wh2099@outlook.com>, 2020
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-06-23 16:32+0000\n"
"PO-Revision-Date: 2020-05-30 11:54+0000\n"
"Last-Translator: WH-2099 <wh2099@outlook.com>, 2020\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/"
"teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howto/descriptor.rst:3
msgid "Descriptor HowTo Guide"
msgstr "描述器使用指南"

#: ../../howto/descriptor.rst:0
msgid "Author"
msgstr "作者"

#: ../../howto/descriptor.rst:5
msgid "Raymond Hettinger"
msgstr "Raymond Hettinger"

#: ../../howto/descriptor.rst:0
msgid "Contact"
msgstr "联系方式"

#: ../../howto/descriptor.rst:6
msgid "<python at rcn dot com>"
msgstr "<python at rcn dot com>"

#: ../../howto/descriptor.rst:8
msgid "Contents"
msgstr "目录"

#: ../../howto/descriptor.rst:11
msgid "Abstract"
msgstr "摘要"

#: ../../howto/descriptor.rst:13
msgid ""
"Defines descriptors, summarizes the protocol, and shows how descriptors are "
"called.  Examines a custom descriptor and several built-in Python "
"descriptors including functions, properties, static methods, and class "
"methods.  Shows how each works by giving a pure Python equivalent and a "
"sample application."
msgstr ""
"定义描述器，总结描述器协议，展示描述器被如何使用。测试一个自定义的描述器和若"
"干 Python 内置的描述器，包括函数、属性、静态方法和类方法。通过给出一个纯 "
"Python 的等价实现和例程，展示每个描述器如何工作。"

#: ../../howto/descriptor.rst:18
msgid ""
"Learning about descriptors not only provides access to a larger toolset, it "
"creates a deeper understanding of how Python works and an appreciation for "
"the elegance of its design."
msgstr ""
"学习描述器不仅能提供接触到更多工具集的途径，还能更深地理解 Python 工作的原理"
"并更加体会到其设计的优雅性。"

#: ../../howto/descriptor.rst:24
msgid "Definition and Introduction"
msgstr "定义和简介"

#: ../../howto/descriptor.rst:26
msgid ""
"In general, a descriptor is an object attribute with \"binding behavior\", "
"one whose attribute access has been overridden by methods in the descriptor "
"protocol.  Those methods are :meth:`__get__`, :meth:`__set__`, and :meth:"
"`__delete__`.  If any of those methods are defined for an object, it is said "
"to be a descriptor."
msgstr ""
"一般地，一个描述器是一个包含 “绑定行为” 的对象，对其属性的访问被描述器协议中"
"定义的方法覆盖。这些方法有：:meth:`__get__`，:meth:`__set__` 和 :meth:"
"`__delete__`。如果某个对象中定义了这些方法中的任意一个，那么这个对象就可以被"
"称为一个描述器。"

#: ../../howto/descriptor.rst:32
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary.  For instance, ``a.x`` has a lookup "
"chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``, and "
"continuing through the base classes of ``type(a)`` excluding metaclasses. If "
"the looked-up value is an object defining one of the descriptor methods, "
"then Python may override the default behavior and invoke the descriptor "
"method instead. Where this occurs in the precedence chain depends on which "
"descriptor methods were defined."
msgstr ""
"属性访问的默认行为是从一个对象的字典中获取、设置或删除属性。例如，``a.x`` 的"
"查找顺序会从 ``a.__dict__['x']`` 开始，然后是 ``type(a).__dict__['x']``，接下"
"来依次查找 ``type(a)`` 的基类，不包括元类。 如果找到的值是定义了某个描述器方"
"法的对象，则 Python 可能会重载默认行为并转而发起调用描述器方法。这具体发生在"
"优先级链的哪个环节则要根据所定义的描述器方法及其被调用的方式来决定。"

#: ../../howto/descriptor.rst:41
msgid ""
"Descriptors are a powerful, general purpose protocol.  They are the "
"mechanism behind properties, methods, static methods, class methods, and :"
"func:`super()`. They are used throughout Python itself to implement the new "
"style classes introduced in version 2.2.  Descriptors simplify the "
"underlying C-code and offer a flexible set of new tools for everyday Python "
"programs."
msgstr ""
"描述器是一个强大而通用的协议。 它们是特征属性、方法静态方法、类方法和 :func:"
"`super()` 背后的实现机制。 它们在 Python 内部被广泛使用来实现自 2.2 版中引入"
"的新式类。 描述器简化了底层的 C 代码并为 Python 的日常程序提供了一组灵活的新"
"工具。"

#: ../../howto/descriptor.rst:49
msgid "Descriptor Protocol"
msgstr "描述器协议"

#: ../../howto/descriptor.rst:51
msgid "``descr.__get__(self, obj, type=None) -> value``"
msgstr "``descr.__get__(self, obj, type=None) -> value``"

#: ../../howto/descriptor.rst:53
msgid "``descr.__set__(self, obj, value) -> None``"
msgstr "``descr.__set__(self, obj, value) -> None``"

#: ../../howto/descriptor.rst:55
msgid "``descr.__delete__(self, obj) -> None``"
msgstr "``descr.__delete__(self, obj) -> None``"

#: ../../howto/descriptor.rst:57
msgid ""
"That is all there is to it.  Define any of these methods and an object is "
"considered a descriptor and can override default behavior upon being looked "
"up as an attribute."
msgstr ""
"以上就是全部。定义这些方法中的任何一个的对象被视为描述器，并在被作为属性时覆"
"盖其默认行为。"

#: ../../howto/descriptor.rst:61
msgid ""
"If an object defines :meth:`__set__` or :meth:`__delete__`, it is considered "
"a data descriptor.  Descriptors that only define :meth:`__get__` are called "
"non-data descriptors (they are typically used for methods but other uses are "
"possible)."
msgstr ""
"如果一个对象定义了 :meth:`__set__` 或 :meth:`__delete__`，则它会被视为数据描"
"述器。 仅定义了 :meth:`__get__` 的描述器称为非数据描述器（它们通常被用于方"
"法，但也可以有其他用途）。"

#: ../../howto/descriptor.rst:66
msgid ""
"Data and non-data descriptors differ in how overrides are calculated with "
"respect to entries in an instance's dictionary.  If an instance's dictionary "
"has an entry with the same name as a data descriptor, the data descriptor "
"takes precedence.  If an instance's dictionary has an entry with the same "
"name as a non-data descriptor, the dictionary entry takes precedence."
msgstr ""
"数据和非数据描述器的不同之处在于，如何计算实例字典中条目的替代值。如果实例的"
"字典具有与数据描述器同名的条目，则数据描述器优先。如果实例的字典具有与非数据"
"描述器同名的条目，则该字典条目优先。"

#: ../../howto/descriptor.rst:72
msgid ""
"To make a read-only data descriptor, define both :meth:`__get__` and :meth:"
"`__set__` with the :meth:`__set__` raising an :exc:`AttributeError` when "
"called.  Defining the :meth:`__set__` method with an exception raising "
"placeholder is enough to make it a data descriptor."
msgstr ""
"为了使数据描述器成为只读的，应该同时定义 :meth:`__get__` 和 :meth:"
"`__set__` ，并在 :meth:`__set__` 中引发 :exc:`AttributeError` 。用引发异常的"
"占位符定义 :meth:`__set__`  方法使其成为数据描述器。"

#: ../../howto/descriptor.rst:79
msgid "Invoking Descriptors"
msgstr "调用描述器"

#: ../../howto/descriptor.rst:81
msgid ""
"A descriptor can be called directly by its method name.  For example, ``d."
"__get__(obj)``."
msgstr "描述器可以通过其方法名称直接调用。例如， ``d.__get__(obj)`` 。"

#: ../../howto/descriptor.rst:84
msgid ""
"Alternatively, it is more common for a descriptor to be invoked "
"automatically upon attribute access.  For example, ``obj.d`` looks up ``d`` "
"in the dictionary of ``obj``.  If ``d`` defines the method :meth:`__get__`, "
"then ``d.__get__(obj)`` is invoked according to the precedence rules listed "
"below."
msgstr ""
"或者，更常见的是在属性访问时自动调用描述器。例如，在中 ``obj.d`` 会在 ``d`` "
"的字典中查找 ``obj`` 。如果 ``d`` 定义了方法 :meth:`__get__` ，则 ``d."
"__get__(obj)`` 根据下面列出的优先级规则进行调用。"

#: ../../howto/descriptor.rst:89
msgid ""
"The details of invocation depend on whether ``obj`` is an object or a class."
msgstr "调用的细节取决于 ``obj`` 是对象还是类。"

#: ../../howto/descriptor.rst:91
msgid ""
"For objects, the machinery is in :meth:`object.__getattribute__` which "
"transforms ``b.x`` into ``type(b).__dict__['x'].__get__(b, type(b))``.  The "
"implementation works through a precedence chain that gives data descriptors "
"priority over instance variables, instance variables priority over non-data "
"descriptors, and assigns lowest priority to :meth:`__getattr__` if provided. "
"The full C implementation can be found in :c:func:"
"`PyObject_GenericGetAttr()` in :source:`Objects/object.c`."
msgstr ""
"对于对象来说，机制是 :meth:`object.__getattribute__` 中将 ``b.x`` 转换为 "
"``type(b).__dict__['x'].__get__(b, type(b))`` 。这个实现通过一个优先级链完"
"成，该优先级链赋予数据描述器优先于实例变量的优先级，实例变量优先于非数据描述"
"器的优先级，并如果 :meth:`__getattr__` 方法存在，为其分配最低的优先级。 完整"
"的C实现可在 :source:`Objects/object.c` 中的 :c:func:"
"`PyObject_GenericGetAttr()` 找到。"

#: ../../howto/descriptor.rst:99
msgid ""
"For classes, the machinery is in :meth:`type.__getattribute__` which "
"transforms ``B.x`` into ``B.__dict__['x'].__get__(None, B)``.  In pure "
"Python, it looks like::"
msgstr ""
"对于类来说，机制是 :meth:`type.__getattribute__` 中将 ``B.x`` 转换为 ``B."
"__dict__['x'].__get__(None, B)`` 。在纯 Python中 ，它是这样的::"

#: ../../howto/descriptor.rst:110
msgid "The important points to remember are:"
msgstr "要记住的重要点是："

#: ../../howto/descriptor.rst:112
msgid "descriptors are invoked by the :meth:`__getattribute__` method"
msgstr "描述器由 :meth:`__getattribute__` 方法调用"

#: ../../howto/descriptor.rst:113
msgid "overriding :meth:`__getattribute__` prevents automatic descriptor calls"
msgstr "重写 :meth:`__getattribute__` 会阻止描述器的自动调用"

#: ../../howto/descriptor.rst:114
msgid ""
":meth:`object.__getattribute__` and :meth:`type.__getattribute__` make "
"different calls to :meth:`__get__`."
msgstr ""
":meth:`object.__getattribute__` 和 :meth:`type.__getattribute__` 会用不同的方"
"式调用 :meth:`__get__`."

#: ../../howto/descriptor.rst:116
msgid "data descriptors always override instance dictionaries."
msgstr "数据描述器始终会覆盖实例字典。"

#: ../../howto/descriptor.rst:117
msgid "non-data descriptors may be overridden by instance dictionaries."
msgstr "非数据描述器会被实例字典覆盖。"

#: ../../howto/descriptor.rst:119
msgid ""
"The object returned by ``super()`` also has a custom :meth:"
"`__getattribute__` method for invoking descriptors.  The attribute lookup "
"``super(B, obj).m`` searches ``obj.__class__.__mro__`` for the base class "
"``A`` immediately following ``B`` and then returns ``A.__dict__['m']."
"__get__(obj, B)``.  If not a descriptor, ``m`` is returned unchanged.  If "
"not in the dictionary, ``m`` reverts to a search using :meth:`object."
"__getattribute__`."
msgstr ""
" ``super()`` 返回的对象还有一个自定义的 :meth:`__getattribute__` 方法来调用描"
"述器。属性查找 ``super(B, obj).m`` 在 ``obj.__class__.__mro__`` 中搜索紧随 "
"``B`` 后的基类 ``A`` ，然后返回  ``A.__dict__['m'].__get__(obj, B)`` 。如果其"
"不是描述器，则直接返回 ``m`` 。如果不在字典中， ``m`` 才会使用 :meth:`object."
"__getattribute__` 进行搜索。 "

#: ../../howto/descriptor.rst:126
msgid ""
"The implementation details are in :c:func:`super_getattro()` in :source:"
"`Objects/typeobject.c`.  and a pure Python equivalent can be found in "
"`Guido's Tutorial`_."
msgstr ""
"这个实现的具体细节在 :source:`Objects/typeobject.c`. 的 :c:func:"
"`super_getattro()` 中，并且你还可以在 `Guido's Tutorial`_ 中找到等价的纯 "
"Python 实现。"

#: ../../howto/descriptor.rst:132
msgid ""
"The details above show that the mechanism for descriptors is embedded in "
"the :meth:`__getattribute__()` methods for :class:`object`, :class:`type`, "
"and :func:`super`.  Classes inherit this machinery when they derive from :"
"class:`object` or if they have a meta-class providing similar functionality. "
"Likewise, classes can turn-off descriptor invocation by overriding :meth:"
"`__getattribute__()`."
msgstr ""
"以上展示的关于描述器机制的细节嵌入在 :class:`object` ， :class:`type` ， 和 :"
"func:`super` 中的 :meth:`__getattribute__()` 。当类派生自类 :class:`object` "
"或有提供类似功能的元类时，它们将继承此机制。同样，类可以通过重写 :meth:"
"`__getattribute__()` 阻止描述器调用。"

#: ../../howto/descriptor.rst:141
msgid "Descriptor Example"
msgstr "描述器示例"

#: ../../howto/descriptor.rst:143
msgid ""
"The following code creates a class whose objects are data descriptors which "
"print a message for each get or set.  Overriding :meth:`__getattribute__` is "
"alternate approach that could do this for every attribute.  However, this "
"descriptor is useful for monitoring just a few chosen attributes::"
msgstr ""
"以下代码创建一个类，其对象是数据描述器，该描述器为每个 get 或 set 打印一条消"
"息。  覆盖 :meth:`__getattribute__` 是可以对每个属性执行此操作的替代方法。但"
"是，此描述器对于跟踪少数几个选定的属性很有用::"

#: ../../howto/descriptor.rst:181
msgid ""
"The protocol is simple and offers exciting possibilities.  Several use cases "
"are so common that they have been packaged into individual function calls. "
"Properties, bound methods, static methods, and class methods are all based "
"on the descriptor protocol."
msgstr ""
"这个协议很简单，并提供了令人兴奋的可能性。有几种用例非常普遍，以至于它们被打"
"包到单独的函数调用中。属性、绑定方法、静态方法和类方法均基于描述器协议。"

#: ../../howto/descriptor.rst:188
msgid "Properties"
msgstr "属性"

#: ../../howto/descriptor.rst:190
msgid ""
"Calling :func:`property` is a succinct way of building a data descriptor "
"that triggers function calls upon access to an attribute.  Its signature is::"
msgstr ""
"调用 :func:`property` 是构建数据描述器的简洁方式，该数据描述器在访问属性时触"
"发函数调用。它的签名是::"

#: ../../howto/descriptor.rst:195
msgid ""
"The documentation shows a typical use to define a managed attribute ``x``::"
msgstr "该文档显示了定义托管属性 ``x`` 的典型用法::"

#: ../../howto/descriptor.rst:203
msgid ""
"To see how :func:`property` is implemented in terms of the descriptor "
"protocol, here is a pure Python equivalent::"
msgstr ""
"要了解 :func:`property` 如何根据描述器协议实现，这里是一个纯 Python 的等价实"
"现如下::"

#: ../../howto/descriptor.rst:243
msgid ""
"The :func:`property` builtin helps whenever a user interface has granted "
"attribute access and then subsequent changes require the intervention of a "
"method."
msgstr ""
"这个内置的 :func:`property` 每当用户访问属性时生效，随后的变化需要一个方法的"
"参与。"

#: ../../howto/descriptor.rst:247
msgid ""
"For instance, a spreadsheet class may grant access to a cell value through "
"``Cell('b10').value``. Subsequent improvements to the program require the "
"cell to be recalculated on every access; however, the programmer does not "
"want to affect existing client code accessing the attribute directly.  The "
"solution is to wrap access to the value attribute in a property data "
"descriptor::"
msgstr ""
"例如，一个电子表格类可以通过 ``Cell('b10').value`` 授予对单元格值的访问权限。"
"对程序的后续改进要求每次访问都要重新计算单元格；但是，程序员不希望影响直接访"
"问该属性的现有客户端代码。解决方案是将对 value 属性的访问包装在属性数据描述器"
"中::"

#: ../../howto/descriptor.rst:263
msgid "Functions and Methods"
msgstr "函数和方法"

#: ../../howto/descriptor.rst:265
msgid ""
"Python's object oriented features are built upon a function based "
"environment. Using non-data descriptors, the two are merged seamlessly."
msgstr ""
"Python 的面向对象功能是在基于函数的环境构建的。通过使用非数据描述器，这两方面"
"完成了无缝融合。"

#: ../../howto/descriptor.rst:268
msgid ""
"Class dictionaries store methods as functions.  In a class definition, "
"methods are written using :keyword:`def` or :keyword:`lambda`, the usual "
"tools for creating functions.  Methods only differ from regular functions in "
"that the first argument is reserved for the object instance.  By Python "
"convention, the instance reference is called *self* but may be called *this* "
"or any other variable name."
msgstr ""
"类字典将方法存储为函数。在类定义中，方法是用 :keyword:`def` 或 :keyword:"
"`lambda` 这两个创建函数的常用工具编写的。方法与常规函数的不同之处仅在于第一个"
"参数是为对象实例保留的。按照 Python 约定，实例引用称为 *self* ，但也可以称为 "
"*this* 或任何其他变量名称。"

#: ../../howto/descriptor.rst:275
msgid ""
"To support method calls, functions include the :meth:`__get__` method for "
"binding methods during attribute access.  This means that all functions are "
"non-data descriptors which return bound methods when they are invoked from "
"an object.  In pure Python, it works like this::"
msgstr ""
"为了支持方法调用，函数包含 :meth:`__get__` 方法用于在访问属性时将其绑定成方"
"法。这意味着所有函数都是非数据描述器，当从对象调用它们时，它们返回绑定方法。"
"在纯 Python 中，它的工作方式如下::"

#: ../../howto/descriptor.rst:288
msgid ""
"Running the interpreter shows how the function descriptor works in practice::"
msgstr "运行解释器显示了函数描述器在实践中的工作方式："

#: ../../howto/descriptor.rst:324
msgid "Static Methods and Class Methods"
msgstr "静态方法和类方法"

#: ../../howto/descriptor.rst:326
msgid ""
"Non-data descriptors provide a simple mechanism for variations on the usual "
"patterns of binding functions into methods."
msgstr "非数据描述器为把函数绑定为方法的通常模式提供了一种简单的机制。"

#: ../../howto/descriptor.rst:329
msgid ""
"To recap, functions have a :meth:`__get__` method so that they can be "
"converted to a method when accessed as attributes.  The non-data descriptor "
"transforms an ``obj.f(*args)`` call into ``f(obj, *args)``.  Calling ``klass."
"f(*args)`` becomes ``f(*args)``."
msgstr ""
"概括地说，函数具有 :meth:`__get__` 方法，以便在作为属性访问时可以将其转换为方"
"法。非数据描述符将 ``obj.f(*args)`` 的调用转换为 ``f(obj, *args)`` 。调用 "
"`klass.f(*args)`` 因而变成 ``f(*args)`` 。"

#: ../../howto/descriptor.rst:334
msgid "This chart summarizes the binding and its two most useful variants:"
msgstr "下表总结了绑定及其两个最有用的变体："

#: ../../howto/descriptor.rst:337
msgid "Transformation"
msgstr "转换形式"

#: ../../howto/descriptor.rst:337
msgid "Called from an Object"
msgstr "通过对象调用"

#: ../../howto/descriptor.rst:337
msgid "Called from a Class"
msgstr "通过类调用"

#: ../../howto/descriptor.rst:340
msgid "function"
msgstr "function -- 函数"

#: ../../howto/descriptor.rst:340
msgid "f(obj, \\*args)"
msgstr "f(obj, \\*args)"

#: ../../howto/descriptor.rst:340 ../../howto/descriptor.rst:342
msgid "f(\\*args)"
msgstr "f(\\*args)"

#: ../../howto/descriptor.rst:342
msgid "staticmethod"
msgstr "静态方法"

#: ../../howto/descriptor.rst:344
msgid "classmethod"
msgstr "类方法"

#: ../../howto/descriptor.rst:344
msgid "f(type(obj), \\*args)"
msgstr "f(type(obj), \\*args)"

#: ../../howto/descriptor.rst:344
msgid "f(klass, \\*args)"
msgstr "f(klass, \\*args)"

#: ../../howto/descriptor.rst:347
msgid ""
"Static methods return the underlying function without changes.  Calling "
"either ``c.f`` or ``C.f`` is the equivalent of a direct lookup into ``object."
"__getattribute__(c, \"f\")`` or ``object.__getattribute__(C, \"f\")``. As a "
"result, the function becomes identically accessible from either an object or "
"a class."
msgstr ""
"静态方法返回底层函数，不做任何更改。调用 ``c.f`` 或 ``C.f`` 等效于通过 "
"``object.__getattribute__(c, \"f\")`` 或 ``object.__getattribute__(C, "
"\"f\")`` 查找。这样该函数就可以从对象或类中进行相同的访问。"

#: ../../howto/descriptor.rst:353
msgid ""
"Good candidates for static methods are methods that do not reference the "
"``self`` variable."
msgstr "适合于作为静态方法的是那些不引用 ``self`` 变量的方法。"

#: ../../howto/descriptor.rst:356
msgid ""
"For instance, a statistics package may include a container class for "
"experimental data.  The class provides normal methods for computing the "
"average, mean, median, and other descriptive statistics that depend on the "
"data. However, there may be useful functions which are conceptually related "
"but do not depend on the data.  For instance, ``erf(x)`` is handy conversion "
"routine that comes up in statistical work but does not directly depend on a "
"particular dataset. It can be called either from an object or the class:  "
"``s.erf(1.5) --> .9332`` or ``Sample.erf(1.5) --> .9332``."
msgstr ""
"例如，一个统计用的包可能包含一个实验数据的容器类。该容器类提供了用于计算数据"
"的平均值，均值，中位数和其他描述性统计信息的常规方法。但是，可能有在概念上相"
"关但不依赖于数据的函数。例如， ``erf(x)`` 是在统计中的便捷转换，但并不直接依"
"赖于特定的数据集。可以从对象或类中调用它： ``s.erf(1.5) --> .9332`` 或 "
"``Sample.erf(1.5) --> .9332``。"

#: ../../howto/descriptor.rst:365
msgid ""
"Since staticmethods return the underlying function with no changes, the "
"example calls are unexciting::"
msgstr "由于静态方法直接返回了底层的函数，因此示例调用是相同的："

#: ../../howto/descriptor.rst:378
msgid ""
"Using the non-data descriptor protocol, a pure Python version of :func:"
"`staticmethod` would look like this::"
msgstr "使用非数据描述器，纯 Python 版本的 :func:`staticmethod` 如下所示："

#: ../../howto/descriptor.rst:390
msgid ""
"Unlike static methods, class methods prepend the class reference to the "
"argument list before calling the function.  This format is the same for "
"whether the caller is an object or a class::"
msgstr ""
"与静态方法不同，类方法在调用函数之前将类引用放在参数列表的最前。无论调用方是"
"对象还是类，此格式相同："

#: ../../howto/descriptor.rst:405
msgid ""
"This behavior is useful whenever the function only needs to have a class "
"reference and does not care about any underlying data.  One use for "
"classmethods is to create alternate class constructors.  In Python 2.3, the "
"classmethod :func:`dict.fromkeys` creates a new dictionary from a list of "
"keys.  The pure Python equivalent is::"
msgstr ""
"此行为适用于当函数仅需要使用类引用并且不关心任何底层数据时的情况。 类方法的一"
"种用途是创建替代的类构造器。 在 Python 2.3 中，类方法 :func:`dict.fromkeys` "
"会从键列表中创建一个新的字典。 纯 Python 的等价形式是::"

#: ../../howto/descriptor.rst:421
msgid "Now a new dictionary of unique keys can be constructed like this::"
msgstr "现在可以这样构造一个新的唯一键字典："

#: ../../howto/descriptor.rst:426
msgid ""
"Using the non-data descriptor protocol, a pure Python version of :func:"
"`classmethod` would look like this::"
msgstr "使用非数据描述符协议，纯 Python 版本的 :func:`classmethod` 如下："
