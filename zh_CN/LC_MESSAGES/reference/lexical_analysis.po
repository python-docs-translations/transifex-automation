# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# eric R <trencyclopedia@gmail.com>, 2019
# 1lin24 <1lin24@sina.com>, 2019
# Freesand Leo <yuqinju@163.com>, 2020
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-06-02 14:49+0000\n"
"PO-Revision-Date: 2019-09-01 03:42+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2020\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:6
msgid "Lexical analysis"
msgstr "词法分析"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:10
msgid ""
"A Python program is read by a *parser*.  Input to the parser is a stream of "
"*tokens*, generated by the *lexical analyzer*.  This chapter describes how "
"the lexical analyzer breaks a file into tokens."
msgstr ""
"Python 程序由一个 *解析器* 读取。输入到解析器的是一个由 *词法分析器* 所生成的 *形符* "
"流，本章将描述词法分析器是如何将一个文件拆分为一个个形符的。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:14
msgid ""
"Python reads program text as Unicode code points; the encoding of a source "
"file can be given by an encoding declaration and defaults to UTF-8, see "
":pep:`3120` for details.  If the source file cannot be decoded, a "
":exc:`SyntaxError` is raised."
msgstr ""
"Python 会将读取的程序文本转为 Unicode 码点；源文件的文本编码可由编码声明指定，默认为 UTF-8，详情见 "
":pep:`3120`。如果源文件无法被解码，将会引发 :exc:`SyntaxError`。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:23
msgid "Line structure"
msgstr "行结构"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:27
msgid "A Python program is divided into a number of *logical lines*."
msgstr "一个 Python 程序可分为许多 *逻辑行*。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:33
msgid "Logical lines"
msgstr "逻辑行"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:37
msgid ""
"The end of a logical line is represented by the token NEWLINE.  Statements "
"cannot cross logical line boundaries except where NEWLINE is allowed by the "
"syntax (e.g., between statements in compound statements). A logical line is "
"constructed from one or more *physical lines* by following the explicit or "
"implicit *line joining* rules."
msgstr ""
"逻辑行的结束是以 NEWLINE 形符表示的。语句不能跨越逻辑行的边界，除非其语法允许包含 NEWLINE "
"(例如复合语句可由多行子语句组成)。一个逻辑行可由一个或多个 *物理行* 按照明确或隐含的 *行拼接* 规则构成。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:47
msgid "Physical lines"
msgstr "物理行"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:49
msgid ""
"A physical line is a sequence of characters terminated by an end-of-line "
"sequence.  In source files and strings, any of the standard platform line "
"termination sequences can be used - the Unix form using ASCII LF (linefeed),"
" the Windows form using the ASCII sequence CR LF (return followed by "
"linefeed), or the old Macintosh form using the ASCII CR (return) character."
"  All of these forms can be used equally, regardless of platform. The end of"
" input also serves as an implicit terminator for the final physical line."
msgstr ""
"物理行是以一个行终止序列结束的字符序列。在源文件和字符串中，可以使用任何标准平台上的行终止序列 - Unix 所用的 ASCII 字符 LF (换行),"
" Windows 所用的 ASCII 字符序列 CR LF (回车加换行), 或者旧 Macintosh 所用的 ASCII 字符 CR "
"(回车)。所有这些形式均可使用，无论具体平台。输入的结束也会被作为最后一个物理行的隐含终止标志。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:57
msgid ""
"When embedding Python, source code strings should be passed to Python APIs "
"using the standard C conventions for newline characters (the ``\\n`` "
"character, representing ASCII LF, is the line terminator)."
msgstr ""
"当嵌入 Python 时，源码字符串传入 Python API 应使用标准 C 的传统换行符 (即 ``\\n``，表示 ASCII 字符 LF "
"作为行终止标志)。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:65
msgid "Comments"
msgstr "注释"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:70
msgid ""
"A comment starts with a hash character (``#``) that is not part of a string "
"literal, and ends at the end of the physical line.  A comment signifies the "
"end of the logical line unless the implicit line joining rules are invoked. "
"Comments are ignored by the syntax."
msgstr ""
"一条注释以不包含在字符串字面值内的井号 (``#``) 开头，并在物理行的末尾结束。 一条注释标志着逻辑行的结束，除非存在隐含的行拼接规则。 "
"注释在语法分析中会被忽略。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:79
msgid "Encoding declarations"
msgstr "编码声明"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:84
msgid ""
"If a comment in the first or second line of the Python script matches the "
"regular expression ``coding[=:]\\s*([-\\w.]+)``, this comment is processed "
"as an encoding declaration; the first group of this expression names the "
"encoding of the source code file. The encoding declaration must appear on a "
"line of its own. If it is the second line, the first line must also be a "
"comment-only line. The recommended forms of an encoding expression are ::"
msgstr ""
"如果一条注释位于 Python 脚本的第一或第二行，并且匹配正则表达式 "
"``coding[=:]\\s*([-\\w.]+)``，这条注释会被作为编码声明来处理；上述表达式的第一组指定了源码文件的编码。编码声明必须独占一行。如果它是在第二行，则第一行也必须是注释。推荐的编码声明形式如下"
" ::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:93
msgid "which is recognized also by GNU Emacs, and ::"
msgstr "这也是 GNU Emacs 认可的形式，以及 ::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:97
msgid "which is recognized by Bram Moolenaar's VIM."
msgstr "这是 Bram Moolenaar 的 VIM 认可的形式。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:99
msgid ""
"If no encoding declaration is found, the default encoding is UTF-8.  In "
"addition, if the first bytes of the file are the UTF-8 byte-order mark "
"(``b'\\xef\\xbb\\xbf'``), the declared file encoding is UTF-8 (this is "
"supported, among others, by Microsoft's :program:`notepad`)."
msgstr ""
"如果没有编码声明，则默认编码为 UTF-8。此外，如果文件的首字节为 UTF-8 字节顺序标志 "
"(``b'\\xef\\xbb\\xbf'``)，文件编码也声明为 UTF-8 (这是 Microsoft 的 :program:`notepad` "
"等软件支持的形式)。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:104
msgid ""
"If an encoding is declared, the encoding name must be recognized by Python. "
"The encoding is used for all lexical analysis, including string literals, "
"comments and identifiers."
msgstr "编码声明指定的编码名称必须是 Python 所认可的编码。所有词法分析将使用此编码，包括语义字符串、注释和标识符。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:114
msgid "Explicit line joining"
msgstr "显式的行拼接"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:118
msgid ""
"Two or more physical lines may be joined into logical lines using backslash "
"characters (``\\``), as follows: when a physical line ends in a backslash "
"that is not part of a string literal or comment, it is joined with the "
"following forming a single logical line, deleting the backslash and the "
"following end-of-line character.  For example::"
msgstr ""
"两个或更多个物理行可使用反斜杠字符 (``\\``) 拼接为一个逻辑行，规则如下: "
"当一个物理行以一个不在字符串或注释内的反斜杠结尾时，它将与下一行拼接构成一个单独的逻辑行，反斜杠及其后的换行符会被删除。例如::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:129
msgid ""
"A line ending in a backslash cannot carry a comment.  A backslash does not "
"continue a comment.  A backslash does not continue a token except for string"
" literals (i.e., tokens other than string literals cannot be split across "
"physical lines using a backslash).  A backslash is illegal elsewhere on a "
"line outside a string literal."
msgstr ""
"以反斜杠结束的行不能带有注释。反斜杠不能用来拼接注释。反斜杠不能用来拼接形符，字符串除外 "
"(即原文字符串以外的形符不能用反斜杠分隔到两个物理行)。不允许有原文字符串以外的反斜杠存在于物理行的其他位置。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:139
msgid "Implicit line joining"
msgstr "隐式的行拼接"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:141
msgid ""
"Expressions in parentheses, square brackets or curly braces can be split "
"over more than one physical line without using backslashes. For example::"
msgstr "圆括号、方括号或花括号以内的表达式允许分成多个物理行，无需使用反斜杠。例如::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:149
msgid ""
"Implicitly continued lines can carry comments.  The indentation of the "
"continuation lines is not important.  Blank continuation lines are allowed. "
"There is no NEWLINE token between implicit continuation lines.  Implicitly "
"continued lines can also occur within triple-quoted strings (see below); in "
"that case they cannot carry comments."
msgstr ""
"隐式的行拼接可以带有注释。后续行的缩进不影响程序结构。后续行也允许为空白行。隐式拼接的行之间不会有 NEWLINE "
"形符。隐式拼接的行也可以出现于三引号字符串中 (见下)；此情况下这些行不允许带有注释。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:159
msgid "Blank lines"
msgstr "空白行"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:163
msgid ""
"A logical line that contains only spaces, tabs, formfeeds and possibly a "
"comment, is ignored (i.e., no NEWLINE token is generated).  During "
"interactive input of statements, handling of a blank line may differ "
"depending on the implementation of the read-eval-print loop.  In the "
"standard interactive interpreter, an entirely blank logical line (i.e. one "
"containing not even whitespace or a comment) terminates a multi-line "
"statement."
msgstr ""
"一个只包含空格符，制表符，进纸符或者注释的逻辑行会被忽略 (即不生成 NEWLINE 形符)。在交互模式输入语句时，对空白行的处理可能会因读取-求值-"
"打印循环的具体实现方式而存在差异。在标准交互模式解释器中，一个完全空白的逻辑行 (即连空格或注释都没有) 将会结束一条多行复合语句。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:174
msgid "Indentation"
msgstr "缩进"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:178
msgid ""
"Leading whitespace (spaces and tabs) at the beginning of a logical line is "
"used to compute the indentation level of the line, which in turn is used to "
"determine the grouping of statements."
msgstr "一个逻辑行开头处的空白 (空格符和制表符) 被用来计算该行的缩进等级，以决定语句段落的组织结构。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:182
msgid ""
"Tabs are replaced (from left to right) by one to eight spaces such that the "
"total number of characters up to and including the replacement is a multiple"
" of eight (this is intended to be the same rule as used by Unix).  The total"
" number of spaces preceding the first non-blank character then determines "
"the line's indentation.  Indentation cannot be split over multiple physical "
"lines using backslashes; the whitespace up to the first backslash determines"
" the indentation."
msgstr ""
"制表符会被 (从左至右) 替换为一至八个空格，这样缩进的空格总数为八的倍数 (这是为了与 Unix "
"所用的规则一致)。首个非空白字符之前的空格总数将确定该行的缩进层次。一个缩进不可使用反斜杠进行多行拼接；首个反斜杠之前的空格将确定缩进层次。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:190
msgid ""
"Indentation is rejected as inconsistent if a source file mixes tabs and "
"spaces in a way that makes the meaning dependent on the worth of a tab in "
"spaces; a :exc:`TabError` is raised in that case."
msgstr ""
"在一个源文件中如果混合使用制表符和空格符缩进，并使得确定缩进层次需要依赖于制表符对应的空格数量设置，则被视为不合规则；此情况将会引发 "
":exc:`TabError`。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:194
msgid ""
"**Cross-platform compatibility note:** because of the nature of text editors"
" on non-UNIX platforms, it is unwise to use a mixture of spaces and tabs for"
" the indentation in a single source file.  It should also be noted that "
"different platforms may explicitly limit the maximum indentation level."
msgstr ""
"**跨平台兼容性注释:** 由于非 UNIX "
"平台上文本编辑器本身的特性，在一个源文件中混合使用制表符和空格符是不明智的。另外也要注意不同平台还可能会显式地限制最大缩进层级。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:199
msgid ""
"A formfeed character may be present at the start of the line; it will be "
"ignored for the indentation calculations above.  Formfeed characters "
"occurring elsewhere in the leading whitespace have an undefined effect (for "
"instance, they may reset the space count to zero)."
msgstr ""
"行首有时可能会有一个进纸符；它在上述缩进层级计算中会被忽略。处于行首空格内其他位置的进纸符的效果未定义 (例如它可能导致空格计数重置为零)。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:206
msgid ""
"The indentation levels of consecutive lines are used to generate INDENT and "
"DEDENT tokens, using a stack, as follows."
msgstr "多个连续行各自的缩进层级将会被放入一个堆栈用来生成 INDENT 和 DEDENT 形符，具体说明如下。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:209
msgid ""
"Before the first line of the file is read, a single zero is pushed on the "
"stack; this will never be popped off again.  The numbers pushed on the stack"
" will always be strictly increasing from bottom to top.  At the beginning of"
" each logical line, the line's indentation level is compared to the top of "
"the stack. If it is equal, nothing happens. If it is larger, it is pushed on"
" the stack, and one INDENT token is generated.  If it is smaller, it *must* "
"be one of the numbers occurring on the stack; all numbers on the stack that "
"are larger are popped off, and for each number popped off a DEDENT token is "
"generated.  At the end of the file, a DEDENT token is generated for each "
"number remaining on the stack that is larger than zero."
msgstr ""
"在读取文件的第一行之前，先向堆栈推入一个零值；它将不再被弹出。被推入栈的层级数值从底至顶持续增加。每个逻辑行开头的行缩进层级将与栈顶行比较。如果相同，则不做处理。如果新行层级较高，则会被推入栈顶，并生成一个"
" INDENT 形符。如果新行层级较低，则 *应当* 是栈中的层级数值之一；栈中高于该层级的所有数值都将被弹出，每弹出一级数值生成一个 DEDENT "
"形符。在文件末尾，栈中剩余的每个大于零的数值生成一个 DEDENT 形符。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:220
msgid ""
"Here is an example of a correctly (though confusingly) indented piece of "
"Python code::"
msgstr "这是一个正确 (但令人迷惑) 的Python 代码缩进示例::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:235
msgid "The following example shows various indentation errors::"
msgstr "以下示例显示了各种缩进错误::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:245
msgid ""
"(Actually, the first three errors are detected by the parser; only the last "
"error is found by the lexical analyzer --- the indentation of ``return r`` "
"does not match a level popped off the stack.)"
msgstr ""
"(实际上，前三个错误会被解析器发现；只有最后一个错误是由词法分析器发现的 --- ``return r`` 的缩进无法匹配弹出栈的缩进层级。)"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:253
msgid "Whitespace between tokens"
msgstr "形符之间的空白"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:255
msgid ""
"Except at the beginning of a logical line or in string literals, the "
"whitespace characters space, tab and formfeed can be used interchangeably to"
" separate tokens.  Whitespace is needed between two tokens only if their "
"concatenation could otherwise be interpreted as a different token (e.g., ab "
"is one token, but a b is two tokens)."
msgstr ""
"除非是在逻辑行的开头或字符串内，空格符、制表符和进纸符等空白符都同样可以用来分隔形符。如果两个形符彼此相连会被解析为一个不同的形符，则需要使用空白来分隔"
" (例如 ab 是一个形符，而 a b 是两个形符)。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:265
msgid "Other tokens"
msgstr "其他形符"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:267
msgid ""
"Besides NEWLINE, INDENT and DEDENT, the following categories of tokens "
"exist: *identifiers*, *keywords*, *literals*, *operators*, and *delimiters*."
" Whitespace characters (other than line terminators, discussed earlier) are "
"not tokens, but serve to delimit tokens. Where ambiguity exists, a token "
"comprises the longest possible string that forms a legal token, when read "
"from left to right."
msgstr ""
"除了 NEWLINE, INDENT 和 DEDENT，还存在以下类别的形符: *标识符*, *关键字*, *字面值*, *运算符* 以及 *分隔符*。"
" 空白字符 (之前讨论过的行终止符除外) 不属于形符，而是用来分隔形符。如果存在二义性，将从左至右读取尽可能长的合法字符串组成一个形符。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:277
msgid "Identifiers and keywords"
msgstr "标识符和关键字"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:281
msgid ""
"Identifiers (also referred to as *names*) are described by the following "
"lexical definitions."
msgstr "标识符 (或者叫做 *名称*) 由以下词法定义进行描述。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:284
msgid ""
"The syntax of identifiers in Python is based on the Unicode standard annex "
"UAX-31, with elaboration and changes as defined below; see also :pep:`3131` "
"for further details."
msgstr ""
"Python 中的标识符语法是基于 Unicode 标准附件 UAX-31，并加入了下文所定义的细化与修改；更多细节还可参见 :pep:`3131` 。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:288
msgid ""
"Within the ASCII range (U+0001..U+007F), the valid characters for "
"identifiers are the same as in Python 2.x: the uppercase and lowercase "
"letters ``A`` through ``Z``, the underscore ``_`` and, except for the first "
"character, the digits ``0`` through ``9``."
msgstr ""
"在 ASCII 范围内 (U+0001..U+007F)，可用于标识符的字符与 Python 2.x 一致: 大写和小写字母 ``A`` 至 "
"``Z``，下划线 ``_`` 以及数字 ``0`` 至 ``9``，但不可以数字打头。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:293
msgid ""
"Python 3.0 introduces additional characters from outside the ASCII range "
"(see :pep:`3131`).  For these characters, the classification uses the "
"version of the Unicode Character Database as included in the "
":mod:`unicodedata` module."
msgstr ""
"Python 3.0 引入了 ASCII 范围以外的额外字符 (见 :pep:`3131`)。这些字符的分类使用包含于 "
":mod:`unicodedata` 模块中的 Unicode 字符数据库版本。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:297
msgid "Identifiers are unlimited in length.  Case is significant."
msgstr "标识符的长度没有限制。对大小写敏感。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:306
msgid "The Unicode category codes mentioned above stand for:"
msgstr "上文所用 Unicode 类别码的含义:"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:308
msgid "*Lu* - uppercase letters"
msgstr "*Lu* - 大写字母"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:309
msgid "*Ll* - lowercase letters"
msgstr "*Ll* - 小写字母"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:310
msgid "*Lt* - titlecase letters"
msgstr "*Lt* - 词首大写字母"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:311
msgid "*Lm* - modifier letters"
msgstr "*Lm* - 修饰字母"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:312
msgid "*Lo* - other letters"
msgstr "*Lo* - 其他字母"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:313
msgid "*Nl* - letter numbers"
msgstr "*Nl* - 字母数字"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:314
msgid "*Mn* - nonspacing marks"
msgstr "*Mn* - 非空白标识"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:315
msgid "*Mc* - spacing combining marks"
msgstr "*Mc* - 含空白标识"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:316
msgid "*Nd* - decimal numbers"
msgstr "*Nd* - 十进制数字"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:317
msgid "*Pc* - connector punctuations"
msgstr "*Pc* - 连接标点"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:318
msgid ""
"*Other_ID_Start* - explicit list of characters in `PropList.txt "
"<http://www.unicode.org/Public/11.0.0/ucd/PropList.txt>`_ to support "
"backwards compatibility"
msgstr ""
"*Other_ID_Start* - 由 `PropList.txt "
"<http://www.unicode.org/Public/11.0.0/ucd/PropList.txt>`_ 定义的显式字符列表，用来支持向后兼容"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:321
msgid "*Other_ID_Continue* - likewise"
msgstr "*Other_ID_Continue* - 同上"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:323
msgid ""
"All identifiers are converted into the normal form NFKC while parsing; "
"comparison of identifiers is based on NFKC."
msgstr "所有标识符在解析时会被转换为规范形式 NFKC；标识符的比较都是基于 NFKC。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:326
msgid ""
"A non-normative HTML file listing all valid identifier characters for "
"Unicode 4.1 can be found at "
"https://www.unicode.org/Public/13.0.0/ucd/DerivedCoreProperties.txt"
msgstr ""
"Unicode 4.1 中所有可用的标识符字符列表可参见以下非正式 HTML 文件 "
"https://www.unicode.org/Public/13.0.0/ucd/DerivedCoreProperties.txt"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:334
msgid "Keywords"
msgstr "关键字"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:340
msgid ""
"The following identifiers are used as reserved words, or *keywords* of the "
"language, and cannot be used as ordinary identifiers.  They must be spelled "
"exactly as written here:"
msgstr "以下标识符被作为语言的保留字或称 *关键字*，不可被用作普通标识符。关键字的拼写必须与这里列出的完全一致。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:360
msgid "Reserved classes of identifiers"
msgstr "保留的标识符类"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:362
msgid ""
"Certain classes of identifiers (besides keywords) have special meanings.  "
"These classes are identified by the patterns of leading and trailing "
"underscore characters:"
msgstr "某些标识符类 (除了关键字) 具有特殊的含义。这些标识符类的命名模式是以下划线字符打头和结尾:"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:376
msgid "``_*``"
msgstr "``_*``"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:367
msgid ""
"Not imported by ``from module import *``.  The special identifier ``_`` is "
"used in the interactive interpreter to store the result of the last "
"evaluation; it is stored in the :mod:`builtins` module.  When not in "
"interactive mode, ``_`` has no special meaning and is not defined. See "
"section :ref:`import`."
msgstr ""
"不会被 ``from module import *`` 导入。特殊标识符 ``_`` 在交互式解释器中被用来存放最近一次求值结果；它保存在 "
":mod:`builtins` 模块中。当不处于交互模式时，``_`` 无特殊含义也没有预定义。参见 :ref:`import`。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:374
msgid ""
"The name ``_`` is often used in conjunction with internationalization; refer"
" to the documentation for the :mod:`gettext` module for more information on "
"this convention."
msgstr "``_`` 作为名称常用于连接国际化文本；请参看 :mod:`gettext` 模块文档了解有关此约定的详情。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:384
msgid "``__*__``"
msgstr "``__*__``"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:379
msgid ""
"System-defined names, informally known as \"dunder\" names. These names are "
"defined by the interpreter and its implementation (including the standard "
"library). Current system names are discussed in the :ref:`specialnames` "
"section and elsewhere. More will likely be defined in future versions of "
"Python.  *Any* use of ``__*__`` names, in any context, that does not follow "
"explicitly documented use, is subject to breakage without warning."
msgstr ""
"系统定义的名称，在非正式场合下被叫做 \"dunder\" 名称。 这些名称是由解释器及其实现（包括标准库）定义的。 现有系统定义名称相关的讨论请参见 "
":ref:`specialnames` 等章节。 未来的 Python 版本中还将定义更多此类名称。 任何情况下 *任何* 不遵循文档所显式指明的 "
"``__*__`` 名称使用方式都可能导致无警告的错误。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:391
msgid "``__*``"
msgstr "``__*``"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:387
msgid ""
"Class-private names.  Names in this category, when used within the context "
"of a class definition, are re-written to use a mangled form to help avoid "
"name clashes between \"private\" attributes of base and derived classes. See"
" section :ref:`atom-identifiers`."
msgstr ""
"类的私有名称。这种名称在类定义中使用时，会以一种混合形式重写以避免在基类及派生类的 \"私有\" 属性之间出现名称冲突。参见 :ref:`atom-"
"identifiers`。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:396
msgid "Literals"
msgstr "字面值"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:400
msgid "Literals are notations for constant values of some built-in types."
msgstr "字面值用于表示一些内置类型的常量。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:411
msgid "String and Bytes literals"
msgstr "字符串和字节串字面值"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:413
msgid "String literals are described by the following lexical definitions:"
msgstr "字符串字面值由以下词法定义进行描述:"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:438
msgid ""
"One syntactic restriction not indicated by these productions is that "
"whitespace is not allowed between the :token:`stringprefix` or "
":token:`bytesprefix` and the rest of the literal. The source character set "
"is defined by the encoding declaration; it is UTF-8 if no encoding "
"declaration is given in the source file; see section :ref:`encodings`."
msgstr ""
"这些条目中未提及的一个语法限制是 :token:`stringprefix` 或 :token:`bytesprefix` "
"与字面值的剩余部分之间不允许有空白。源字符集是由编码声明定义的；如果源文件中没有编码声明则默认为 UTF-8；参见 :ref:`encodings`。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:448
msgid ""
"In plain English: Both types of literals can be enclosed in matching single "
"quotes (``'``) or double quotes (``\"``).  They can also be enclosed in "
"matching groups of three single or double quotes (these are generally "
"referred to as *triple-quoted strings*).  The backslash (``\\``) character "
"is used to escape characters that otherwise have a special meaning, such as "
"newline, backslash itself, or the quote character."
msgstr ""
"自然语言描述: 两种字面值都可以用成对单引号 (``'``) 或双引号 (``\"``) 来标示首尾。它们也可以用成对的连续三个单引号或双引号来标示首尾"
" (这通常被称为 *三引号字符串*)。反斜杠 (``\\``) 字符被用来对特殊含义的字符进行转义，例如换行，反斜杠本身或是引号等字符。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:459
msgid ""
"Bytes literals are always prefixed with ``'b'`` or ``'B'``; they produce an "
"instance of the :class:`bytes` type instead of the :class:`str` type.  They "
"may only contain ASCII characters; bytes with a numeric value of 128 or "
"greater must be expressed with escapes."
msgstr ""
"字节串字面值总是带有前缀 ``'b'`` 或 ``'B'``；它们生成 :class:`bytes` 类型而非 :class:`str` "
"类型的实例。它们只能包含 ASCII 字符；字节对应数值在128及以上必须以转义形式来表示。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:468
msgid ""
"Both string and bytes literals may optionally be prefixed with a letter "
"``'r'`` or ``'R'``; such strings are called :dfn:`raw strings` and treat "
"backslashes as literal characters.  As a result, in string literals, "
"``'\\U'`` and ``'\\u'`` escapes in raw strings are not treated specially. "
"Given that Python 2.x's raw unicode literals behave differently than Python "
"3.x's the ``'ur'`` syntax is not supported."
msgstr ""
"字符串和字节串字面值都可以带有前缀 ``'r'`` 或 ``'R'``；这种字符串被称为 :dfn:`原始字符串` "
"其中的反斜杠会被当作其本身的字面字符来处理。因此在原始字符串字面值中，``'\\U'`` 和 ``'\\u'`` 转义形式不会被特殊对待。由于 "
"Python 2.x 的原始统一码字面值的特性与 Python 3.x 不一致，``'ur'`` 语法已不再被支持。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:475
msgid ""
"The ``'rb'`` prefix of raw bytes literals has been added as a synonym of "
"``'br'``."
msgstr "新加入了表示原始字节串的 ``'rb'`` 前缀，与 ``'br'`` 的意义相同。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:479
msgid ""
"Support for the unicode legacy literal (``u'value'``) was reintroduced to "
"simplify the maintenance of dual Python 2.x and 3.x codebases. See "
":pep:`414` for more information."
msgstr ""
"对旧式统一码字面值 (``u'value'``) 的支持被重新引入以简化 Python 2.x 和 3.x 代码库的同步维护。详情见 "
":pep:`414`。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:488
msgid ""
"A string literal with ``'f'`` or ``'F'`` in its prefix is a :dfn:`formatted "
"string literal`; see :ref:`f-strings`.  The ``'f'`` may be combined with "
"``'r'``, but not with ``'b'`` or ``'u'``, therefore raw formatted strings "
"are possible, but formatted bytes literals are not."
msgstr ""
"包含 ``'f'`` 或 ``'F'`` 前缀的字符串字面值称为 :dfn:`格式化字符串字面值`；参见 "
":ref:`f-strings`。``'f'`` 可与 ``'r'`` 连用，但不能与 ``'b'`` 或 ``'u'`` "
"连用，因此存在原始格式化字符串，但不存在格式化字节串字面值。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:493
msgid ""
"In triple-quoted literals, unescaped newlines and quotes are allowed (and "
"are retained), except that three unescaped quotes in a row terminate the "
"literal.  (A \"quote\" is the character used to open the literal, i.e. "
"either ``'`` or ``\"``.)"
msgstr ""
"在三引号字面值中，允许存在未经转义的换行和引号 (并原样保留)，除非是未经转义的连续三引号，这标示着字面值的结束。 (\"引号\" "
"是用来标示字面值的字符，即 ``'`` 或 ``\"``。)"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:512
msgid ""
"Unless an ``'r'`` or ``'R'`` prefix is present, escape sequences in string "
"and bytes literals are interpreted according to rules similar to those used "
"by Standard C.  The recognized escape sequences are:"
msgstr ""
"除非带有 ``'r'`` 或 ``'R'`` 前缀，字符串和字节串字面值中的转义序列会基于类似标准 C 中的转义规则来解读。可用的转义序列如下:"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:517
#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:550
msgid "Escape Sequence"
msgstr "转义序列"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:517
#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:550
msgid "Meaning"
msgstr "含义"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:517
#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:550
msgid "Notes"
msgstr "注释"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:519
msgid "``\\newline``"
msgstr "``\\newline``"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:519
msgid "Backslash and newline ignored"
msgstr "反斜杠加换行全被忽略"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:521
msgid "``\\\\``"
msgstr "``\\\\``"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:521
msgid "Backslash (``\\``)"
msgstr "反斜杠 (``\\``)"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:523
msgid "``\\'``"
msgstr "``\\'``"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:523
msgid "Single quote (``'``)"
msgstr "单引号 (``'``)"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:525
msgid "``\\\"``"
msgstr "``\\\"``"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:525
msgid "Double quote (``\"``)"
msgstr "双引号 (``\"``)"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:527
msgid "``\\a``"
msgstr "``\\a``"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:527
msgid "ASCII Bell (BEL)"
msgstr "ASCII 响铃 (BEL)"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:529
msgid "``\\b``"
msgstr "``\\b``"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:529
msgid "ASCII Backspace (BS)"
msgstr "ASCII 退格 (BS)"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:531
msgid "``\\f``"
msgstr "``\\f``"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:531
msgid "ASCII Formfeed (FF)"
msgstr "ASCII 进纸 (FF)"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:533
msgid "``\\n``"
msgstr "``\\n``"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:533
msgid "ASCII Linefeed (LF)"
msgstr "ASCII 换行 (LF)"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:535
msgid "``\\r``"
msgstr "``\\r``"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:535
msgid "ASCII Carriage Return (CR)"
msgstr "ASCII 回车 (CR)"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:537
msgid "``\\t``"
msgstr "``\\t``"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:537
msgid "ASCII Horizontal Tab (TAB)"
msgstr "ASCII 水平制表 (TAB)"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:539
msgid "``\\v``"
msgstr "``\\v``"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:539
msgid "ASCII Vertical Tab (VT)"
msgstr "ASCII 垂直制表 (VT)"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:541
msgid "``\\ooo``"
msgstr "``\\ooo``"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:541
msgid "Character with octal value *ooo*"
msgstr "八进制数 *ooo* 码位的字符"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:541
msgid "(1,3)"
msgstr "(1,3)"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:544
msgid "``\\xhh``"
msgstr "``\\xhh``"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:544
msgid "Character with hex value *hh*"
msgstr "十六进制数 *hh* 码位的字符"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:544
msgid "(2,3)"
msgstr "(2,3)"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:547
msgid "Escape sequences only recognized in string literals are:"
msgstr "仅在字符串字面值中可用的转义序列如下:"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:552
msgid "``\\N{name}``"
msgstr "``\\N{name}``"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:552
msgid "Character named *name* in the Unicode database"
msgstr "Unicode 数据库中名称为 *name* 的字符"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:552
msgid "\\(4)"
msgstr "\\(4)"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:555
msgid "``\\uxxxx``"
msgstr "``\\uxxxx``"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:555
msgid "Character with 16-bit hex value *xxxx*"
msgstr "16位十六进制数 *xxxx* 码位的字符"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:555
msgid "\\(5)"
msgstr "\\(5)"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:558
msgid "``\\Uxxxxxxxx``"
msgstr "``\\Uxxxxxxxx``"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:558
msgid "Character with 32-bit hex value *xxxxxxxx*"
msgstr "32位16进制数 *xxxxxxxx* 码位的字符"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:558
msgid "\\(6)"
msgstr "\\(6)"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:562
msgid "Notes:"
msgstr "注释:"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:565
msgid "As in Standard C, up to three octal digits are accepted."
msgstr "与标准 C 一致，接受最多三个八进制数码。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:568
msgid "Unlike in Standard C, exactly two hex digits are required."
msgstr "与标准 C 不同，要求必须为两个十六进制数码。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:571
msgid ""
"In a bytes literal, hexadecimal and octal escapes denote the byte with the "
"given value. In a string literal, these escapes denote a Unicode character "
"with the given value."
msgstr "在字节串字面值中，十六进制数和八进制数转义码以相应数值代表每个字节。在字符串字面值中，这些转义码以相应数值代表每个 Unicode 字符。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:576
msgid "Support for name aliases [#]_ has been added."
msgstr "加入了对别名 [#]_ 的支持。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:580
msgid "Exactly four hex digits are required."
msgstr "要求必须为四个十六进制数码。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:583
msgid ""
"Any Unicode character can be encoded this way.  Exactly eight hex digits are"
" required."
msgstr "此方式可用来表示任意 Unicode 字符。要求必须为八个十六进制数码。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:589
msgid ""
"Unlike Standard C, all unrecognized escape sequences are left in the string "
"unchanged, i.e., *the backslash is left in the result*.  (This behavior is "
"useful when debugging: if an escape sequence is mistyped, the resulting "
"output is more easily recognized as broken.)  It is also important to note "
"that the escape sequences only recognized in string literals fall into the "
"category of unrecognized escapes for bytes literals."
msgstr ""
"与标准 C 不同，所有无法识别的转义序列将原样保留在字符串中，也就是说，*反斜杠会在结果中保留*。(这种方式在调试时很有用: "
"如果输错了一个转义序列，更容易在输出结果中识别错误。) "
"另外要注意的一个关键点是：专用于字符串字面值中的转义序列如果在字节串字面值中出现，会被归类为无法识别的转义序列。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:596
msgid ""
"Unrecognized escape sequences produce a DeprecationWarning.  In some future "
"version of Python they will be a SyntaxError."
msgstr "无法识别的转义序列会引发 DeprecationWarning。从未来某个 Python 版本开始将会引发 SyntaxError。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:600
msgid ""
"Even in a raw literal, quotes can be escaped with a backslash, but the "
"backslash remains in the result; for example, ``r\"\\\"\"`` is a valid "
"string literal consisting of two characters: a backslash and a double quote;"
" ``r\"\\\"`` is not a valid string literal (even a raw string cannot end in "
"an odd number of backslashes).  Specifically, *a raw literal cannot end in a"
" single backslash* (since the backslash would escape the following quote "
"character).  Note also that a single backslash followed by a newline is "
"interpreted as those two characters as part of the literal, *not* as a line "
"continuation."
msgstr ""
"即使在原始字面值中，引号也可以加上反斜杠转义符，但反斜杠会保留在输出结果中；例如 ``r\"\\\"\"`` 是一个有效的字符串字面值，包含两个字符: "
"一个反斜杠和一个双引号；而 ``r\"\\\"`` 不是一个有效的字符串字面值 "
"(即便是原始字符串也不能以奇数个反斜杠结束)。特别地，*一个原始字面值不能以单个反斜杠结束* "
"(因为此反斜杠会转义其后的引号字符)。还要注意一个反斜杠加一个换行在字面值中会被解释为两个字符，而 *不是* 一个连续行。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:613
msgid "String literal concatenation"
msgstr "字符串字面值拼接"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:615
msgid ""
"Multiple adjacent string or bytes literals (delimited by whitespace), "
"possibly using different quoting conventions, are allowed, and their meaning"
" is the same as their concatenation.  Thus, ``\"hello\" 'world'`` is "
"equivalent to ``\"helloworld\"``.  This feature can be used to reduce the "
"number of backslashes needed, to split long strings conveniently across long"
" lines, or even to add comments to parts of strings, for example::"
msgstr ""
"多个相邻的字符串或字节串字面值 (以空白符分隔)，所用的引号可以彼此不同，其含义等同于全部拼接为一体。因此， ``\"hello\" 'world'``"
" 等同于 "
"``\"helloworld\"``。此特性可以减少反斜杠的使用，以方便地将很长的字符串分成多个物理行，甚至每部分字符串还可分别加注释，例如::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:626
msgid ""
"Note that this feature is defined at the syntactical level, but implemented "
"at compile time.  The '+' operator must be used to concatenate string "
"expressions at run time.  Also note that literal concatenation can use "
"different quoting styles for each component (even mixing raw strings and "
"triple quoted strings), and formatted string literals may be concatenated "
"with plain string literals."
msgstr ""
"注意此特性是在句法层面定义的，但是在编译时实现。在运行时拼接字符串表达式必须使用 '+' 运算符。还要注意字面值拼接时每个部分可以使用不同的引号风格 "
"(甚至混合使用原始字符串和三引号字符串)，格式化字符串字面值也可与普通字符串字面值拼接。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:645
msgid "Formatted string literals"
msgstr "格式化字符串字面值"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:649
msgid ""
"A :dfn:`formatted string literal` or :dfn:`f-string` is a string literal "
"that is prefixed with ``'f'`` or ``'F'``.  These strings may contain "
"replacement fields, which are expressions delimited by curly braces ``{}``. "
"While other string literals always have a constant value, formatted strings "
"are really expressions evaluated at run time."
msgstr ""
":dfn:`格式化字符串字面值` 或称 :dfn:`f-string` 是带有 ``'f'`` 或 ``'F'`` "
"前缀的字符串字面值。这种字符串可包含替换字段，即以 ``{}`` "
"标示的表达式。而其他字符串字面值总是一个常量，格式化字符串字面值实际上是会在运行时被求值的表达式。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:655
msgid ""
"Escape sequences are decoded like in ordinary string literals (except when a"
" literal is also marked as a raw string).  After decoding, the grammar for "
"the contents of the string is:"
msgstr "转义序列会像在普通字符串字面值中一样被解码 (除非字面值还被标示为原始字符串)。解码之后，字符串内容所用的语法如下:"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:669
msgid ""
"The parts of the string outside curly braces are treated literally, except "
"that any doubled curly braces ``'{{'`` or ``'}}'`` are replaced with the "
"corresponding single curly brace.  A single opening curly bracket ``'{'`` "
"marks a replacement field, which starts with a Python expression.  After the"
" expression, there may be a conversion field, introduced by an exclamation "
"point ``'!'``.  A format specifier may also be appended, introduced by a "
"colon ``':'``.  A replacement field ends with a closing curly bracket "
"``'}'``."
msgstr ""
"字符串在花括号以外的部分按其字面值处理，除了双重花括号 ``'{{'`` 或 ``'}}'`` 会被替换为相应的单个花括号。单个左花括号 ``'{'``"
" 标示一个替换字段，它以一个 Python 表达式打头，表达式之后可能有一个以叹号 ``'!'`` 标示的转换字段。之后还可能带有一个以冒号 "
"``':'`` 标示的格式说明符。替换字段以一个右花括号 ``'}'`` 作为结束。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:678
msgid ""
"Expressions in formatted string literals are treated like regular Python "
"expressions surrounded by parentheses, with a few exceptions. An empty "
"expression is not allowed, and a :keyword:`lambda` expression must be "
"surrounded by explicit parentheses.  Replacement expressions can contain "
"line breaks (e.g. in triple-quoted strings), but they cannot contain "
"comments.  Each expression is evaluated in the context where the formatted "
"string literal appears, in order from left to right."
msgstr ""
"格式化字符串字面值中的表达式会被当作正常的包含在圆括号中的 Python "
"表达式一样处理，但有少数例外。空表达式不被允许，:keyword:`lambda` 表达式必须显式地加上圆括号。替换表达式可以包含换行 "
"(例如在三引号字符串中)，但是不能包含注释。每个表达式会在格式化字符串字面值所包含的位置按照从左至右的顺序被求值。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:686
msgid ""
"Prior to Python 3.7, an :keyword:`await` expression and comprehensions "
"containing an :keyword:`async for` clause were illegal in the expressions in"
" formatted string literals due to a problem with the implementation."
msgstr ""
"在 Python 3.7 之前， :keyword:`await` 表达式包含  :keyword:`async for` "
"子句的推导式不允许在格式化字符串字面值表达式中使用，这是因为具体实现存在一个问题。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:691
msgid ""
"If a conversion is specified, the result of evaluating the expression is "
"converted before formatting.  Conversion ``'!s'`` calls :func:`str` on the "
"result, ``'!r'`` calls :func:`repr`, and ``'!a'`` calls :func:`ascii`."
msgstr ""
"如果指定了转换符，表达式的求值结果会先转换再格式化。转换符 ``'!s'`` 即对结果调用 :func:`str`，``'!r'`` 为调用 "
":func:`repr`，而 ``'!a'`` 为调用 :func:`ascii`。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:695
msgid ""
"The result is then formatted using the :func:`format` protocol.  The format "
"specifier is passed to the :meth:`__format__` method of the expression or "
"conversion result.  An empty string is passed when the format specifier is "
"omitted.  The formatted result is then included in the final value of the "
"whole string."
msgstr ""
"在此之后结果会使用 :func:`format` 协议进行格式化。格式说明符会被传入表达式或转换结果的 :meth:`__format__` "
"方法。如果省略格式说明符则会传入一个空字符串。然后格式化结果会包含在整个字符串最终的值当中。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:701
msgid ""
"Top-level format specifiers may include nested replacement fields. These "
"nested fields may include their own conversion fields and :ref:`format "
"specifiers <formatspec>`, but may not include more deeply-nested replacement"
" fields. The :ref:`format specifier mini-language <formatspec>` is the same "
"as that used by the string .format() method."
msgstr ""
"顶层的格式说明符可以包含有嵌套的替换字段。这些嵌套字段也可以包含有自己的转换字段和 :ref:`格式说明符 "
"<formatspec>`，但不可再包含更深层嵌套的替换字段。这里的 :ref:`格式说明符微型语言 <formatspec>` 与字符串 "
".format() 方法所使用的相同。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:707
msgid ""
"Formatted string literals may be concatenated, but replacement fields cannot"
" be split across literals."
msgstr "格式化字符串字面值可以拼接，但是一个替换字段不能拆分到多个字面值。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:710
msgid "Some examples of formatted string literals::"
msgstr "一些格式化字符串字面值的示例::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:729
msgid ""
"A consequence of sharing the same syntax as regular string literals is that "
"characters in the replacement fields must not conflict with the quoting used"
" in the outer formatted string literal::"
msgstr "与正常字符串字面值采用相同语法导致的一个结果就是替换字段中的字符不能与外部的格式化字符串字面值所用的引号相冲突::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:736
msgid ""
"Backslashes are not allowed in format expressions and will raise an error::"
msgstr "格式表达式中不允许有反斜杠，这会引发错误::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:741
msgid ""
"To include a value in which a backslash escape is required, create a "
"temporary variable."
msgstr "想包含需要用反斜杠转义的值，可以创建一个临时变量。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:748
msgid ""
"Formatted string literals cannot be used as docstrings, even if they do not "
"include expressions."
msgstr "格式化字符串字面值不可用作文档字符串，即便其中没有包含表达式。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:759
msgid ""
"See also :pep:`498` for the proposal that added formatted string literals, "
"and :meth:`str.format`, which uses a related format string mechanism."
msgstr "另请参见 :pep:`498` 了解加入格式化字符串字面值的提议，以及使用了相关的格式字符串机制的 :meth:`str.format`。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:766
msgid "Numeric literals"
msgstr "数字字面值"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:772
msgid ""
"There are three types of numeric literals: integers, floating point numbers,"
" and imaginary numbers.  There are no complex literals (complex numbers can "
"be formed by adding a real number and an imaginary number)."
msgstr "数字字面值有三种类型: 整型数、浮点数和虚数。没有专门的复数字面值 (复数可由一个实数加一个虚数合成)。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:776
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is "
"actually an expression composed of the unary operator '``-``' and the "
"literal ``1``."
msgstr "注意数字字面值并不包含正负号；``-1`` 这样的负数实际上是由单目运算符 '``-``' 和字面值 ``1`` 合成的。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:790
msgid "Integer literals"
msgstr "整型数字面值"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:792
msgid "Integer literals are described by the following lexical definitions:"
msgstr "整型数字面值由以下词法定义进行描述:"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:806
msgid ""
"There is no limit for the length of integer literals apart from what can be "
"stored in available memory."
msgstr "整型数字面值的长度没有限制，能一直大到占满可用内存。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:809
msgid ""
"Underscores are ignored for determining the numeric value of the literal.  "
"They can be used to group digits for enhanced readability.  One underscore "
"can occur between digits, and after base specifiers like ``0x``."
msgstr ""
"在确定数字大小时字面值中的下划线会被忽略。它们可用来将数码分组以提高可读性。一个下划线可放在数码之间，也可放在基数说明符例如 ``0x`` 之后。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:813
msgid ""
"Note that leading zeros in a non-zero decimal number are not allowed. This "
"is for disambiguation with C-style octal literals, which Python used before "
"version 3.0."
msgstr "注意非零的十进制数开头不允许有额外的零。这是为了避免与 Python 在版本 3.0 之前所使用的 C 风格八进制字面值相混淆。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:817
msgid "Some examples of integer literals::"
msgstr "一些整型数字面值的示例如下::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:823
#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:855
msgid "Underscores are now allowed for grouping purposes in literals."
msgstr "允许在字面值中使用下划线进行分组。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:834
msgid "Floating point literals"
msgstr "浮点数字面值"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:836
msgid ""
"Floating point literals are described by the following lexical definitions:"
msgstr "浮点数字面值由以下词法定义进行描述:"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:846
msgid ""
"Note that the integer and exponent parts are always interpreted using radix "
"10. For example, ``077e010`` is legal, and denotes the same number as "
"``77e10``. The allowed range of floating point literals is implementation-"
"dependent.  As in integer literals, underscores are supported for digit "
"grouping."
msgstr ""
"注意整型数部分和指数部分在解析时总是以 10 为基数。例如，``077e010`` 是合法的，且表示的数值与 ``77e10`` "
"相同。浮点数字面值允许的范围依赖于具体实现。对于整型数字面值，支持以下划线进行分组。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:851
msgid "Some examples of floating point literals::"
msgstr "一些浮点数字面值的示例如下::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:864
msgid "Imaginary literals"
msgstr "虚数字面值"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:866
msgid "Imaginary literals are described by the following lexical definitions:"
msgstr "虚数字面值由以下词法定义进行描述:"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:871
msgid ""
"An imaginary literal yields a complex number with a real part of 0.0.  "
"Complex numbers are represented as a pair of floating point numbers and have"
" the same restrictions on their range.  To create a complex number with a "
"nonzero real part, add a floating point number to it, e.g., ``(3+4j)``.  "
"Some examples of imaginary literals::"
msgstr ""
"一个虚数字面值将生成一个实部为 0.0 的复数。复数是以一对浮点数来表示的，它们的取值范围相同。要创建一个实部不为零的复数，就加上一个浮点数，例如 "
"``(3+4j)``。一些虚数字面值的示例如下::"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:883
msgid "Operators"
msgstr "运算符"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:887
msgid "The following tokens are operators:"
msgstr "以下形符属于运算符:"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:900
msgid "Delimiters"
msgstr "分隔符"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:904
msgid "The following tokens serve as delimiters in the grammar:"
msgstr "以下形符在语法中归类为分隔符:"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:913
msgid ""
"The period can also occur in floating-point and imaginary literals.  A "
"sequence of three periods has a special meaning as an ellipsis literal. The "
"second half of the list, the augmented assignment operators, serve lexically"
" as delimiters, but also perform an operation."
msgstr ""
"句点也可出现于浮点数和虚数字面值中。连续三个句点有表示一个省略符的特殊含义。以上列表的后半部分为增强赋值操作符，在词法中作为分隔符，但也起到运算作用。"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:918
msgid ""
"The following printing ASCII characters have special meaning as part of "
"other tokens or are otherwise significant to the lexical analyzer:"
msgstr "以下可打印 ASCII 字符作为其他形符的组成部分时具有特殊含义，或是对词法分析器有重要意义:"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:925
msgid ""
"The following printing ASCII characters are not used in Python.  Their "
"occurrence outside string literals and comments is an unconditional error:"
msgstr "以下可打印 ASCII 字符不在 Python 词法中使用。如果出现于字符串字面值和注释之外将无条件地引发错误:"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:934
msgid "Footnotes"
msgstr "备注"

#: /home/runner/work/docspush-transifex/docspush-transifex/cpython/Doc/reference/lexical_analysis.rst:935
msgid "http://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt"
msgstr "http://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt"
