# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# ww song <sww4718168@gmail.com>, 2019
# eric R <trencyclopedia@gmail.com>, 2019
# df2dc1c92e792f7ae8417c51df43db8f_594d92a <0f49be28017426edb1db1a2ab6e67088_717605>, 2019
# chyroc chen <chyroc@qq.com>, 2019
# Freesand Leo <yuqinju@163.com>, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-06-16 16:41+0000\n"
"PO-Revision-Date: 2019-09-01 02:41+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2022\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/"
"teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:5
msgid "Modules"
msgstr "模块"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:7
msgid ""
"If you quit from the Python interpreter and enter it again, the definitions "
"you have made (functions and variables) are lost. Therefore, if you want to "
"write a somewhat longer program, you are better off using a text editor to "
"prepare the input for the interpreter and running it with that file as input "
"instead.  This is known as creating a *script*.  As your program gets "
"longer, you may want to split it into several files for easier maintenance.  "
"You may also want to use a handy function that you've written in several "
"programs without copying its definition into each program."
msgstr ""
"如果你从Python解释器退出并再次进入，之前的定义（函数和变量）都会丢失。因此，"
"如果你想编写一个稍长些的程序，最好使用文本编辑器为解释器准备输入并将该文件作"
"为输入运行。这被称作编写 *脚本* 。随着程序变得越来越长，你或许会想把它拆分成"
"几个文件，以方便维护。你亦或想在不同的程序中使用一个便捷的函数， 而不必把这个"
"函数复制到每一个程序中去。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:16
msgid ""
"To support this, Python has a way to put definitions in a file and use them "
"in a script or in an interactive instance of the interpreter. Such a file is "
"called a *module*; definitions from a module can be *imported* into other "
"modules or into the *main* module (the collection of variables that you have "
"access to in a script executed at the top level and in calculator mode)."
msgstr ""
"为支持这些，Python有一种方法可以把定义放在一个文件里，并在脚本或解释器的交互"
"式实例中使用它们。这样的文件被称作 *模块* ；模块中的定义可以 *导入* 到其它模"
"块或者 *主* 模块（你在顶级和计算器模式下执行的脚本中可以访问的变量集合）。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:22
msgid ""
"A module is a file containing Python definitions and statements.  The file "
"name is the module name with the suffix :file:`.py` appended.  Within a "
"module, the module's name (as a string) is available as the value of the "
"global variable ``__name__``.  For instance, use your favorite text editor "
"to create a file called :file:`fibo.py` in the current directory with the "
"following contents::"
msgstr ""
"模块是一个包含Python定义和语句的文件。文件名就是模块名后跟文件后缀 :file:`."
"py` 。在一个模块内部，模块名（作为一个字符串）可以通过全局变量 ``__name__`` "
"的值获得。例如，使用你最喜爱的文本编辑器在当前目录下创建一个名为 :file:`fibo."
"py` 的文件， 文件中含有以下内容::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:45
msgid ""
"Now enter the Python interpreter and import this module with the following "
"command::"
msgstr "现在进入Python解释器，并用以下命令导入该模块::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:50
msgid ""
"This does not enter the names of the functions defined in ``fibo``  directly "
"in the current symbol table; it only enters the module name ``fibo`` there. "
"Using the module name you can access the functions::"
msgstr ""
"在当前的符号表中，这并不会直接进入到定义在 ``fibo`` 函数内的名称；它只是进入"
"到模块名 ``fibo`` 中。你可以用模块名访问这些函数::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:61
msgid ""
"If you intend to use a function often you can assign it to a local name::"
msgstr "如果你想经常使用某个函数，你可以把它赋值给一个局部变量::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:71
msgid "More on Modules"
msgstr "更多有关模块的信息"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:73
msgid ""
"A module can contain executable statements as well as function definitions. "
"These statements are intended to initialize the module. They are executed "
"only the *first* time the module name is encountered in an import statement. "
"[#]_ (They are also run if the file is executed as a script.)"
msgstr ""
"模块可以包含可执行的语句以及函数定义。这些语句用于初始化模块。它们仅在模块 *"
"第一次* 在 import 语句中被导入时才执行。 [#]_ (当文件被当作脚本运行时，它们也"
"会执行。)"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:78
msgid ""
"Each module has its own private symbol table, which is used as the global "
"symbol table by all functions defined in the module. Thus, the author of a "
"module can use global variables in the module without worrying about "
"accidental clashes with a user's global variables. On the other hand, if you "
"know what you are doing you can touch a module's global variables with the "
"same notation used to refer to its functions, ``modname.itemname``."
msgstr ""
"每个模块都有它自己的私有符号表，该表用作模块中定义的所有函数的全局符号表。因"
"此，模块的作者可以在模块内使用全局变量，而不必担心与用户的全局变量发生意外冲"
"突。另一方面，如果你知道自己在做什么，则可以用跟访问模块内的函数的同样标记方"
"法，去访问一个模块的全局变量，``modname.itemname``。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:85
msgid ""
"Modules can import other modules.  It is customary but not required to place "
"all :keyword:`import` statements at the beginning of a module (or script, "
"for that matter).  The imported module names are placed in the importing "
"module's global symbol table."
msgstr ""
"可以把其他模块导入模块。 按惯例，所有 :keyword:`import` 语句都放在模块（或脚"
"本）开头，但这不是必须的。 被导入的模块名存在导入方模块的全局符号表里。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:90
msgid ""
"There is a variant of the :keyword:`import` statement that imports names "
"from a module directly into the importing module's symbol table.  For "
"example::"
msgstr ""
":keyword:`import` 语句有一个变体，它可以把名字从一个被调模块内直接导入到现模"
"块的符号表里。例如::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:97
msgid ""
"This does not introduce the module name from which the imports are taken in "
"the local symbol table (so in the example, ``fibo`` is not defined)."
msgstr ""
"这并不会把被调模块名引入到局部变量表里（因此在这个例子里，``fibo`` 是未被定义"
"的）。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:100
msgid "There is even a variant to import all names that a module defines::"
msgstr "还有一个变体甚至可以导入模块内定义的所有名称::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:106
msgid ""
"This imports all names except those beginning with an underscore (``_``). In "
"most cases Python programmers do not use this facility since it introduces "
"an unknown set of names into the interpreter, possibly hiding some things "
"you have already defined."
msgstr ""
"这会调入所有非以下划线（``_``）开头的名称。 在多数情况下，Python程序员都不会"
"使用这个功能，因为它在解释器中引入了一组未知的名称，而它们很可能会覆盖一些你"
"已经定义过的东西。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:111
msgid ""
"Note that in general the practice of importing ``*`` from a module or "
"package is frowned upon, since it often causes poorly readable code. "
"However, it is okay to use it to save typing in interactive sessions."
msgstr ""
"注意通常情况下从一个模块或者包内调入 ``*`` 的做法是不太被接受的， 因为这通常"
"会导致代码的可读性很差。不过，在交互式编译器中为了节省打字可以这么用。 "

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:115
msgid ""
"If the module name is followed by :keyword:`!as`, then the name following :"
"keyword:`!as` is bound directly to the imported module."
msgstr ""
"如果模块名称之后带有 :keyword:`!as`，则跟在 :keyword:`!as` 之后的名称将直接绑"
"定到所导入的模块。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:124
msgid ""
"This is effectively importing the module in the same way that ``import "
"fibo`` will do, with the only difference of it being available as ``fib``."
msgstr ""
"这会和 ``import fibo`` 方式一样有效地调入模块， 唯一的区别是它以 ``fib`` 的名"
"称存在的。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:127
msgid ""
"It can also be used when utilising :keyword:`from` with similar effects::"
msgstr "这种方式也可以在用到 :keyword:`from` 的时候使用，并会有类似的效果::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:136
msgid ""
"For efficiency reasons, each module is only imported once per interpreter "
"session.  Therefore, if you change your modules, you must restart the "
"interpreter -- or, if it's just one module you want to test interactively, "
"use :func:`importlib.reload`, e.g. ``import importlib; importlib."
"reload(modulename)``."
msgstr ""
"出于效率的考虑，每个模块在每个解释器会话中只被导入一次。因此，如果你更改了你"
"的模块，则必须重新启动解释器， 或者，如果它只是一个要交互式地测试的模块，请使"
"用 :func:`importlib.reload`，例如 ``import importlib; importlib."
"reload(modulename)``。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:146
msgid "Executing modules as scripts"
msgstr "以脚本的方式执行模块"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:148
msgid "When you run a Python module with ::"
msgstr "当你用下面方式运行一个Python模块::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:152
msgid ""
"the code in the module will be executed, just as if you imported it, but "
"with the ``__name__`` set to ``\"__main__\"``.  That means that by adding "
"this code at the end of your module::"
msgstr ""
"这项操作将执行模块里的代码，和导入模块一样，但会把 ``__name__`` 赋值为 "
"``\"__main__\"``。 也就是把下列代码添加到模块末尾："

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:160
msgid ""
"you can make the file usable as a script as well as an importable module, "
"because the code that parses the command line only runs if the module is "
"executed as the \"main\" file:"
msgstr ""
"你既可以把这个文件当作脚本又可当作一个可调入的模块来使用， 因为那段解析命令行"
"的代码只有在当模块是以“main”文件的方式执行的时候才会运行:"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:169
msgid "If the module is imported, the code is not run::"
msgstr "如果模块是被导入的，那些代码是不运行的::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:174
msgid ""
"This is often used either to provide a convenient user interface to a "
"module, or for testing purposes (running the module as a script executes a "
"test suite)."
msgstr ""
"这经常用于为模块提供一个方便的用户接口，或用于测试（以脚本的方式运行模块从而"
"执行一些测试套件）。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:181
msgid "The Module Search Path"
msgstr "模块搜索路径"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:185
msgid ""
"When a module named :mod:`spam` is imported, the interpreter first searches "
"for a built-in module with that name. If not found, it then searches for a "
"file named :file:`spam.py` in a list of directories given by the variable :"
"data:`sys.path`.  :data:`sys.path` is initialized from these locations:"
msgstr ""
"当一个名为 :mod:`spam` 的模块被导入的时候，解释器首先寻找具有该名称的内置模"
"块。如果没有找到，然后解释器从 :data:`sys.path` 变量给出的目录列表里寻找名"
"为 :file:`spam.py` 的文件。:data:`sys.path` 初始有这些目录地址:"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:190
msgid ""
"The directory containing the input script (or the current directory when no "
"file is specified)."
msgstr "包含输入脚本的目录（或者未指定文件时的当前目录）。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:192
msgid ""
":envvar:`PYTHONPATH` (a list of directory names, with the same syntax as the "
"shell variable :envvar:`PATH`)."
msgstr ""
":envvar:`PYTHONPATH` （一个包含目录名称的列表，它和shell变量 :envvar:`PATH` "
"有一样的语法）。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:194
msgid "The installation-dependent default."
msgstr "取决于安装的默认设置"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:197
msgid ""
"On file systems which support symlinks, the directory containing the input "
"script is calculated after the symlink is followed. In other words the "
"directory containing the symlink is **not** added to the module search path."
msgstr ""
"在支持符号链接的文件系统上，包含输入脚本的目录是在追加符号链接后才计算出来"
"的。换句话说，包含符号链接的目录并 **没有** 被添加到模块的搜索路径上。 "

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:201
msgid ""
"After initialization, Python programs can modify :data:`sys.path`.  The "
"directory containing the script being run is placed at the beginning of the "
"search path, ahead of the standard library path. This means that scripts in "
"that directory will be loaded instead of modules of the same name in the "
"library directory. This is an error unless the replacement is intended.  See "
"section :ref:`tut-standardmodules` for more information."
msgstr ""
"在初始化后，Python程序可以更改 :data:`sys.path`。包含正在运行脚本的文件目录被"
"放在搜索路径的开头处， 在标准库路径之前。这意味着将加载此目录里的脚本，而不是"
"标准库中的同名模块。 除非有意更换，否则这是错误。更多信息请参阅 :ref:`tut-"
"standardmodules`。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:212
msgid "\"Compiled\" Python files"
msgstr "“编译过的”Python文件"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:214
msgid ""
"To speed up loading modules, Python caches the compiled version of each "
"module in the ``__pycache__`` directory under the name :file:`module."
"{version}.pyc`, where the version encodes the format of the compiled file; "
"it generally contains the Python version number.  For example, in CPython "
"release 3.3 the compiled version of spam.py would be cached as ``__pycache__/"
"spam.cpython-33.pyc``.  This naming convention allows compiled modules from "
"different releases and different versions of Python to coexist."
msgstr ""
"为了加速模块载入，Python在 ``__pycache__`` 目录里缓存了每个模块的编译后版本，"
"名称为 :file:`module.{version}.pyc` ，其中名称中的版本字段对编译文件的格式进"
"行编码； 它一般使用Python版本号。例如，在CPython版本3.3中，spam.py的编译版本"
"将被缓存为 ``__pycache__/spam.cpython-33.pyc``。此命名约定允许来自不同发行版"
"和不同版本的Python的已编译模块共存。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:222
msgid ""
"Python checks the modification date of the source against the compiled "
"version to see if it's out of date and needs to be recompiled.  This is a "
"completely automatic process.  Also, the compiled modules are platform-"
"independent, so the same library can be shared among systems with different "
"architectures."
msgstr ""
"Python根据编译版本检查源的修改日期，以查看它是否已过期并需要重新编译。这是一"
"个完全自动化的过程。此外，编译的模块与平台无关，因此可以在具有不同体系结构的"
"系统之间共享相同的库。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:227
msgid ""
"Python does not check the cache in two circumstances.  First, it always "
"recompiles and does not store the result for the module that's loaded "
"directly from the command line.  Second, it does not check the cache if "
"there is no source module.  To support a non-source (compiled only) "
"distribution, the compiled module must be in the source directory, and there "
"must not be a source module."
msgstr ""
"Python在两种情况下不会检查缓存。首先，对于从命令行直接载入的模块，它从来都是"
"重新编译并且不存储编译结果；其次，如果没有源模块，它不会检查缓存。为了支持无"
"源文件（仅编译）发行版本， 编译模块必须是在源目录下，并且绝对不能有源模块。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:234
msgid "Some tips for experts:"
msgstr "给专业人士的一些小建议:"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:236
msgid ""
"You can use the :option:`-O` or :option:`-OO` switches on the Python command "
"to reduce the size of a compiled module.  The ``-O`` switch removes assert "
"statements, the ``-OO`` switch removes both assert statements and __doc__ "
"strings.  Since some programs may rely on having these available, you should "
"only use this option if you know what you're doing.  \"Optimized\" modules "
"have an ``opt-`` tag and are usually smaller.  Future releases may change "
"the effects of optimization."
msgstr ""
"你可以在Python命令中使用 :option:`-O` 或者 :option:`-OO` 开关， 以减小编译后"
"模块的大小。 ``-O`` 开关去除断言语句，``-OO`` 开关同时去除断言语句和 __doc__ "
"字符串。由于有些程序可能依赖于这些，你应当只在清楚自己在做什么时才使用这个选"
"项。“优化过的”模块有一个 ``opt-`` 标签并且通常小些。将来的发行版本或许会更改"
"优化的效果。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:244
msgid ""
"A program doesn't run any faster when it is read from a ``.pyc`` file than "
"when it is read from a ``.py`` file; the only thing that's faster about ``."
"pyc`` files is the speed with which they are loaded."
msgstr ""
"一个从 ``.pyc`` 文件读出的程序并不会比它从 ``.py`` 读出时运行的更快，``."
"pyc`` 文件唯一快的地方在于载入速度。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:248
msgid ""
"The module :mod:`compileall` can create .pyc files for all modules in a "
"directory."
msgstr ":mod:`compileall` 模块可以为一个目录下的所有模块创建.pyc文件。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:251
msgid ""
"There is more detail on this process, including a flow chart of the "
"decisions, in :pep:`3147`."
msgstr "关于这个过程，:pep:`3147` 中有更多细节，包括一个决策流程图。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:258
msgid "Standard Modules"
msgstr "标准模块"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:262
msgid ""
"Python comes with a library of standard modules, described in a separate "
"document, the Python Library Reference (\"Library Reference\" hereafter).  "
"Some modules are built into the interpreter; these provide access to "
"operations that are not part of the core of the language but are "
"nevertheless built in, either for efficiency or to provide access to "
"operating system primitives such as system calls.  The set of such modules "
"is a configuration option which also depends on the underlying platform.  "
"For example, the :mod:`winreg` module is only provided on Windows systems. "
"One particular module deserves some attention: :mod:`sys`, which is built "
"into every Python interpreter.  The variables ``sys.ps1`` and ``sys.ps2`` "
"define the strings used as primary and secondary prompts::"
msgstr ""
"Python附带了一个标准模块库，在单独的文档Python库参考（以下称为“库参考”）中进"
"行了描述。一些模块内置于解释器中；它们提供对不属于语言核心但仍然内置的操作的"
"访问，以提高效率或提供对系统调用等操作系统原语的访问。这些模块的集合是一个配"
"置选项，它也取决于底层平台。例如，:mod:`winreg` 模块只在Windows操作系统上提"
"供。一个特别值得注意的模块 :mod:`sys`，它被内嵌到每一个Python解释器中。变量 "
"``sys.ps1`` 和 ``sys.ps2`` 定义用作主要和辅助提示的字符串::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:285
msgid ""
"These two variables are only defined if the interpreter is in interactive "
"mode."
msgstr "这两个变量只有在编译器是交互模式下才被定义。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:287
msgid ""
"The variable ``sys.path`` is a list of strings that determines the "
"interpreter's search path for modules. It is initialized to a default path "
"taken from the environment variable :envvar:`PYTHONPATH`, or from a built-in "
"default if :envvar:`PYTHONPATH` is not set.  You can modify it using "
"standard list operations::"
msgstr ""
"``sys.path`` 变量是一个字符串列表，用于确定解释器的模块搜索路径。该变量被初始"
"化为从环境变量 :envvar:`PYTHONPATH` 获取的默认路径，或者如果 :envvar:"
"`PYTHONPATH` 未设置，则从内置默认路径初始化。你可以使用标准列表操作对其进行修"
"改::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:300
msgid "The :func:`dir` Function"
msgstr ":func:`dir` 函数"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:302
msgid ""
"The built-in function :func:`dir` is used to find out which names a module "
"defines.  It returns a sorted list of strings::"
msgstr ""
"内置函数 :func:`dir` 用于查找模块定义的名称。 它返回一个排序过的字符串列表::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:327
msgid ""
"Without arguments, :func:`dir` lists the names you have defined currently::"
msgstr "如果没有参数，:func:`dir` 会列出你当前定义的名称::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:335
msgid ""
"Note that it lists all types of names: variables, modules, functions, etc."
msgstr "注意：它列出所有类型的名称：变量，模块，函数，等等。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:339
msgid ""
":func:`dir` does not list the names of built-in functions and variables.  If "
"you want a list of those, they are defined in the standard module :mod:"
"`builtins`::"
msgstr ""
":func:`dir` 不会列出内置函数和变量的名称。如果你想要这些，它们的定义是在标准"
"模块 :mod:`builtins` 中::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:378
msgid "Packages"
msgstr "包"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:380
msgid ""
"Packages are a way of structuring Python's module namespace by using "
"\"dotted module names\".  For example, the module name :mod:`A.B` designates "
"a submodule named ``B`` in a package named ``A``.  Just like the use of "
"modules saves the authors of different modules from having to worry about "
"each other's global variable names, the use of dotted module names saves the "
"authors of multi-module packages like NumPy or Pillow from having to worry "
"about each other's module names."
msgstr ""
"包是一种通过用“带点号的模块名”来构造 Python 模块命名空间的方法。 例如，模块"
"名 :mod:`A.B` 表示 ``A`` 包中名为 ``B`` 的子模块。正如模块的使用使得不同模块"
"的作者不必担心彼此的全局变量名称一样，使用加点的模块名可以使得 NumPy 或 "
"Pillow 等多模块软件包的作者不必担心彼此的模块名称一样。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:388
msgid ""
"Suppose you want to design a collection of modules (a \"package\") for the "
"uniform handling of sound files and sound data.  There are many different "
"sound file formats (usually recognized by their extension, for example: :"
"file:`.wav`, :file:`.aiff`, :file:`.au`), so you may need to create and "
"maintain a growing collection of modules for the conversion between the "
"various file formats. There are also many different operations you might "
"want to perform on sound data (such as mixing, adding echo, applying an "
"equalizer function, creating an artificial stereo effect), so in addition "
"you will be writing a never-ending stream of modules to perform these "
"operations.  Here's a possible structure for your package (expressed in "
"terms of a hierarchical filesystem):"
msgstr ""
"假设你想为声音文件和声音数据的统一处理，设计一个模块集合（一个“包”）。由于存"
"在很多不同的声音文件格式（通常由它们的扩展名来识别，例如：:file:`.wav`， :"
"file:`.aiff`， :file:`.au`），因此为了不同文件格式间的转换，你可能需要创建和"
"维护一个不断增长的模块集合。 你可能还想对声音数据还做很多不同的处理（例如，混"
"声，添加回声，使用均衡器功能，创造人工立体声效果）， 因此为了实现这些处理，你"
"将另外写一个无穷尽的模块流。这是你的包的可能结构（以分层文件系统的形式表"
"示）："

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:425
msgid ""
"When importing the package, Python searches through the directories on ``sys."
"path`` looking for the package subdirectory."
msgstr "当导入这个包时，Python搜索 ``sys.path`` 里的目录，查找包的子目录。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:428
msgid ""
"The :file:`__init__.py` files are required to make Python treat directories "
"containing the file as packages.  This prevents directories with a common "
"name, such as ``string``, unintentionally hiding valid modules that occur "
"later on the module search path. In the simplest case, :file:`__init__.py` "
"can just be an empty file, but it can also execute initialization code for "
"the package or set the ``__all__`` variable, described later."
msgstr ""
"必须要有 :file:`__init__.py` 文件才能让 Python 将包含该文件的目录当作包。 这"
"样可以防止具有通常名称例如 ``string`` 的目录在无意中隐藏稍后在模块搜索路径上"
"出现的有效模块。 在最简单的情况下，:file:`__init__.py` 可以只是一个空文件，但"
"它也可以执行包的初始化代码或设置 ``__all__`` 变量，具体将在后文介绍。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:435
msgid ""
"Users of the package can import individual modules from the package, for "
"example::"
msgstr "包的用户可以从包中导入单个模块，例如::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:440
msgid ""
"This loads the submodule :mod:`sound.effects.echo`.  It must be referenced "
"with its full name. ::"
msgstr ""
"这会加载子模块 :mod:`sound.effects.echo` 。但引用它时必须使用它的全名。 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:445
msgid "An alternative way of importing the submodule is::"
msgstr "导入子模块的另一种方法是 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:449
msgid ""
"This also loads the submodule :mod:`echo`, and makes it available without "
"its package prefix, so it can be used as follows::"
msgstr ""
"这也会加载子模块 :mod:`echo` ，并使其在没有包前缀的情况下可用，因此可以按如下"
"方式使用::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:454
msgid ""
"Yet another variation is to import the desired function or variable "
"directly::"
msgstr "另一种形式是直接导入所需的函数或变量::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:458
msgid ""
"Again, this loads the submodule :mod:`echo`, but this makes its function :"
"func:`echofilter` directly available::"
msgstr ""
"同样，这也会加载子模块 :mod:`echo`，但这会使其函数 :func:`echofilter` 直接可"
"用::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:463
msgid ""
"Note that when using ``from package import item``, the item can be either a "
"submodule (or subpackage) of the package, or some  other name defined in the "
"package, like a function, class or variable.  The ``import`` statement first "
"tests whether the item is defined in the package; if not, it assumes it is a "
"module and attempts to load it.  If it fails to find it, an :exc:"
"`ImportError` exception is raised."
msgstr ""
"请注意，当使用 ``from package import item`` 时，item可以是包的子模块（或子"
"包），也可以是包中定义的其他名称，如函数，类或变量。 ``import`` 语句首先测试"
"是否在包中定义了item；如果没有，它假定它是一个模块并尝试加载它。如果找不到"
"它，则引发 :exc:`ImportError` 异常。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:470
msgid ""
"Contrarily, when using syntax like ``import item.subitem.subsubitem``, each "
"item except for the last must be a package; the last item can be a module or "
"a package but can't be a class or function or variable defined in the "
"previous item."
msgstr ""
"相反，当使用 ``import item.subitem.subsubitem`` 这样的语法时，除了最后一项之"
"外的每一项都必须是一个包；最后一项可以是模块或包，但不能是前一项中定义的类或"
"函数或变量。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:479
msgid "Importing \\* From a Package"
msgstr "从包中导入 \\*"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:483
msgid ""
"Now what happens when the user writes ``from sound.effects import *``?  "
"Ideally, one would hope that this somehow goes out to the filesystem, finds "
"which submodules are present in the package, and imports them all.  This "
"could take a long time and importing sub-modules might have unwanted side-"
"effects that should only happen when the sub-module is explicitly imported."
msgstr ""
"当用户写 ``from sound.effects import *`` 会发生什么？理想情况下，人们希望这会"
"以某种方式传递给文件系统，找到包中存在哪些子模块，并将它们全部导入。这可能需"
"要很长时间，导入子模块可能会产生不必要的副作用，这种副作用只有在显式导入子模"
"块时才会发生。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:489
msgid ""
"The only solution is for the package author to provide an explicit index of "
"the package.  The :keyword:`import` statement uses the following convention: "
"if a package's :file:`__init__.py` code defines a list named ``__all__``, it "
"is taken to be the list of module names that should be imported when ``from "
"package import *`` is encountered.  It is up to the package author to keep "
"this list up-to-date when a new version of the package is released.  Package "
"authors may also decide not to support it, if they don't see a use for "
"importing \\* from their package.  For example, the file :file:`sound/"
"effects/__init__.py` could contain the following code::"
msgstr ""
"唯一的解决方案是让包作者提供一个包的显式索引。:keyword:`import` 语句使用下面"
"的规范：如果一个包的 :file:`__init__.py` 代码定义了一个名为 ``__all__`` 的列"
"表，它会被视为在遇到 ``from package import *`` 时应该导入的模块名列表。在发布"
"该包的新版本时，包作者可以决定是否让此列表保持更新。包作者如果认为从他们的包"
"中导入 \\* 的操作没有必要被使用，也可以决定不支持此列表。例如，文件 :file:"
"`sound/effects/__init__.py` 可以包含以下代码::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:501
msgid ""
"This would mean that ``from sound.effects import *`` would import the three "
"named submodules of the :mod:`sound` package."
msgstr ""
"这意味着 ``from sound.effects import *`` 将导入 :mod:`sound` 包的三个命名子模"
"块。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:504
msgid ""
"If ``__all__`` is not defined, the statement ``from sound.effects import *`` "
"does *not* import all submodules from the package :mod:`sound.effects` into "
"the current namespace; it only ensures that the package :mod:`sound.effects` "
"has been imported (possibly running any initialization code in :file:"
"`__init__.py`) and then imports whatever names are defined in the package.  "
"This includes any names defined (and submodules explicitly loaded) by :file:"
"`__init__.py`.  It also includes any submodules of the package that were "
"explicitly loaded by previous :keyword:`import` statements.  Consider this "
"code::"
msgstr ""
"如果没有定义 ``__all__``，``from sound.effects import *`` 语句 *不会* 从包 :"
"mod:`sound.effects` 中导入所有子模块到当前命名空间；它只确保导入了包 :mod:"
"`sound.effects` （可能运行任何在 :file:`__init__.py` 中的初始化代码），然后导"
"入包中定义的任何名称。 这包括 :file:`__init__.py` 定义的任何名称（以及显式加"
"载的子模块）。它还包括由之前的 :keyword:`import` 语句显式加载的包的任何子模"
"块。思考下面的代码::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:517
msgid ""
"In this example, the :mod:`echo` and :mod:`surround` modules are imported in "
"the current namespace because they are defined in the :mod:`sound.effects` "
"package when the ``from...import`` statement is executed.  (This also works "
"when ``__all__`` is defined.)"
msgstr ""
"在这个例子中， :mod:`echo` 和 :mod:`surround` 模块是在执行 ``from...import`` "
"语句时导入到当前命名空间中的，因为它们定义在 :mod:`sound.effects` 包中。（这"
"在定义了 ``__all__`` 时也有效。）"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:522
msgid ""
"Although certain modules are designed to export only names that follow "
"certain patterns when you use ``import *``, it is still considered bad "
"practice in production code."
msgstr ""
"虽然某些模块被设计为在使用 ``import *`` 时只导出遵循某些模式的名称，但在生产"
"代码中它仍然被认为是不好的做法。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:526
msgid ""
"Remember, there is nothing wrong with using ``from package import "
"specific_submodule``!  In fact, this is the recommended notation unless the "
"importing module needs to use submodules with the same name from different "
"packages."
msgstr ""
"请记住，使用 ``from package import specific_submodule`` 没有任何问题！ 实际"
"上，除非导入的模块需要使用来自不同包的同名子模块，否则这是推荐的表示法。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:533
msgid "Intra-package References"
msgstr "子包参考"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:535
msgid ""
"When packages are structured into subpackages (as with the :mod:`sound` "
"package in the example), you can use absolute imports to refer to submodules "
"of siblings packages.  For example, if the module :mod:`sound.filters."
"vocoder` needs to use the :mod:`echo` module in the :mod:`sound.effects` "
"package, it can use ``from sound.effects import echo``."
msgstr ""
"当包被构造成子包时（与示例中的 :mod:`sound` 包一样），你可以使用绝对导入来引"
"用兄弟包的子模块。例如，如果模块 :mod:`sound.filters.vocoder` 需要在 :mod:"
"`sound.effects` 包中使用 :mod:`echo` 模块，它可以使用 ``from sound.effects "
"import echo`` 。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:541
msgid ""
"You can also write relative imports, with the ``from module import name`` "
"form of import statement.  These imports use leading dots to indicate the "
"current and parent packages involved in the relative import.  From the :mod:"
"`surround` module for example, you might use::"
msgstr ""
"你还可以使用import语句的 ``from module import name`` 形式编写相对导入。这些导"
"入使用前导点来指示相对导入中涉及的当前包和父包。例如，从 :mod:`surround` 模"
"块，你可以使用::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:550
msgid ""
"Note that relative imports are based on the name of the current module.  "
"Since the name of the main module is always ``\"__main__\"``, modules "
"intended for use as the main module of a Python application must always use "
"absolute imports."
msgstr ""
"请注意，相对导入是基于当前模块的名称进行导入的。由于主模块的名称总是 "
"``\"__main__\"`` ，因此用作Python应用程序主模块的模块必须始终使用绝对导入。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:556
msgid "Packages in Multiple Directories"
msgstr "多个目录中的包"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:558
msgid ""
"Packages support one more special attribute, :attr:`__path__`.  This is "
"initialized to be a list containing the name of the directory holding the "
"package's :file:`__init__.py` before the code in that file is executed.  "
"This variable can be modified; doing so affects future searches for modules "
"and subpackages contained in the package."
msgstr ""
"包支持另一个特殊属性， :attr:`__path__` 。它被初始化为一个列表，其中包含在执"
"行该文件中的代码之前保存包的文件 :file:`__init__.py` 的目录的名称。这个变量可"
"以修改；这样做会影响将来对包中包含的模块和子包的搜索。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:564
msgid ""
"While this feature is not often needed, it can be used to extend the set of "
"modules found in a package."
msgstr "虽然通常不需要此功能，但它可用于扩展程序包中的模块集。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:569
msgid "Footnotes"
msgstr "备注"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/modules.rst:570
msgid ""
"In fact function definitions are also 'statements' that are 'executed'; the "
"execution of a module-level function definition enters the function name in "
"the module's global symbol table."
msgstr ""
"实际上，函数定义也是“被执行”的“语句”；模块级函数定义的执行在模块的全局符号表"
"中输入该函数名。"
