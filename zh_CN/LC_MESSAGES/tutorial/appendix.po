# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Rafael Fontenelle <rffontenelle@gmail.com>, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.10\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-06-23 15:19+0000\n"
"PO-Revision-Date: 2022-11-05 17:23+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2022\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/"
"teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../tutorial/appendix.rst:5
msgid "Appendix"
msgstr "附录"

#: ../../tutorial/appendix.rst:11
msgid "Interactive Mode"
msgstr "交互模式"

#: ../../tutorial/appendix.rst:16
msgid "Error Handling"
msgstr "错误处理"

#: ../../tutorial/appendix.rst:18
msgid ""
"When an error occurs, the interpreter prints an error message and a stack "
"trace. In interactive mode, it then returns to the primary prompt; when "
"input came from a file, it exits with a nonzero exit status after printing "
"the stack trace. (Exceptions handled by an :keyword:`except` clause in a :"
"keyword:`try` statement are not errors in this context.)  Some errors are "
"unconditionally fatal and cause an exit with a nonzero exit; this applies to "
"internal inconsistencies and some cases of running out of memory.  All error "
"messages are written to the standard error stream; normal output from "
"executed commands is written to standard output."
msgstr ""
"当发生错误时，解释器会打印错误信息和错误堆栈。在交互模式下，将返回到主命令提"
"示符；如果输入内容来自文件，在打印错误堆栈之后，程序会以非零状态退出。（这里"
"所说的错误不包括 :keyword:`try` 语句中由 :keyword:`except` 所捕获的异常。）有"
"些错误是无条件致命的，会导致程序以非零状态退出；比如内部逻辑矛盾或内存耗尽。"
"所有错误信息都会被写入标准错误流；而命令的正常输出则被写入标准输出流。"

#: ../../tutorial/appendix.rst:28
msgid ""
"Typing the interrupt character (usually :kbd:`Control-C` or :kbd:`Delete`) "
"to the primary or secondary prompt cancels the input and returns to the "
"primary prompt. [#]_ Typing an interrupt while a command is executing raises "
"the :exc:`KeyboardInterrupt` exception, which may be handled by a :keyword:"
"`try` statement."
msgstr ""
"将中断字符（通常为 :kbd:`Control-C` 或 :kbd:`Delete` ）键入主要或辅助提示会取"
"消输入并返回主提示符。 [#]_ 在执行命令时键入中断引发的 :exc:"
"`KeyboardInterrupt` 异常，可以由 :keyword:`try` 语句处理。"

#: ../../tutorial/appendix.rst:38
msgid "Executable Python Scripts"
msgstr "可执行的Python脚本"

#: ../../tutorial/appendix.rst:40
msgid ""
"On BSD'ish Unix systems, Python scripts can be made directly executable, "
"like shell scripts, by putting the line ::"
msgstr ""
"在BSD等类Unix系统上，Python脚本可以直接执行，就像shell脚本一样，第一行添加::"

#: ../../tutorial/appendix.rst:45
msgid ""
"(assuming that the interpreter is on the user's :envvar:`PATH`) at the "
"beginning of the script and giving the file an executable mode.  The ``#!`` "
"must be the first two characters of the file.  On some platforms, this first "
"line must end with a Unix-style line ending (``'\\n'``), not a Windows "
"(``'\\r\\n'``) line ending.  Note that the hash, or pound, character, "
"``'#'``, is used to start a comment in Python."
msgstr ""
"（假设解释器位于用户的 :envvar:`PATH` ）脚本的开头，并将文件设置为可执行。 "
"``#!`` 必须是文件的前两个字符。在某些平台上，第一行必须以Unix样式的行结尾"
"（``'\\n'``）结束，而不是以Windows（``'\\r\\n'``）行结尾。请注意，散列或磅字"
"符 ``'#'`` 在Python中代表注释开始。"

#: ../../tutorial/appendix.rst:52
msgid ""
"The script can be given an executable mode, or permission, using the :"
"program:`chmod` command."
msgstr "可以使用 :program:`chmod` 命令为脚本提供可执行模式或权限。"

#: ../../tutorial/appendix.rst:59
msgid ""
"On Windows systems, there is no notion of an \"executable mode\".  The "
"Python installer automatically associates ``.py`` files with ``python.exe`` "
"so that a double-click on a Python file will run it as a script.  The "
"extension can also be ``.pyw``, in that case, the console window that "
"normally appears is suppressed."
msgstr ""
"在Windows系统上，没有“可执行模式”的概念。 Python安装程序自动将 ``.py`` 文件"
"与 ``python.exe`` 相关联，这样双击Python文件就会将其作为脚本运行。扩展也可以"
"是 ``.pyw`` ，在这种情况下，会隐藏通常出现的控制台窗口。"

#: ../../tutorial/appendix.rst:69
msgid "The Interactive Startup File"
msgstr "交互式启动文件"

#: ../../tutorial/appendix.rst:71
msgid ""
"When you use Python interactively, it is frequently handy to have some "
"standard commands executed every time the interpreter is started.  You can "
"do this by setting an environment variable named :envvar:`PYTHONSTARTUP` to "
"the name of a file containing your start-up commands.  This is similar to "
"the :file:`.profile` feature of the Unix shells."
msgstr ""
"当您以交互方式使用Python时，每次启动解释器时都会执行一些标准命令，这通常很方"
"便。您可以通过将名为 :envvar:`PYTHONSTARTUP` 的环境变量设置为包含启动命令的文"
"件名来实现。这类似于Unix shell的 :file:`.profile` 功能。"

#: ../../tutorial/appendix.rst:77
msgid ""
"This file is only read in interactive sessions, not when Python reads "
"commands from a script, and not when :file:`/dev/tty` is given as the "
"explicit source of commands (which otherwise behaves like an interactive "
"session).  It is executed in the same namespace where interactive commands "
"are executed, so that objects that it defines or imports can be used without "
"qualification in the interactive session. You can also change the prompts "
"``sys.ps1`` and ``sys.ps2`` in this file."
msgstr ""
"此文件只会在交互式会话时读取，而非在 Python 从脚本读取指令或是在给定 :file:`/"
"dev/tty` 为指令的明确来源时（后者反而表现得像是一个交互式会话）。 该文件执行"
"时所在的命名空间与交互式指令相同，所以它定义或导入的对象可以在交互式会话中直"
"接使用。 你也可以在该文件中更改提示符 ``sys.ps1`` 和 ``sys.ps2``。"

#: ../../tutorial/appendix.rst:85
msgid ""
"If you want to read an additional start-up file from the current directory, "
"you can program this in the global start-up file using code like ``if os."
"path.isfile('.pythonrc.py'): exec(open('.pythonrc.py').read())``. If you "
"want to use the startup file in a script, you must do this explicitly in the "
"script::"
msgstr ""
"如果你想从当前目录中读取一个额外的启动文件，你可以使用像 ``if os.path."
"isfile('.pythonrc.py'): exec(open('.pythonrc.py').read())`` 这样的代码在全局"
"启动文件中对它进行编程。如果要在脚本中使用启动文件，则必须在脚本中显式执行此"
"操作::"

#: ../../tutorial/appendix.rst:102
msgid "The Customization Modules"
msgstr "定制模块"

#: ../../tutorial/appendix.rst:104
msgid ""
"Python provides two hooks to let you customize it: :mod:`sitecustomize` and :"
"mod:`usercustomize`.  To see how it works, you need first to find the "
"location of your user site-packages directory.  Start Python and run this "
"code::"
msgstr ""
"Python提供了两个钩子来让你自定义它：:mod:`sitecustomize` 和 :mod:"
"`usercustomize`。要查看其工作原理，首先需要找到用户site-packages目录的位置。"
"启动Python并运行此代码::"

#: ../../tutorial/appendix.rst:112
msgid ""
"Now you can create a file named :file:`usercustomize.py` in that directory "
"and put anything you want in it.  It will affect every invocation of Python, "
"unless it is started with the :option:`-s` option to disable the automatic "
"import."
msgstr ""
"现在，您可以在该目录中创建一个名为 :file:`usercustomize.py` 的文件，并将所需"
"内容放入其中。它会影响Python的每次启动，除非它以 :option:`-s` 选项启动，以禁"
"用自动导入。"

#: ../../tutorial/appendix.rst:116
msgid ""
":mod:`sitecustomize` works in the same way, but is typically created by an "
"administrator of the computer in the global site-packages directory, and is "
"imported before :mod:`usercustomize`.  See the documentation of the :mod:"
"`site` module for more details."
msgstr ""
":mod:`sitecustomize` 以相同的方式工作，但通常由计算机管理员在全局 site-"
"packages 目录中创建，并在 :mod:`usercustomize` 之前被导入。有关详情请参阅 :"
"mod:`site` 模块的文档。"

#: ../../tutorial/appendix.rst:123
msgid "Footnotes"
msgstr "备注"

#: ../../tutorial/appendix.rst:124
msgid "A problem with the GNU Readline package may prevent this."
msgstr "GNU Readline 包的问题可能会阻止这种情况。"
