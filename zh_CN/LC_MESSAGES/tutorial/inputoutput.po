# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Shengjing Zhu <zsj950618@gmail.com>, 2020
# cissoid <yangtukun1412@gmail.com>, 2020
# df2dc1c92e792f7ae8417c51df43db8f_594d92a <0f49be28017426edb1db1a2ab6e67088_717605>, 2020
# Freesand Leo <yuqinju@163.com>, 2020
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-06-23 16:32+0000\n"
"PO-Revision-Date: 2020-05-30 12:16+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2020\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/"
"teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../tutorial/inputoutput.rst:5
msgid "Input and Output"
msgstr "输入输出"

#: ../../tutorial/inputoutput.rst:7
msgid ""
"There are several ways to present the output of a program; data can be "
"printed in a human-readable form, or written to a file for future use. This "
"chapter will discuss some of the possibilities."
msgstr ""
"有几种方法可以显示程序的输出；数据可以以人类可读的形式打印出来，或者写入文件"
"以供将来使用。本章将讨论一些可能性。"

#: ../../tutorial/inputoutput.rst:15
msgid "Fancier Output Formatting"
msgstr "更漂亮的输出格式"

#: ../../tutorial/inputoutput.rst:17
msgid ""
"So far we've encountered two ways of writing values: *expression statements* "
"and the :func:`print` function.  (A third way is using the :meth:`write` "
"method of file objects; the standard output file can be referenced as ``sys."
"stdout``. See the Library Reference for more information on this.)"
msgstr ""
"到目前为止，我们遇到了两种写入值的方法：*表达式语句* 和 :func:`print` 函数。"
"（第三种是使用文件对象的 :meth:`write` 方法；标准输出文件可以作为 ``sys."
"stdout`` 引用。更多相关信息可参考标准库指南。）"

#: ../../tutorial/inputoutput.rst:22
msgid ""
"Often you'll want more control over the formatting of your output than "
"simply printing space-separated values. There are several ways to format "
"output."
msgstr ""
"通常，你需要更多地控制输出的格式，而不仅仅是打印空格分隔的值。有几种格式化输"
"出的方法。"

#: ../../tutorial/inputoutput.rst:25
msgid ""
"To use :ref:`formatted string literals <tut-f-strings>`, begin a string with "
"``f`` or ``F`` before the opening quotation mark or triple quotation mark. "
"Inside this string, you can write a Python expression between ``{`` and ``}"
"`` characters that can refer to variables or literal values."
msgstr ""
"要使用 :ref:`格式化字符串字面值 <tut-f-strings>` ，请在字符串的开始引号或三引"
"号之前加上一个 ``f`` 或 ``F`` 。在此字符串中，你可以在 ``{`` 和 ``}`` 字符之"
"间写可以引用的变量或字面值的 Python 表达式。"

#: ../../tutorial/inputoutput.rst:37
msgid ""
"The :meth:`str.format` method of strings requires more manual effort.  "
"You'll still use ``{`` and ``}`` to mark where a variable will be "
"substituted and can provide detailed formatting directives, but you'll also "
"need to provide the information to be formatted."
msgstr ""
"字符串的 :meth:`str.format` 方法需要更多的手动操作。你仍将使用 ``{`` 和 ``}"
"`` 来标记变量将被替换的位置，并且可以提供详细的格式化指令，但你还需要提供要格"
"式化的信息。"

#: ../../tutorial/inputoutput.rst:50
msgid ""
"Finally, you can do all the string handling yourself by using string slicing "
"and concatenation operations to create any layout you can imagine.  The "
"string type has some methods that perform useful operations for padding "
"strings to a given column width."
msgstr ""
"最后，你可以使用字符串切片和连接操作自己完成所有的字符串处理，以创建你可以想"
"象的任何布局。字符串类型有一些方法可以执行将字符串填充到给定列宽的有用操作。"

#: ../../tutorial/inputoutput.rst:55
msgid ""
"When you don't need fancy output but just want a quick display of some "
"variables for debugging purposes, you can convert any value to a string with "
"the :func:`repr` or :func:`str` functions."
msgstr ""
"当你不需要花哨的输出而只是想快速显示某些变量以进行调试时，可以使用 :func:"
"`repr` or :func:`str` 函数将任何值转化为字符串。"

#: ../../tutorial/inputoutput.rst:59
msgid ""
"The :func:`str` function is meant to return representations of values which "
"are fairly human-readable, while :func:`repr` is meant to generate "
"representations which can be read by the interpreter (or will force a :exc:"
"`SyntaxError` if there is no equivalent syntax).  For objects which don't "
"have a particular representation for human consumption, :func:`str` will "
"return the same value as :func:`repr`.  Many values, such as numbers or "
"structures like lists and dictionaries, have the same representation using "
"either function.  Strings, in particular, have two distinct representations."
msgstr ""
":func:`str` 函数是用于返回人类可读的值的表示，而 :func:`repr` 是用于生成解释"
"器可读的表示（如果没有等效的语法，则会强制执行 :exc:`SyntaxError`）对于没有人"
"类可读性的表示的对象， :func:`str` 将返回和 :func:`repr` 一样的值。很多值使用"
"任一函数都具有相同的表示，比如数字或类似列表和字典的结构。特殊的是字符串有两"
"个不同的表示。"

#: ../../tutorial/inputoutput.rst:68
msgid "Some examples::"
msgstr "几个例子::"

#: ../../tutorial/inputoutput.rst:91
msgid ""
"The :mod:`string` module contains a :class:`~string.Template` class that "
"offers yet another way to substitute values into strings, using placeholders "
"like ``$x`` and replacing them with values from a dictionary, but offers "
"much less control of the formatting."
msgstr ""
":mod:`string` 模块包含一个 :class:`~string.Template` 类，它提供了另一种将值替"
"换为字符串的方法，使用类似 ``$x`` 的占位符并用字典中的值替换它们，但对格式的"
"控制要少的多。"

#: ../../tutorial/inputoutput.rst:100
msgid "Formatted String Literals"
msgstr "格式化字符串文字"

#: ../../tutorial/inputoutput.rst:102
msgid ""
":ref:`Formatted string literals <f-strings>` (also called f-strings for "
"short) let you include the value of Python expressions inside a string by "
"prefixing the string with ``f`` or ``F`` and writing expressions as "
"``{expression}``."
msgstr ""
":ref:`格式化字符串字面值 <f-strings>` （常简称为 f-字符串）能让你在字符串前加"
"上 ``f`` 和 ``F`` 并将表达式写成 ``{expression}`` 来在字符串中包含 Python 表"
"达式的值。"

#: ../../tutorial/inputoutput.rst:107
msgid ""
"An optional format specifier can follow the expression. This allows greater "
"control over how the value is formatted. The following example rounds pi to "
"three places after the decimal::"
msgstr ""
"可选的格式说明符可以跟在表达式后面。这样可以更好地控制值的格式化方式。以下示"
"例将pi舍入到小数点后三位::"

#: ../../tutorial/inputoutput.rst:115
msgid ""
"Passing an integer after the ``':'`` will cause that field to be a minimum "
"number of characters wide.  This is useful for making columns line up. ::"
msgstr ""
"在 ``':'`` 后传递一个整数可以让该字段成为最小字符宽度。这在使列对齐时很有"
"用。::"

#: ../../tutorial/inputoutput.rst:126
msgid ""
"Other modifiers can be used to convert the value before it is formatted. ``'!"
"a'`` applies :func:`ascii`, ``'!s'`` applies :func:`str`, and ``'!r'`` "
"applies :func:`repr`::"
msgstr ""
"其他的修饰符可用于在格式化之前转化值。 ``'!a'`` 应用 :func:`ascii` ，``'!"
"s'`` 应用 :func:`str`，还有 ``'!r'`` 应用 :func:`repr`::"

#: ../../tutorial/inputoutput.rst:136
msgid ""
"For a reference on these format specifications, see the reference guide for "
"the :ref:`formatspec`."
msgstr "有关这些格式规范的参考，请参阅参考指南 :ref:`formatspec`。"

#: ../../tutorial/inputoutput.rst:142
msgid "The String format() Method"
msgstr "字符串的 format() 方法"

#: ../../tutorial/inputoutput.rst:144
msgid "Basic usage of the :meth:`str.format` method looks like this::"
msgstr ":meth:`str.format` 方法的基本用法如下所示::"

#: ../../tutorial/inputoutput.rst:149
msgid ""
"The brackets and characters within them (called format fields) are replaced "
"with the objects passed into the :meth:`str.format` method.  A number in the "
"brackets can be used to refer to the position of the object passed into the :"
"meth:`str.format` method. ::"
msgstr ""
"花括号和其中的字符（称为格式字段）将替换为传递给 :meth:`str.format` 方法的对"
"象。花括号中的数字可用来表示传递给 :meth:`str.format` 方法的对象的位置。"

#: ../../tutorial/inputoutput.rst:159
msgid ""
"If keyword arguments are used in the :meth:`str.format` method, their values "
"are referred to by using the name of the argument. ::"
msgstr ""
"如果在 :meth:`str.format` 方法中使用关键字参数，则使用参数的名称引用它们的"
"值。::"

#: ../../tutorial/inputoutput.rst:166
msgid "Positional and keyword arguments can be arbitrarily combined::"
msgstr "位置和关键字参数可以任意组合::"

#: ../../tutorial/inputoutput.rst:172
msgid ""
"If you have a really long format string that you don't want to split up, it "
"would be nice if you could reference the variables to be formatted by name "
"instead of by position.  This can be done by simply passing the dict and "
"using square brackets ``'[]'`` to access the keys. ::"
msgstr ""
"如果你有一个非常长的格式字符串，你不想把它拆开，那么你最好是按名称而不是按位"
"置引用变量来进行格式化。 这可以通过简单地传递字典并使用方括号 ``'[]'`` 访问键"
"来完成。 ::"

#: ../../tutorial/inputoutput.rst:182
msgid ""
"This could also be done by passing the table as keyword arguments with the "
"'**' notation. ::"
msgstr "这也可以通过使用 '**' 符号将 table 作为关键字参数传递。"

#: ../../tutorial/inputoutput.rst:189
msgid ""
"This is particularly useful in combination with the built-in function :func:"
"`vars`, which returns a dictionary containing all local variables."
msgstr ""
"这在与内置函数 :func:`vars` 结合使用时非常有用，它会返回包含所有局部变量的字"
"典。"

#: ../../tutorial/inputoutput.rst:192
msgid ""
"As an example, the following lines produce a tidily-aligned set of columns "
"giving integers and their squares and cubes::"
msgstr ""
"例如，下面几行代码生成一组整齐的列，其中包含给定的整数和它的平方以及立方::"

#: ../../tutorial/inputoutput.rst:209
msgid ""
"For a complete overview of string formatting with :meth:`str.format`, see :"
"ref:`formatstrings`."
msgstr ""
"关于使用 :meth:`str.format` 进行字符串格式化的完整概述，请参阅 :ref:"
"`formatstrings` 。"

#: ../../tutorial/inputoutput.rst:214
msgid "Manual String Formatting"
msgstr "手动格式化字符串"

#: ../../tutorial/inputoutput.rst:216
msgid "Here's the same table of squares and cubes, formatted manually::"
msgstr "这是同一个平方和立方的表，手动格式化的::"

#: ../../tutorial/inputoutput.rst:234
msgid ""
"(Note that the one space between each column was added by the way :func:"
"`print` works: it always adds spaces between its arguments.)"
msgstr ""
"（注意每列之间的一个空格是通过使用 :func:`print` 的方式添加的：它总是在其参数"
"间添加空格。）"

#: ../../tutorial/inputoutput.rst:237
msgid ""
"The :meth:`str.rjust` method of string objects right-justifies a string in a "
"field of a given width by padding it with spaces on the left. There are "
"similar methods :meth:`str.ljust` and :meth:`str.center`. These methods do "
"not write anything, they just return a new string. If the input string is "
"too long, they don't truncate it, but return it unchanged; this will mess up "
"your column lay-out but that's usually better than the alternative, which "
"would be lying about a value. (If you really want truncation you can always "
"add a slice operation, as in ``x.ljust(n)[:n]``.)"
msgstr ""
"字符串对象的 :meth:`str.rjust` 方法通过在左侧填充空格来对给定宽度的字段中的字"
"符串进行右对齐。类似的方法还有 :meth:`str.ljust` 和 :meth:`str.center` 。这些"
"方法不会写入任何东西，它们只是返回一个新的字符串，如果输入的字符串太长，它们"
"不会截断字符串，而是原样返回；这虽然会弄乱你的列布局，但这通常比另一种方法"
"好，后者会在显示值时可能不准确（如果你真的想截断，你可以添加一个切片操作，例"
"如 ``x.ljust(n)[:n]`` 。）"

#: ../../tutorial/inputoutput.rst:246
msgid ""
"There is another method, :meth:`str.zfill`, which pads a numeric string on "
"the left with zeros.  It understands about plus and minus signs::"
msgstr ""
"还有另外一个方法，:meth:`str.zfill` ，它会在数字字符串的左边填充零。它能识别"
"正负号::"

#: ../../tutorial/inputoutput.rst:258
msgid "Old string formatting"
msgstr "旧的字符串格式化方法"

#: ../../tutorial/inputoutput.rst:260
msgid ""
"The % operator (modulo) can also be used for string formatting. Given "
"``'string' % values``, instances of ``%`` in ``string`` are replaced with "
"zero or more elements of ``values``. This operation is commonly known as "
"string interpolation. For example::"
msgstr ""
"% 运算符（求余）也可用于字符串格式化。 给定 ``'string' % values``，则 "
"``string`` 中的 ``%`` 实例会以零个或多个 ``values`` 元素替换。 此操作通常被称"
"为字符串插值。 例如::"

#: ../../tutorial/inputoutput.rst:269
msgid ""
"More information can be found in the :ref:`old-string-formatting` section."
msgstr "可在 :ref:`old-string-formatting` 部分找到更多信息。"

#: ../../tutorial/inputoutput.rst:275
msgid "Reading and Writing Files"
msgstr "读写文件"

#: ../../tutorial/inputoutput.rst:281
msgid ""
":func:`open` returns a :term:`file object`, and is most commonly used with "
"two arguments: ``open(filename, mode)``."
msgstr ""
":func:`open` 返回一个 :term:`file object`，最常用的有两个参数： "
"``open(filename, mode)``。"

#: ../../tutorial/inputoutput.rst:293
msgid ""
"The first argument is a string containing the filename.  The second argument "
"is another string containing a few characters describing the way in which "
"the file will be used.  *mode* can be ``'r'`` when the file will only be "
"read, ``'w'`` for only writing (an existing file with the same name will be "
"erased), and ``'a'`` opens the file for appending; any data written to the "
"file is automatically added to the end.  ``'r+'`` opens the file for both "
"reading and writing. The *mode* argument is optional; ``'r'`` will be "
"assumed if it's omitted."
msgstr ""
"第一个参数是包含文件名的字符串。第二个参数是另一个字符串，其中包含一些描述文"
"件使用方式的字符。*mode* 可以是 ``'r'`` ，表示文件只能读取，``'w'`` 表示只能"
"写入（已存在的同名文件会被删除），还有 ``'a'`` 表示打开文件以追加内容；任何写"
"入的数据会自动添加到文件的末尾。``'r+'`` 表示打开文件进行读写。*mode* 参数是"
"可选的；省略时默认为 ``'r'``。"

#: ../../tutorial/inputoutput.rst:302
msgid ""
"Normally, files are opened in :dfn:`text mode`, that means, you read and "
"write strings from and to the file, which are encoded in a specific "
"encoding. If encoding is not specified, the default is platform dependent "
"(see :func:`open`). ``'b'`` appended to the mode opens the file in :dfn:"
"`binary mode`: now the data is read and written in the form of bytes "
"objects.  This mode should be used for all files that don't contain text."
msgstr ""
"通常文件是以 :dfn:`text mode` 打开的，这意味着从文件中读取或写入字符串时，都"
"会以指定的编码方式进行编码。如果未指定编码格式，默认值与平台相关 (参见 :func:"
"`open`)。在mode 中追加的 ``'b'`` 则以 :dfn:`binary mode` 打开文件：现在数据是"
"以字节对象的形式进行读写的。这个模式应该用于所有不包含文本的文件。"

#: ../../tutorial/inputoutput.rst:309
msgid ""
"In text mode, the default when reading is to convert platform-specific line "
"endings (``\\n`` on Unix, ``\\r\\n`` on Windows) to just ``\\n``.  When "
"writing in text mode, the default is to convert occurrences of ``\\n`` back "
"to platform-specific line endings.  This behind-the-scenes modification to "
"file data is fine for text files, but will corrupt binary data like that in :"
"file:`JPEG` or :file:`EXE` files.  Be very careful to use binary mode when "
"reading and writing such files."
msgstr ""
"在文本模式下读取时，默认会把平台特定的行结束符 (Unix 上的 ``\\n``, Windows 上"
"的 ``\\r\\n``) 转换为 ``\\n``。在文本模式下写入时，默认会把出现的 ``\\n`` 转"
"换回平台特定的结束符。这样在幕后修改文件数据对文本文件来说没有问题，但是会破"
"坏二进制数据例如 :file:`JPEG` 或 :file:`EXE` 文件中的数据。请一定要注意在读写"
"此类文件时应使用二进制模式。"

#: ../../tutorial/inputoutput.rst:317
msgid ""
"It is good practice to use the :keyword:`with` keyword when dealing with "
"file objects.  The advantage is that the file is properly closed after its "
"suite finishes, even if an exception is raised at some point.  Using :"
"keyword:`!with` is also much shorter than writing equivalent :keyword:"
"`try`\\ -\\ :keyword:`finally` blocks::"
msgstr ""
"在处理文件对象时，最好使用 :keyword:`with` 关键字。 优点是当子句体结束后文件"
"会正确关闭，即使在某个时刻引发了异常。 而且使用 :keyword:`!with` 相比等效的 :"
"keyword:`try`\\ -\\ :keyword:`finally` 代码块要简短得多::"

#: ../../tutorial/inputoutput.rst:330
msgid ""
"If you're not using the :keyword:`with` keyword, then you should call ``f."
"close()`` to close the file and immediately free up any system resources "
"used by it."
msgstr ""
"如果你没有使用 :keyword:`with` 关键字，则你应当调用 ``f.close()`` 来关闭文件"
"并立即释放它所使用的任何系统资源。"

#: ../../tutorial/inputoutput.rst:335
msgid ""
"Calling ``f.write()`` without using the :keyword:`!with` keyword or calling "
"``f.close()`` **might** result in the arguments of ``f.write()`` not being "
"completely written to the disk, even if the program exits successfully."
msgstr ""
"调用 ``f.write()`` 时未使用 :keyword:`!with` 关键字或未调用 ``f.close()`` **"
"可能** 导致 ``f.write()`` 的参数没有完全写入到磁盘，即使程序是正常退出的。"

#: ../../tutorial/inputoutput.rst:343
msgid ""
"After a file object is closed, either by a :keyword:`with` statement or by "
"calling ``f.close()``, attempts to use the file object will automatically "
"fail. ::"
msgstr ""
"通过 :keyword:`with` 语句或者调用 ``f.close()`` 关闭文件对象后，尝试使用该文"
"件对象将自动失败。::"

#: ../../tutorial/inputoutput.rst:357
msgid "Methods of File Objects"
msgstr "文件对象的方法"

#: ../../tutorial/inputoutput.rst:359
msgid ""
"The rest of the examples in this section will assume that a file object "
"called ``f`` has already been created."
msgstr "本节中剩下的例子将假定你已创建名为 ``f`` 的文件对象。"

#: ../../tutorial/inputoutput.rst:362
msgid ""
"To read a file's contents, call ``f.read(size)``, which reads some quantity "
"of data and returns it as a string (in text mode) or bytes object (in binary "
"mode). *size* is an optional numeric argument.  When *size* is omitted or "
"negative, the entire contents of the file will be read and returned; it's "
"your problem if the file is twice as large as your machine's memory. "
"Otherwise, at most *size* characters (in text mode) or *size* bytes (in "
"binary mode) are read and returned. If the end of the file has been reached, "
"``f.read()`` will return an empty string (``''``).  ::"
msgstr ""
"要读取文件内容，请调用 ``f.read(size)``，它会读取一些数据并将其作为字符串（在"
"文本模式下）或字节串对象（在二进制模式下）返回。 *size* 是一个可选的数值参"
"数。 当 *size* 被省略或者为负数时，将读取并返回整个文件的内容；如果文件的大小"
"是你的机器内存的两倍就会出现问题。 当取其他值时，将读取并返回至多 *size* 个字"
"符（在文本模式下）或 *size* 个字节（在二进制模式下）。 如果已到达文件末尾，"
"``f.read()`` 将返回一个空字符串 (``''``)。 ::"

#: ../../tutorial/inputoutput.rst:376
msgid ""
"``f.readline()`` reads a single line from the file; a newline character "
"(``\\n``) is left at the end of the string, and is only omitted on the last "
"line of the file if the file doesn't end in a newline.  This makes the "
"return value unambiguous; if ``f.readline()`` returns an empty string, the "
"end of the file has been reached, while a blank line is represented by "
"``'\\n'``, a string containing only a single newline.  ::"
msgstr ""
"``f.readline()`` 从文件中读取一行；换行符（``\\n``）留在字符串的末尾，如果文"
"件不以换行符结尾，则在文件的最后一行省略。这使得返回值明确无误；如果 ``f."
"readline()`` 返回一个空的字符串，则表示已经到达了文件末尾，而空行使用 "
"``'\\n'`` 表示，该字符串只包含一个换行符。::"

#: ../../tutorial/inputoutput.rst:390
msgid ""
"For reading lines from a file, you can loop over the file object. This is "
"memory efficient, fast, and leads to simple code::"
msgstr ""
"要从文件中读取行，你可以循环遍历文件对象。这是内存高效，快速的，并简化代码::"

#: ../../tutorial/inputoutput.rst:399
msgid ""
"If you want to read all the lines of a file in a list you can also use "
"``list(f)`` or ``f.readlines()``."
msgstr ""
"如果你想以列表的形式读取文件中的所有行，你也可以使用 ``list(f)`` 或 ``f."
"readlines()``。"

#: ../../tutorial/inputoutput.rst:402
msgid ""
"``f.write(string)`` writes the contents of *string* to the file, returning "
"the number of characters written. ::"
msgstr ""
"``f.write(string)`` 会把 *string* 的内容写入到文件中，并返回写入的字符数。::"

#: ../../tutorial/inputoutput.rst:408
msgid ""
"Other types of objects need to be converted -- either to a string (in text "
"mode) or a bytes object (in binary mode) -- before writing them::"
msgstr ""
"在写入其他类型的对象之前，需要先把它们转化为字符串（在文本模式下）或者字节对"
"象（在二进制模式下）::"

#: ../../tutorial/inputoutput.rst:416
msgid ""
"``f.tell()`` returns an integer giving the file object's current position in "
"the file represented as number of bytes from the beginning of the file when "
"in binary mode and an opaque number when in text mode."
msgstr ""
"``f.tell()`` 返回一个整数，给出文件对象在文件中的当前位置，表示为二进制模式下"
"时从文件开始的字节数，以及文本模式下的意义不明的数字。"

#: ../../tutorial/inputoutput.rst:420
msgid ""
"To change the file object's position, use ``f.seek(offset, whence)``.  The "
"position is computed from adding *offset* to a reference point; the "
"reference point is selected by the *whence* argument.  A *whence* value of 0 "
"measures from the beginning of the file, 1 uses the current file position, "
"and 2 uses the end of the file as the reference point.  *whence* can be "
"omitted and defaults to 0, using the beginning of the file as the reference "
"point. ::"
msgstr ""
"要改变文件对象的位置，请使用 ``f.seek(offset, whence)``。 通过向一个参考点添"
"加 *offset* 来计算位置；参考点由 *whence* 参数指定。 *whence* 的 0 值表示从文"
"件开头起算，1 表示使用当前文件位置，2 表示使用文件末尾作为参考点。 *whence* "
"如果省略则默认值为 0，即使用文件开头作为参考点。 ::"

#: ../../tutorial/inputoutput.rst:439
msgid ""
"In text files (those opened without a ``b`` in the mode string), only seeks "
"relative to the beginning of the file are allowed (the exception being "
"seeking to the very file end with ``seek(0, 2)``) and the only valid "
"*offset* values are those returned from the ``f.tell()``, or zero. Any other "
"*offset* value produces undefined behaviour."
msgstr ""
"在文本文件（那些在模式字符串中没有 ``b`` 的打开的文件）中，只允许相对于文件开"
"头搜索（使用 ``seek(0, 2)`` 搜索到文件末尾是个例外）并且唯一有效的 *offset* "
"值是那些能从 ``f.tell()`` 中返回的或者是零。其他 *offset* 值都会产生未定义的"
"行为。"

#: ../../tutorial/inputoutput.rst:445
msgid ""
"File objects have some additional methods, such as :meth:`~file.isatty` and :"
"meth:`~file.truncate` which are less frequently used; consult the Library "
"Reference for a complete guide to file objects."
msgstr ""
"文件对象有一些额外的方法，例如 :meth:`~file.isatty` 和 :meth:`~file."
"truncate` ，它们使用频率较低；有关文件对象的完整指南请参阅库参考。"

#: ../../tutorial/inputoutput.rst:453
msgid "Saving structured data with :mod:`json`"
msgstr "使用 :mod:`json` 保存结构化数据"

#: ../../tutorial/inputoutput.rst:457
msgid ""
"Strings can easily be written to and read from a file.  Numbers take a bit "
"more effort, since the :meth:`read` method only returns strings, which will "
"have to be passed to a function like :func:`int`, which takes a string like "
"``'123'`` and returns its numeric value 123.  When you want to save more "
"complex data types like nested lists and dictionaries, parsing and "
"serializing by hand becomes complicated."
msgstr ""
"字符串可以很轻松地写入文件并从文件中读取出来。数字可能会费点劲，因为 :meth:"
"`read` 方法只能返回字符串，这些字符串必须传递给类似 :func:`int` 的函数，它会"
"接受类似 ``'123'`` 这样的字符串并返回其数字值 123。当你想保存诸如嵌套列表和字"
"典这样更复杂的数据类型时，手动解析和序列化会变得复杂。"

#: ../../tutorial/inputoutput.rst:464
msgid ""
"Rather than having users constantly writing and debugging code to save "
"complicated data types to files, Python allows you to use the popular data "
"interchange format called `JSON (JavaScript Object Notation) <http://json."
"org>`_.  The standard module called :mod:`json` can take Python data "
"hierarchies, and convert them to string representations; this process is "
"called :dfn:`serializing`.  Reconstructing the data from the string "
"representation is called :dfn:`deserializing`.  Between serializing and "
"deserializing, the string representing the object may have been stored in a "
"file or data, or sent over a network connection to some distant machine."
msgstr ""
"Python 允许你使用称为  `JSON (JavaScript Object Notation) <http://json."
"org>`_ 的流行数据交换格式，而不是让用户不断的编写和调试代码以将复杂的数据类型"
"保存到文件中。名为 :mod:`json` 的标准模块可以采用 Python 数据层次结构，并将它"
"们转化为字符串表示形式；这个过程称为 :dfn:`serializing` 。从字符串表示中重建"
"数据称为 :dfn:`deserializing` 。在序列化和反序列化之间，表示对象的字符串可能"
"已存储在文件或数据中，或通过网络连接发送到某个远程机器。"

#: ../../tutorial/inputoutput.rst:475
msgid ""
"The JSON format is commonly used by modern applications to allow for data "
"exchange.  Many programmers are already familiar with it, which makes it a "
"good choice for interoperability."
msgstr ""
"JSON格式通常被现代应用程序用于允许数据交换。许多程序员已经熟悉它，这使其成为"
"互操作性的良好选择。"

#: ../../tutorial/inputoutput.rst:479
msgid ""
"If you have an object ``x``, you can view its JSON string representation "
"with a simple line of code::"
msgstr ""
"如果你有一个对象 ``x`` ，你可以用一行简单的代码来查看它的 JSON 字符串表示::"

#: ../../tutorial/inputoutput.rst:486
msgid ""
"Another variant of the :func:`~json.dumps` function, called :func:`~json."
"dump`, simply serializes the object to a :term:`text file`.  So if ``f`` is "
"a :term:`text file` object opened for writing, we can do this::"
msgstr ""
":func:`~json.dumps` 函数的另一个变体叫做 :func:`~json.dump` ，它只是将对象序"
"列化为 :term:`text file` 。因此，如果 ``f`` 是一个 :term:`text file` 对象，我"
"们可以这样做::"

#: ../../tutorial/inputoutput.rst:492
msgid ""
"To decode the object again, if ``f`` is a :term:`text file` object which has "
"been opened for reading::"
msgstr ""
"要再次解码对象，如果 ``f`` 是一个打开的以供阅读的 :term:`text file` 对象::"

#: ../../tutorial/inputoutput.rst:497
msgid ""
"This simple serialization technique can handle lists and dictionaries, but "
"serializing arbitrary class instances in JSON requires a bit of extra "
"effort. The reference for the :mod:`json` module contains an explanation of "
"this."
msgstr ""
"这种简单的序列化技术可以处理列表和字典，但是在JSON中序列化任意类的实例需要额"
"外的努力。 :mod:`json` 模块的参考包含对此的解释。"

#: ../../tutorial/inputoutput.rst:503
msgid ":mod:`pickle` - the pickle module"
msgstr ":mod:`pickle` - 封存模块"

#: ../../tutorial/inputoutput.rst:505
msgid ""
"Contrary to :ref:`JSON <tut-json>`, *pickle* is a protocol which allows the "
"serialization of arbitrarily complex Python objects.  As such, it is "
"specific to Python and cannot be used to communicate with applications "
"written in other languages.  It is also insecure by default: deserializing "
"pickle data coming from an untrusted source can execute arbitrary code, if "
"the data was crafted by a skilled attacker."
msgstr ""
"与 :ref:`JSON <tut-json>` 不同，*pickle* 是一种允许对任意复杂 Python 对象进行"
"序列化的协议。因此，它为 Python 所特有，不能用于与其他语言编写的应用程序通"
"信。默认情况下它也是不安全的：如果数据是由熟练的攻击者精心设计的，则反序列化"
"来自不受信任来源的 pickle 数据可以执行任意代码。"
