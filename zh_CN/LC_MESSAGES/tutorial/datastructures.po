# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# eric R <trencyclopedia@gmail.com>, 2019
# Woko <banbooliu@gmail.com>, 2019
# df2dc1c92e792f7ae8417c51df43db8f_594d92a <0f49be28017426edb1db1a2ab6e67088_717605>, 2019
# Konge <zkonge@outlook.com>, 2019
# Henry Zhu <zhuhe212@163.com>, 2019
# Shengjing Zhu <zsj950618@gmail.com>, 2019
# Freesand Leo <yuqinju@163.com>, 2021
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-06-16 16:41+0000\n"
"PO-Revision-Date: 2019-09-01 02:41+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2021\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/"
"teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:5
msgid "Data Structures"
msgstr "数据结构"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:7
msgid ""
"This chapter describes some things you've learned about already in more "
"detail, and adds some new things as well."
msgstr "本章节将详细介绍一些您已经了解的内容，并添加了一些新内容。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:13
msgid "More on Lists"
msgstr "列表的更多特性"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:15
msgid ""
"The list data type has some more methods.  Here are all of the methods of "
"list objects:"
msgstr "列表数据类型还有很多的方法。这里是列表对象方法的清单："

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:22
msgid ""
"Add an item to the end of the list.  Equivalent to ``a[len(a):] = [x]``."
msgstr "在列表的末尾添加一个元素。相当于 ``a[len(a):] = [x]`` 。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:28
msgid ""
"Extend the list by appending all the items from the iterable.  Equivalent to "
"``a[len(a):] = iterable``."
msgstr ""
"使用可迭代对象中的所有元素来扩展列表。相当于  ``a[len(a):] = iterable`` 。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:35
msgid ""
"Insert an item at a given position.  The first argument is the index of the "
"element before which to insert, so ``a.insert(0, x)`` inserts at the front "
"of the list, and ``a.insert(len(a), x)`` is equivalent to ``a.append(x)``."
msgstr ""
"在给定的位置插入一个元素。第一个参数是要插入的元素的索引，所以 ``a.insert(0, "
"x)`` 插入列表头部， ``a.insert(len(a), x)`` 等同于 ``a.append(x)`` 。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:43
msgid ""
"Remove the first item from the list whose value is equal to *x*.  It raises "
"a :exc:`ValueError` if there is no such item."
msgstr ""
"移除列表中第一个值为 *x* 的元素。如果没有这样的元素，则抛出 :exc:"
"`ValueError` 异常。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:50
msgid ""
"Remove the item at the given position in the list, and return it.  If no "
"index is specified, ``a.pop()`` removes and returns the last item in the "
"list.  (The square brackets around the *i* in the method signature denote "
"that the parameter is optional, not that you should type square brackets at "
"that position.  You will see this notation frequently in the Python Library "
"Reference.)"
msgstr ""
"删除列表中给定位置的元素并返回它。如果没有给定位置，``a.pop()`` 将会删除并返"
"回列表中的最后一个元素。（ 方法签名中 *i* 两边的方括号表示这个参数是可选的，"
"而不是要你输入方括号。你会在 Python 参考库中经常看到这种表示方法)。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:60
msgid "Remove all items from the list.  Equivalent to ``del a[:]``."
msgstr "移除列表中的所有元素。等价于``del a[:]``"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:66
msgid ""
"Return zero-based index in the list of the first item whose value is equal "
"to *x*. Raises a :exc:`ValueError` if there is no such item."
msgstr ""
"返回列表中第一个值为 *x* 的元素的从零开始的索引。如果没有这样的元素将会抛出 :"
"exc:`ValueError` 异常。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:69
msgid ""
"The optional arguments *start* and *end* are interpreted as in the slice "
"notation and are used to limit the search to a particular subsequence of the "
"list.  The returned index is computed relative to the beginning of the full "
"sequence rather than the *start* argument."
msgstr ""
"可选参数 *start* 和 *end* 是切片符号，用于将搜索限制为列表的特定子序列。返回"
"的索引是相对于整个序列的开始计算的，而不是 *start* 参数。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:78
msgid "Return the number of times *x* appears in the list."
msgstr "返回元素 *x* 在列表中出现的次数。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:84
msgid ""
"Sort the items of the list in place (the arguments can be used for sort "
"customization, see :func:`sorted` for their explanation)."
msgstr ""
"对列表中的元素进行排序（参数可用于自定义排序，解释请参见 :func:`sorted`）。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:91
msgid "Reverse the elements of the list in place."
msgstr "翻转列表中的元素。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:97
msgid "Return a shallow copy of the list.  Equivalent to ``a[:]``."
msgstr "返回列表的一个浅拷贝，等价于 ``a[:]``。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:100
msgid "An example that uses most of the list methods::"
msgstr "多数列表方法示例："

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:123
msgid ""
"You might have noticed that methods like ``insert``, ``remove`` or ``sort`` "
"that only modify the list have no return value printed -- they return the "
"default ``None``. [1]_  This is a design principle for all mutable data "
"structures in Python."
msgstr ""
"你可能已经注意到，像 ``insert`` ，``remove`` 或者 ``sort`` 方法，只修改列表，"
"没有打印出返回值——它们返回默认值 ``None`` 。[1]_ 这是Python中所有可变数据结构"
"的设计原则。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:132
msgid "Using Lists as Stacks"
msgstr "列表作为栈使用"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:137
msgid ""
"The list methods make it very easy to use a list as a stack, where the last "
"element added is the first element retrieved (\"last-in, first-out\").  To "
"add an item to the top of the stack, use :meth:`append`.  To retrieve an "
"item from the top of the stack, use :meth:`pop` without an explicit index.  "
"For example::"
msgstr ""
"列表方法使得列表作为堆栈非常容易，最后一个插入，最先取出（“后进先出”）。要添"
"加一个元素到堆栈的顶端，使用 :meth:`append` 。要从堆栈顶部取出一个元素，使"
"用 :meth:`pop` ，不用指定索引。例如 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:162
msgid "Using Lists as Queues"
msgstr "列表作为队列使用"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:166
msgid ""
"It is also possible to use a list as a queue, where the first element added "
"is the first element retrieved (\"first-in, first-out\"); however, lists are "
"not efficient for this purpose.  While appends and pops from the end of list "
"are fast, doing inserts or pops from the beginning of a list is slow "
"(because all of the other elements have to be shifted by one)."
msgstr ""
"列表也可以用作队列，其中先添加的元素被最先取出 (“先进先出”)；然而列表用作这个"
"目的相当低效。因为在列表的末尾添加和弹出元素非常快，但是在列表的开头插入或弹"
"出元素却很慢 (因为所有的其他元素都必须移动一位)。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:172
msgid ""
"To implement a queue, use :class:`collections.deque` which was designed to "
"have fast appends and pops from both ends.  For example::"
msgstr ""
"若要实现一个队列，可使用 :class:`collections.deque`，它被设计成可以快速地从两"
"端添加或弹出元素。例如 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:190
msgid "List Comprehensions"
msgstr "列表推导式"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:192
msgid ""
"List comprehensions provide a concise way to create lists. Common "
"applications are to make new lists where each element is the result of some "
"operations applied to each member of another sequence or iterable, or to "
"create a subsequence of those elements that satisfy a certain condition."
msgstr ""
"列表推导式提供了一个更简单的创建列表的方法。常见的用法是把某种操作应用于序列"
"或可迭代对象的每个元素上，然后使用其结果来创建列表，或者通过满足某些特定条件"
"元素来创建子序列。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:197
msgid "For example, assume we want to create a list of squares, like::"
msgstr "例如，假设我们想创建一个平方列表，像这样 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:206
msgid ""
"Note that this creates (or overwrites) a variable named ``x`` that still "
"exists after the loop completes.  We can calculate the list of squares "
"without any side effects using::"
msgstr ""
"注意，这将创建（或覆盖）一个名为 ``x`` 的变量，该变量在循环结束后仍然存在。 "
"下述方法可以无副作用地计算平方列表::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:212
msgid "or, equivalently::"
msgstr "或者，等价于 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:216
msgid "which is more concise and readable."
msgstr "上面这种写法更加简洁易读。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:218
msgid ""
"A list comprehension consists of brackets containing an expression followed "
"by a :keyword:`!for` clause, then zero or more :keyword:`!for` or :keyword:`!"
"if` clauses.  The result will be a new list resulting from evaluating the "
"expression in the context of the :keyword:`!for` and :keyword:`!if` clauses "
"which follow it. For example, this listcomp combines the elements of two "
"lists if they are not equal::"
msgstr ""
"列表推导式的结构是由一对方括号所包含的以下内容：一个表达式，后面跟一个 :"
"keyword:`!for` 子句，然后是零个或多个 :keyword:`!for` 或 :keyword:`!if` 子"
"句。 其结果将是一个新列表，由对表达式依据后面的 :keyword:`!for` 和 :keyword:"
"`!if` 子句的内容进行求值计算而得出。 举例来说，以下列表推导式会将两个列表中不"
"相等的元素组合起来::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:228
msgid "and it's equivalent to::"
msgstr "而它等价于 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:239
msgid ""
"Note how the order of the :keyword:`for` and :keyword:`if` statements is the "
"same in both these snippets."
msgstr ""
"注意在上面两个代码片段中， :keyword:`for` 和 :keyword:`if` 的顺序是相同的。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:242
msgid ""
"If the expression is a tuple (e.g. the ``(x, y)`` in the previous example), "
"it must be parenthesized. ::"
msgstr "如果表达式是一个元组（例如上面的 ``(x, y)``），那么就必须加上括号 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:273
msgid ""
"List comprehensions can contain complex expressions and nested functions::"
msgstr "列表推导式可以使用复杂的表达式和嵌套函数 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:280
msgid "Nested List Comprehensions"
msgstr "嵌套的列表推导式"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:282
msgid ""
"The initial expression in a list comprehension can be any arbitrary "
"expression, including another list comprehension."
msgstr "列表推导式中的初始表达式可以是任何表达式，包括另一个列表推导式。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:285
msgid ""
"Consider the following example of a 3x4 matrix implemented as a list of 3 "
"lists of length 4::"
msgstr "考虑下面这个 3x4的矩阵，它由3个长度为4的列表组成 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:294
msgid "The following list comprehension will transpose rows and columns::"
msgstr "下面的列表推导式将交换其行和列 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:299
msgid ""
"As we saw in the previous section, the nested listcomp is evaluated in the "
"context of the :keyword:`for` that follows it, so this example is equivalent "
"to::"
msgstr ""
"如上节所示，嵌套的列表推导式是基于跟随其后的 :keyword:`for` 进行求值的，所以"
"这个例子等价于::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:310
msgid "which, in turn, is the same as::"
msgstr "反过来说，也等价于 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:323
msgid ""
"In the real world, you should prefer built-in functions to complex flow "
"statements. The :func:`zip` function would do a great job for this use case::"
msgstr ""
"实际应用中，你应该会更喜欢使用内置函数去组成复杂的流程语句。 :func:`zip` 函数"
"将会很好地处理这种情况 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:329
msgid ""
"See :ref:`tut-unpacking-arguments` for details on the asterisk in this line."
msgstr "关于本行中星号的详细说明，参见 :ref:`tut-unpacking-arguments`。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:334
msgid "The :keyword:`!del` statement"
msgstr ":keyword:`!del` 语句"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:336
msgid ""
"There is a way to remove an item from a list given its index instead of its "
"value: the :keyword:`del` statement.  This differs from the :meth:`pop` "
"method which returns a value.  The :keyword:`!del` statement can also be "
"used to remove slices from a list or clear the entire list (which we did "
"earlier by assignment of an empty list to the slice).  For example::"
msgstr ""
"有一种方式可以从列表按照给定的索引而不是值来移除一个元素: 那就是 :keyword:"
"`del` 语句。 它不同于会返回一个值的 :meth:`pop` 方法。 :keyword:`!del` 语句也"
"可以用来从列表中移除切片或者清空整个列表（我们之前用过的方式是将一个空列表赋"
"值给指定的切片）。 例如::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:353
msgid ":keyword:`del` can also be used to delete entire variables::"
msgstr ":keyword:`del` 也可以删除整个变量 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:357
msgid ""
"Referencing the name ``a`` hereafter is an error (at least until another "
"value is assigned to it).  We'll find other uses for :keyword:`del` later."
msgstr ""
"此后再引用 ``a`` 时会报错（直到另一个值被赋给它）。我们会在后面了解到 :"
"keyword:`del` 的其他用法。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:364
msgid "Tuples and Sequences"
msgstr "元组和序列"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:366
msgid ""
"We saw that lists and strings have many common properties, such as indexing "
"and slicing operations.  They are two examples of *sequence* data types "
"(see :ref:`typesseq`).  Since Python is an evolving language, other sequence "
"data types may be added.  There is also another standard sequence data type: "
"the *tuple*."
msgstr ""
"我们看到列表和字符串有很多共同特性，例如索引和切片操作。他们是 *序列* 数据类"
"型（参见 :ref:`typesseq`）中的两种。随着 Python 语言的发展，其他的序列类型也"
"会被加入其中。这里介绍另一种标准序列类型: *元组*。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:372
msgid ""
"A tuple consists of a number of values separated by commas, for instance::"
msgstr "一个元组由几个被逗号隔开的值组成，例如 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:394
msgid ""
"As you see, on output tuples are always enclosed in parentheses, so that "
"nested tuples are interpreted correctly; they may be input with or without "
"surrounding parentheses, although often parentheses are necessary anyway (if "
"the tuple is part of a larger expression).  It is not possible to assign to "
"the individual items of a tuple, however it is possible to create tuples "
"which contain mutable objects, such as lists."
msgstr ""
"如你所见，元组在输出时总是被圆括号包围的，以便正确表示嵌套元组。输入时圆括号"
"可有可无，不过经常会是必须的（如果这个元组是一个更大的表达式的一部分）。给元"
"组中的一个单独的元素赋值是不允许的，当然你可以创建包含可变对象的元组，例如列"
"表。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:401
msgid ""
"Though tuples may seem similar to lists, they are often used in different "
"situations and for different purposes. Tuples are :term:`immutable`, and "
"usually contain a heterogeneous sequence of elements that are accessed via "
"unpacking (see later in this section) or indexing (or even by attribute in "
"the case of :func:`namedtuples <collections.namedtuple>`). Lists are :term:"
"`mutable`, and their elements are usually homogeneous and are accessed by "
"iterating over the list."
msgstr ""
"虽然元组可能看起来与列表很像，但它们通常是在不同的场景被使用，并且有着不同的"
"用途。元组是 :term:`immutable` ，其序列通常包含不同种类的元素，并且通过解包"
"（这一节下面会解释）或者索引来访问（如果是 :func:`namedtuples <collections."
"namedtuple>` 的话甚至还可以通过属性访问）。列表是 :term:`mutable` ，并且列表"
"中的元素一般是同种类型的，并且通过迭代访问。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:409
msgid ""
"A special problem is the construction of tuples containing 0 or 1 items: the "
"syntax has some extra quirks to accommodate these.  Empty tuples are "
"constructed by an empty pair of parentheses; a tuple with one item is "
"constructed by following a value with a comma (it is not sufficient to "
"enclose a single value in parentheses). Ugly, but effective.  For example::"
msgstr ""
"一个特殊的问题是构造包含0个或1个元素的元组：为了适应这种情况，语法有一些额外"
"的改变。空元组可以直接被一对空圆括号创建，含有一个元素的元组可以通过在这个元"
"素后添加一个逗号来构建（圆括号里只有一个值的话不够明确）。丑陋，但是有效。例"
"如 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:424
msgid ""
"The statement ``t = 12345, 54321, 'hello!'`` is an example of *tuple "
"packing*: the values ``12345``, ``54321`` and ``'hello!'`` are packed "
"together in a tuple. The reverse operation is also possible::"
msgstr ""
"语句 ``t = 12345, 54321, 'hello!'`` 是 *元组打包* 的一个例子：值 ``12345``, "
"``54321`` 和 ``'hello!'`` 被打包进元组。其逆操作也是允许的 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:430
msgid ""
"This is called, appropriately enough, *sequence unpacking* and works for any "
"sequence on the right-hand side.  Sequence unpacking requires that there are "
"as many variables on the left side of the equals sign as there are elements "
"in the sequence.  Note that multiple assignment is really just a combination "
"of tuple packing and sequence unpacking."
msgstr ""
"这被称为 *序列解包*  也是很恰当的，因为解包操作的等号右侧可以是任何序列。序列"
"解包要求等号左侧的变量数与右侧序列里所含的元素数相同。注意多重赋值其实也只是"
"元组打包和序列解包的组合。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:440
msgid "Sets"
msgstr "集合"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:442
msgid ""
"Python also includes a data type for *sets*.  A set is an unordered "
"collection with no duplicate elements.  Basic uses include membership "
"testing and eliminating duplicate entries.  Set objects also support "
"mathematical operations like union, intersection, difference, and symmetric "
"difference."
msgstr ""
"Python也包含有 *集合* 类型。集合是由不重复元素组成的无序的集。它的基本用法包"
"括成员检测和消除重复元素。集合对象也支持像 联合，交集，差集，对称差分等数学运"
"算。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:447
msgid ""
"Curly braces or the :func:`set` function can be used to create sets.  Note: "
"to create an empty set you have to use ``set()``, not ``{}``; the latter "
"creates an empty dictionary, a data structure that we discuss in the next "
"section."
msgstr ""
"花括号或 :func:`set` 函数可以用来创建集合。注意：要创建一个空集合你只能用 "
"``set()`` 而不能用 ``{}``，因为后者是创建一个空字典，这种数据结构我们会在下一"
"节进行讨论。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:451
msgid "Here is a brief demonstration::"
msgstr "以下是一些简单的示例 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:476
msgid ""
"Similarly to :ref:`list comprehensions <tut-listcomps>`, set comprehensions "
"are also supported::"
msgstr "类似于 :ref:`列表推导式 <tut-listcomps>`，集合也支持推导式形式 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:487
msgid "Dictionaries"
msgstr "字典"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:489
msgid ""
"Another useful data type built into Python is the *dictionary* (see :ref:"
"`typesmapping`). Dictionaries are sometimes found in other languages as "
"\"associative memories\" or \"associative arrays\".  Unlike sequences, which "
"are indexed by a range of numbers, dictionaries are indexed by *keys*, which "
"can be any immutable type; strings and numbers can always be keys.  Tuples "
"can be used as keys if they contain only strings, numbers, or tuples; if a "
"tuple contains any mutable object either directly or indirectly, it cannot "
"be used as a key. You can't use lists as keys, since lists can be modified "
"in place using index assignments, slice assignments, or methods like :meth:"
"`append` and :meth:`extend`."
msgstr ""
"另一个非常有用的 Python 內置数据类型是 *字典* (参见 :ref:`typesmapping`)。字"
"典在其他语言里可能会被叫做 *联合内存* 或 *联合数组*。与以连续整数为索引的序列"
"不同，字典是以 *关键字* 为索引的，关键字可以是任意不可变类型，通常是字符串或"
"数字。如果一个元组只包含字符串、数字或元组，那么这个元组也可以用作关键字。但"
"如果元组直接或间接地包含了可变对象，那么它就不能用作关键字。列表不能用作关键"
"字，因为列表可以通过索引、切片或 :meth:`append` 和 :meth:`extend` 之类的方法"
"来改变。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:500
msgid ""
"It is best to think of a dictionary as a set of *key: value* pairs, with the "
"requirement that the keys are unique (within one dictionary). A pair of "
"braces creates an empty dictionary: ``{}``. Placing a comma-separated list "
"of key:value pairs within the braces adds initial key:value pairs to the "
"dictionary; this is also the way dictionaries are written on output."
msgstr ""
"理解字典的最好方式，就是将它看做是一个 *键: 值* 对的集合，键必须是唯一的（在"
"一个字典中）。一对花括号可以创建一个空字典：``{}`` 。另一种初始化字典的方式是"
"在一对花括号里放置一些以逗号分隔的键值对，而这也是字典输出的方式。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:506
msgid ""
"The main operations on a dictionary are storing a value with some key and "
"extracting the value given the key.  It is also possible to delete a key:"
"value pair with ``del``. If you store using a key that is already in use, "
"the old value associated with that key is forgotten.  It is an error to "
"extract a value using a non-existent key."
msgstr ""
"字典主要的操作是使用关键字存储和解析值。也可以用 ``del`` 来删除一个键值对。如"
"果你使用了一个已经存在的关键字来存储值，那么之前与这个关键字关联的值就会被遗"
"忘。用一个不存在的键来取值则会报错。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:512
msgid ""
"Performing ``list(d)`` on a dictionary returns a list of all the keys used "
"in the dictionary, in insertion order (if you want it sorted, just use "
"``sorted(d)`` instead). To check whether a single key is in the dictionary, "
"use the :keyword:`in` keyword."
msgstr ""
"对一个字典执行 ``list(d)`` 将返回包含该字典中所有键的列表，按插入次序排列 (如"
"需其他排序，则要使用 ``sorted(d)``)。要检查字典中是否存在一个特定键，可使用 :"
"keyword:`in` 关键字。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:517
msgid "Here is a small example using a dictionary::"
msgstr "以下是使用字典的一些简单示例 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:538
msgid ""
"The :func:`dict` constructor builds dictionaries directly from sequences of "
"key-value pairs::"
msgstr ":func:`dict` 构造函数可以直接从键值对序列里创建字典。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:544
msgid ""
"In addition, dict comprehensions can be used to create dictionaries from "
"arbitrary key and value expressions::"
msgstr "此外，字典推导式可以从任意的键值表达式中创建字典 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:550
msgid ""
"When the keys are simple strings, it is sometimes easier to specify pairs "
"using keyword arguments::"
msgstr "当关键字是简单字符串时，有时直接通过关键字参数来指定键值对更方便 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:560
msgid "Looping Techniques"
msgstr "循环的技巧"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:562
msgid ""
"When looping through dictionaries, the key and corresponding value can be "
"retrieved at the same time using the :meth:`items` method. ::"
msgstr "当在字典中循环时，用 :meth:`items` 方法可将关键字和对应的值同时取出 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:572
msgid ""
"When looping through a sequence, the position index and corresponding value "
"can be retrieved at the same time using the :func:`enumerate` function. ::"
msgstr ""
"当在序列中循环时，用 :func:`enumerate` 函数可以将索引位置和其对应的值同时取"
"出 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:582
msgid ""
"To loop over two or more sequences at the same time, the entries can be "
"paired with the :func:`zip` function. ::"
msgstr ""
"当同时在两个或更多序列中循环时，可以用 :func:`zip` 函数将其内元素一一匹"
"配。 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:594
msgid ""
"To loop over a sequence in reverse, first specify the sequence in a forward "
"direction and then call the :func:`reversed` function. ::"
msgstr ""
"如果要逆向循环一个序列，可以先正向定位序列，然后调用 :func:`reversed` 函数 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:606
msgid ""
"To loop over a sequence in sorted order, use the :func:`sorted` function "
"which returns a new sorted list while leaving the source unaltered. ::"
msgstr ""
"如果要按某个指定顺序循环一个序列，可以用 :func:`sorted` 函数，它可以在不改动"
"原序列的基础上返回一个新的排好序的序列 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:618
msgid ""
"It is sometimes tempting to change a list while you are looping over it; "
"however, it is often simpler and safer to create a new list instead. ::"
msgstr ""
"有时可能会想在循环时修改列表内容，一般来说改为创建一个新列表是比较简单且安全"
"的 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:635
msgid "More on Conditions"
msgstr "深入条件控制"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:637
msgid ""
"The conditions used in ``while`` and ``if`` statements can contain any "
"operators, not just comparisons."
msgstr "``while`` 和 ``if`` 条件句中可以使用任意操作，而不仅仅是比较操作。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:640
msgid ""
"The comparison operators ``in`` and ``not in`` check whether a value occurs "
"(does not occur) in a sequence.  The operators ``is`` and ``is not`` compare "
"whether two objects are really the same object; this only matters for "
"mutable objects like lists.  All comparison operators have the same "
"priority, which is lower than that of all numerical operators."
msgstr ""
"比较操作符 ``in`` 和 ``not in`` 校验一个值是否在（或不在）一个序列里。操作符 "
"``is`` 和 ``is not`` 比较两个对象是不是同一个对象，这只对像列表这样的可变对象"
"比较重要。所有的比较操作符都有相同的优先级，且这个优先级比数值运算符低。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:646
msgid ""
"Comparisons can be chained.  For example, ``a < b == c`` tests whether ``a`` "
"is less than ``b`` and moreover ``b`` equals ``c``."
msgstr ""
"比较操作可以传递。例如 ``a < b == c`` 会校验是否 ``a`` 小于 ``b`` 并且 ``b`` "
"等于 ``c``。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:649
msgid ""
"Comparisons may be combined using the Boolean operators ``and`` and ``or``, "
"and the outcome of a comparison (or of any other Boolean expression) may be "
"negated with ``not``.  These have lower priorities than comparison "
"operators; between them, ``not`` has the highest priority and ``or`` the "
"lowest, so that ``A and not B or C`` is equivalent to ``(A and (not B)) or "
"C``. As always, parentheses can be used to express the desired composition."
msgstr ""
"比较操作可以通过布尔运算符 ``and`` 和 ``or`` 来组合，并且比较操作（或其他任何"
"布尔运算）的结果都可以用 ``not`` 来取反。这些操作符的优先级低于比较操作符；在"
"它们之中，``not`` 优先级最高， ``or`` 优先级最低，因此 ``A and not B or C`` "
"等价于 ``(A and (not B)) or C``。和之前一样，你也可以在这种式子里使用圆括号。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:656
msgid ""
"The Boolean operators ``and`` and ``or`` are so-called *short-circuit* "
"operators: their arguments are evaluated from left to right, and evaluation "
"stops as soon as the outcome is determined.  For example, if ``A`` and ``C`` "
"are true but ``B`` is false, ``A and B and C`` does not evaluate the "
"expression ``C``.  When used as a general value and not as a Boolean, the "
"return value of a short-circuit operator is the last evaluated argument."
msgstr ""
"布尔运算符 ``and`` 和 ``or`` 也被称为 *短路* 运算符：它们的参数从左至右解析，"
"一旦可以确定结果解析就会停止。例如，如果 ``A`` 和 ``C`` 为真而 ``B`` 为假，那"
"么 ``A and B and C`` 不会解析 ``C``。当用作普通值而非布尔值时，短路操作符的返"
"回值通常是最后一个变量。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:663
msgid ""
"It is possible to assign the result of a comparison or other Boolean "
"expression to a variable.  For example, ::"
msgstr "也可以把比较操作或者逻辑表达式的结果赋值给一个变量，例如 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:671
msgid ""
"Note that in Python, unlike C, assignment cannot occur inside expressions. C "
"programmers may grumble about this, but it avoids a common class of problems "
"encountered in C programs: typing ``=`` in an expression when ``==`` was "
"intended."
msgstr ""
"注意 Python 与 C 不同，赋值操作不能发生在表达式内部。C程序员可能会对此抱怨，"
"但它避免了一类C程序中常见的错误：想在表达式中写 ``==`` 时却写成了 ``=``。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:680
msgid "Comparing Sequences and Other Types"
msgstr "比较序列和其他类型"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:682
msgid ""
"Sequence objects may be compared to other objects with the same sequence "
"type. The comparison uses *lexicographical* ordering: first the first two "
"items are compared, and if they differ this determines the outcome of the "
"comparison; if they are equal, the next two items are compared, and so on, "
"until either sequence is exhausted. If two items to be compared are "
"themselves sequences of the same type, the lexicographical comparison is "
"carried out recursively.  If all items of two sequences compare equal, the "
"sequences are considered equal. If one sequence is an initial sub-sequence "
"of the other, the shorter sequence is the smaller (lesser) one.  "
"Lexicographical ordering for strings uses the Unicode code point number to "
"order individual characters.  Some examples of comparisons between sequences "
"of the same type::"
msgstr ""
"序列对象可以与相同类型的其他对象比较。它们使用 *字典顺序* 进行比较：首先比较"
"两个序列的第一个元素，如果不同，那么这就决定了比较操作的结果。如果它们相同，"
"就再比较每个序列的第二个元素，以此类推，直到有一个序列被耗尽。如果要比较的两"
"个元素本身就是相同类型的序列，那么就递归进行字典顺序比较。如果两个序列中所有"
"的元素都相等，那么我们认为这两个序列相等。如果一个序列是另一个序列的初始子序"
"列，那么短序列就小于（少于）另一个。字典顺序对字符串来说，是使用单字符的 "
"Unicode 码的顺序。下面是同类型序列之间比较的例子 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:702
msgid ""
"Note that comparing objects of different types with ``<`` or ``>`` is legal "
"provided that the objects have appropriate comparison methods.  For example, "
"mixed numeric types are compared according to their numeric value, so 0 "
"equals 0.0, etc.  Otherwise, rather than providing an arbitrary ordering, "
"the interpreter will raise a :exc:`TypeError` exception."
msgstr ""
"注意对不同类型对象来说，只要待比较对象提供了合适的比较方法，就可以使用 ``<`` "
"和 ``>`` 来比较。例如，混合数值类型是通过他们的数值进行比较的，所以 0 等于 "
"0.0，等等。否则，解释器将抛出一个 :exc:`TypeError` 异常，而不是随便给出一个结"
"果。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:710
msgid "Footnotes"
msgstr "备注"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/tutorial/datastructures.rst:711
msgid ""
"Other languages may return the mutated object, which allows method chaining, "
"such as ``d->insert(\"a\")->remove(\"b\")->sort();``."
msgstr ""
"别的语言可能会返回一个可变对象，他们允许方法连续执行，例如 ``d-"
">insert(\"a\")->remove(\"b\")->sort();``。"
