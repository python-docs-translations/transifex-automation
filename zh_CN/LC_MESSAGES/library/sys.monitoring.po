# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Fw[a]rd <howard.main@outlook.com>, 2023
# Freesand Leo <yuqinju@163.com>, 2023
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-20 14:13+0000\n"
"PO-Revision-Date: 2023-09-08 14:16+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2023\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/"
"teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/sys.monitoring.rst:2
msgid ":mod:`sys.monitoring` --- Execution event monitoring"
msgstr ":mod:`sys.monitoring` --- 执行事件监测"

#: ../../library/sys.monitoring.rst:13
msgid ""
":mod:`sys.monitoring` is a namespace within the :mod:`sys` module, not an "
"independent module, so there is no need to ``import sys.monitoring``, simply "
"``import sys`` and then use ``sys.monitoring``."
msgstr ""

#: ../../library/sys.monitoring.rst:19
msgid ""
"This namespace provides access to the functions and constants necessary to "
"activate and control event monitoring."
msgstr "这个命名空间提供了对于激活和控制事件监控所需的函数和常量的访问。"

#: ../../library/sys.monitoring.rst:22
msgid ""
"As programs execute, events occur that might be of interest to tools that "
"monitor execution. The :mod:`sys.monitoring` namespace provides means to "
"receive callbacks when events of interest occur."
msgstr ""

#: ../../library/sys.monitoring.rst:26
msgid "The monitoring API consists of three components:"
msgstr "monitoring API由三个部分组成："

#: ../../library/sys.monitoring.rst:28
msgid "`Tool identifiers`_"
msgstr ""

#: ../../library/sys.monitoring.rst:29
msgid "`Events`_"
msgstr ""

#: ../../library/sys.monitoring.rst:30
msgid ":ref:`Callbacks <callbacks>`"
msgstr ""

#: ../../library/sys.monitoring.rst:33
msgid "Tool identifiers"
msgstr "工具标识符"

#: ../../library/sys.monitoring.rst:35
msgid ""
"A tool identifier is an integer and the associated name. Tool identifiers "
"are used to discourage tools from interfering with each other and to allow "
"multiple tools to operate at the same time. Currently tools are completely "
"independent and cannot be used to monitor each other. This restriction may "
"be lifted in the future."
msgstr ""

#: ../../library/sys.monitoring.rst:41
msgid ""
"Before registering or activating events, a tool should choose an identifier. "
"Identifiers are integers in the range 0 to 5 inclusive."
msgstr ""

#: ../../library/sys.monitoring.rst:45
msgid "Registering and using tools"
msgstr "注册和使用工具"

#: ../../library/sys.monitoring.rst:49
msgid ""
"Must be called before *id* can be used. *id* must be in the range 0 to 5 "
"inclusive. Raises a :exc:`ValueError` if *id* is in use."
msgstr ""

#: ../../library/sys.monitoring.rst:55
msgid "Should be called once a tool no longer requires *id*."
msgstr ""

#: ../../library/sys.monitoring.rst:59
msgid ""
"Returns the name of the tool if *id* is in use, otherwise it returns "
"``None``. *id* must be in the range 0 to 5 inclusive."
msgstr ""

#: ../../library/sys.monitoring.rst:63
msgid ""
"All IDs are treated the same by the VM with regard to events, but the "
"following IDs are pre-defined to make co-operation of tools easier::"
msgstr ""
"虚拟机在处理事件时对所有 ID 都一视同仁，但为便于工具之间的协作而预定义了下列 "
"ID::"

#: ../../library/sys.monitoring.rst:71
msgid ""
"There is no obligation to set an ID, nor is there anything preventing a tool "
"from using an ID even it is already in use. However, tools are encouraged to "
"use a unique ID and respect other tools."
msgstr ""
"设置 ID 并非强制要求，也没有任何规定阻止工具使用已被使用的 ID。 不过，我们鼓"
"励工具使用唯一的 ID 并尊重其他工具的设置。"

#: ../../library/sys.monitoring.rst:76
msgid "Events"
msgstr "事件"

#: ../../library/sys.monitoring.rst:78
msgid "The following events are supported:"
msgstr "以下事件是受支持的："

#: ../../library/sys.monitoring.rst:82
msgid "A conditional branch is taken (or not)."
msgstr "条件分支被采用（或不采用）。"

#: ../../library/sys.monitoring.rst:86
msgid "A call in Python code (event occurs before the call)."
msgstr "Python 代码中的调用（事件发生在调用之前）。"

#: ../../library/sys.monitoring.rst:90
msgid ""
"An exception raised from any callable, except for Python functions (event "
"occurs after the exit)."
msgstr ""

#: ../../library/sys.monitoring.rst:94
msgid ""
"Return from any callable, except for Python functions (event occurs after "
"the return)."
msgstr ""

#: ../../library/sys.monitoring.rst:98
msgid "An exception is handled."
msgstr "一个异常被处理。"

#: ../../library/sys.monitoring.rst:102
msgid "A VM instruction is about to be executed."
msgstr "一个 VM 指令即将被执行。"

#: ../../library/sys.monitoring.rst:106
msgid "An unconditional jump in the control flow graph is made."
msgstr "在控制流图中进行一次无条件的跳转。"

#: ../../library/sys.monitoring.rst:110
msgid ""
"An instruction is about to be executed that has a different line number from "
"the preceding instruction."
msgstr "一条与之前指令行号不同的指令即将被执行。"

#: ../../library/sys.monitoring.rst:114
msgid ""
"Resumption of a Python function (for generator and coroutine functions), "
"except for ``throw()`` calls."
msgstr ""

#: ../../library/sys.monitoring.rst:118
msgid ""
"Return from a Python function (occurs immediately before the return, the "
"callee's frame will be on the stack)."
msgstr "从一个 Python 函数返回（在返回之前立即发生，被调用方的帧将在栈中）。"

#: ../../library/sys.monitoring.rst:122
msgid ""
"Start of a Python function (occurs immediately after the call, the callee's "
"frame will be on the stack)"
msgstr "开始一个 Python 函数（在调用之后立即发生，被调用方的帧将在栈中）"

#: ../../library/sys.monitoring.rst:126
msgid "A Python function is resumed by a ``throw()`` call."
msgstr ""

#: ../../library/sys.monitoring.rst:130
msgid "Exit from a Python function during exception unwinding."
msgstr "在异常解除期间从一个 Python函数退出。"

#: ../../library/sys.monitoring.rst:134
msgid ""
"Yield from a Python function (occurs immediately before the yield, the "
"callee's frame will be on the stack)."
msgstr ""
"从一个 Python 函数产出数据（在产出之前立即发生，被调用方的帧将在栈中）。"

#: ../../library/sys.monitoring.rst:138
msgid ""
"An exception is raised, except those that cause a :monitoring-event:"
"`STOP_ITERATION` event."
msgstr ""

#: ../../library/sys.monitoring.rst:142
msgid ""
"An exception is re-raised, for example at the end of a :keyword:`finally` "
"block."
msgstr ""

#: ../../library/sys.monitoring.rst:146
msgid ""
"An artificial :exc:`StopIteration` is raised; see `the STOP_ITERATION "
"event`_."
msgstr ""

#: ../../library/sys.monitoring.rst:149
msgid "More events may be added in the future."
msgstr "将来可能会添加更多事件。"

#: ../../library/sys.monitoring.rst:151
msgid ""
"These events are attributes of the :mod:`!sys.monitoring.events` namespace. "
"Each event is represented as a power-of-2 integer constant. To define a set "
"of events, simply bitwise or the individual events together. For example, to "
"specify both :monitoring-event:`PY_RETURN` and :monitoring-event:`PY_START` "
"events, use the expression ``PY_RETURN | PY_START``."
msgstr ""

#: ../../library/sys.monitoring.rst:159
msgid "An alias for ``0`` so users can do explict comparisions like::"
msgstr ""

#: ../../library/sys.monitoring.rst:164
msgid "Events are divided into three groups:"
msgstr "事件被分为三组："

#: ../../library/sys.monitoring.rst:167
msgid "Local events"
msgstr "本地事件"

#: ../../library/sys.monitoring.rst:169
msgid ""
"Local events are associated with normal execution of the program and happen "
"at clearly defined locations. All local events can be disabled. The local "
"events are:"
msgstr ""
"本地事件与程序的正常执行相关联并且发生在明确定义的位置上。 所有本地事件都可以"
"被禁用。 本地事件包括："

#: ../../library/sys.monitoring.rst:173
msgid ":monitoring-event:`PY_START`"
msgstr ""

#: ../../library/sys.monitoring.rst:174
msgid ":monitoring-event:`PY_RESUME`"
msgstr ""

#: ../../library/sys.monitoring.rst:175
msgid ":monitoring-event:`PY_RETURN`"
msgstr ""

#: ../../library/sys.monitoring.rst:176
msgid ":monitoring-event:`PY_YIELD`"
msgstr ""

#: ../../library/sys.monitoring.rst:177
msgid ":monitoring-event:`CALL`"
msgstr ""

#: ../../library/sys.monitoring.rst:178
msgid ":monitoring-event:`LINE`"
msgstr ""

#: ../../library/sys.monitoring.rst:179
msgid ":monitoring-event:`INSTRUCTION`"
msgstr ""

#: ../../library/sys.monitoring.rst:180
msgid ":monitoring-event:`JUMP`"
msgstr ""

#: ../../library/sys.monitoring.rst:181
msgid ":monitoring-event:`BRANCH`"
msgstr ""

#: ../../library/sys.monitoring.rst:182
msgid ":monitoring-event:`STOP_ITERATION`"
msgstr ""

#: ../../library/sys.monitoring.rst:185
msgid "Ancillary events"
msgstr "辅助事件"

#: ../../library/sys.monitoring.rst:187
msgid ""
"Ancillary events can be monitored like other events, but are controlled by "
"another event:"
msgstr "辅助事件可以像其他事件一样被监视，但是由另一个事件来控制："

#: ../../library/sys.monitoring.rst:190
msgid ":monitoring-event:`C_RAISE`"
msgstr ""

#: ../../library/sys.monitoring.rst:191
msgid ":monitoring-event:`C_RETURN`"
msgstr ""

#: ../../library/sys.monitoring.rst:193
msgid ""
"The :monitoring-event:`C_RETURN` and :monitoring-event:`C_RAISE` events are "
"controlled by the :monitoring-event:`CALL` event. :monitoring-event:"
"`C_RETURN` and :monitoring-event:`C_RAISE` events will only be seen if the "
"corresponding :monitoring-event:`CALL` event is being monitored."
msgstr ""

#: ../../library/sys.monitoring.rst:199
msgid "Other events"
msgstr "其他事件"

#: ../../library/sys.monitoring.rst:201
msgid ""
"Other events are not necessarily tied to a specific location in the program "
"and cannot be individually disabled."
msgstr "其他事件不一定与程序中的特定位置相关联并且不能被单独禁用。"

#: ../../library/sys.monitoring.rst:204
msgid "The other events that can be monitored are:"
msgstr "可以被监视的其他事件包括："

#: ../../library/sys.monitoring.rst:206
msgid ":monitoring-event:`PY_THROW`"
msgstr ""

#: ../../library/sys.monitoring.rst:207
msgid ":monitoring-event:`PY_UNWIND`"
msgstr ""

#: ../../library/sys.monitoring.rst:208
msgid ":monitoring-event:`RAISE`"
msgstr ""

#: ../../library/sys.monitoring.rst:209
msgid ":monitoring-event:`EXCEPTION_HANDLED`"
msgstr ""

#: ../../library/sys.monitoring.rst:213
msgid "The STOP_ITERATION event"
msgstr "STOP_ITERATION 事件"

#: ../../library/sys.monitoring.rst:215
msgid ""
":pep:`PEP 380 <380#use-of-stopiteration-to-return-values>` specifies that a :"
"exc:`StopIteration` exception is raised when returning a value from a "
"generator or coroutine. However, this is a very inefficient way to return a "
"value, so some Python implementations, notably CPython 3.12+, do not raise "
"an exception unless it would be visible to other code."
msgstr ""

#: ../../library/sys.monitoring.rst:221
msgid ""
"To allow tools to monitor for real exceptions without slowing down "
"generators and coroutines, the :monitoring-event:`STOP_ITERATION` event is "
"provided. :monitoring-event:`STOP_ITERATION` can be locally disabled, "
"unlike :monitoring-event:`RAISE`."
msgstr ""

#: ../../library/sys.monitoring.rst:227
msgid "Turning events on and off"
msgstr "开启和关闭事件"

#: ../../library/sys.monitoring.rst:229
msgid ""
"In order to monitor an event, it must be turned on and a corresponding "
"callback must be registered. Events can be turned on or off by setting the "
"events either globally or for a particular code object."
msgstr ""

#: ../../library/sys.monitoring.rst:236
msgid "Setting events globally"
msgstr "全局设置事件"

#: ../../library/sys.monitoring.rst:238
msgid ""
"Events can be controlled globally by modifying the set of events being "
"monitored."
msgstr "通过修改被监视的事件集可以对事件进行全局控制。"

#: ../../library/sys.monitoring.rst:242
msgid "Returns the ``int`` representing all the active events."
msgstr "返回代表所有活动事件的 ``int``。"

#: ../../library/sys.monitoring.rst:246
msgid ""
"Activates all events which are set in *event_set*. Raises a :exc:"
"`ValueError` if *tool_id* is not in use."
msgstr ""

#: ../../library/sys.monitoring.rst:249
msgid "No events are active by default."
msgstr "在默认情况下没有被激活的事件。"

#: ../../library/sys.monitoring.rst:252
msgid "Per code object events"
msgstr "针对特定代码对象的事件"

#: ../../library/sys.monitoring.rst:254
msgid "Events can also be controlled on a per code object basis."
msgstr "事件还可以基于特定代码对象进行控制。"

#: ../../library/sys.monitoring.rst:258
msgid "Returns all the local events for *code*"
msgstr ""

#: ../../library/sys.monitoring.rst:262
msgid ""
"Activates all the local events for *code* which are set in *event_set*. "
"Raises a :exc:`ValueError` if *tool_id* is not in use."
msgstr ""

#: ../../library/sys.monitoring.rst:265
msgid ""
"Local events add to global events, but do not mask them. In other words, all "
"global events will trigger for a code object, regardless of the local events."
msgstr ""
"局部事件将添加到全局事件中，但不会屏蔽全局事件。 换句话说，所有全局事件都会为"
"代码对象触发，无论是否有局部事件。"

#: ../../library/sys.monitoring.rst:271
msgid "Disabling events"
msgstr "禁用事件"

#: ../../library/sys.monitoring.rst:275
msgid ""
"A special value that can be returned from a callback function to disable "
"events for the current code location."
msgstr ""

#: ../../library/sys.monitoring.rst:278
msgid ""
"Local events can be disabled for a specific code location by returning :data:"
"`sys.monitoring.DISABLE` from a callback function. This does not change "
"which events are set, or any other code locations for the same event."
msgstr ""

#: ../../library/sys.monitoring.rst:282
msgid ""
"Disabling events for specific locations is very important for high "
"performance monitoring. For example, a program can be run under a debugger "
"with no overhead if the debugger disables all monitoring except for a few "
"breakpoints."
msgstr ""
"禁用特定位置的事件对高性能的监控非常重要。 例如，如果调试器禁用了除几个断点外"
"的所有监控那么程序在调试器下运行时就不会产生额外的开销。"

#: ../../library/sys.monitoring.rst:291
msgid "Registering callback functions"
msgstr "注册回调函数"

#: ../../library/sys.monitoring.rst:293
msgid "To register a callable for events call"
msgstr "要为事件注册一个可调用对象则要调用"

#: ../../library/sys.monitoring.rst:297
msgid "Registers the callable *func* for the *event* with the given *tool_id*"
msgstr ""

#: ../../library/sys.monitoring.rst:299
msgid ""
"If another callback was registered for the given *tool_id* and *event*, it "
"is unregistered and returned. Otherwise :func:`register_callback` returns "
"``None``."
msgstr ""

#: ../../library/sys.monitoring.rst:304
msgid ""
"Functions can be unregistered by calling ``sys.monitoring."
"register_callback(tool_id, event, None)``."
msgstr ""
"函数可以通过调用 ``sys.monitoring.register_callback(tool_id, event, None)`` "
"来注销。"

#: ../../library/sys.monitoring.rst:307
msgid "Callback functions can be registered and unregistered at any time."
msgstr "回调函数可在任何时候被注册或注销。"

#: ../../library/sys.monitoring.rst:309
msgid ""
"Registering or unregistering a callback function will generate a :func:`sys."
"audit` event."
msgstr ""

#: ../../library/sys.monitoring.rst:313
msgid "Callback function arguments"
msgstr "回调函数参数"

#: ../../library/sys.monitoring.rst:317
msgid ""
"A special value that is passed to a callback function to indicate that there "
"are no arguments to the call."
msgstr ""

#: ../../library/sys.monitoring.rst:320
msgid ""
"When an active event occurs, the registered callback function is called. "
"Different events will provide the callback function with different "
"arguments, as follows:"
msgstr ""
"当一个激活的事件发生时，已注册的回调函数将被调用。 不同的事件将为回调函数提供"
"不同的参数，如下所示："

#: ../../library/sys.monitoring.rst:323
msgid ":monitoring-event:`PY_START` and :monitoring-event:`PY_RESUME`::"
msgstr ""

#: ../../library/sys.monitoring.rst:327
msgid ":monitoring-event:`PY_RETURN` and :monitoring-event:`PY_YIELD`::"
msgstr ""

#: ../../library/sys.monitoring.rst:331
msgid ""
":monitoring-event:`CALL`, :monitoring-event:`C_RAISE` and :monitoring-event:"
"`C_RETURN`::"
msgstr ""

#: ../../library/sys.monitoring.rst:335
msgid ""
"If there are no arguments, *arg0* is set to :data:`sys.monitoring.MISSING`."
msgstr ""

#: ../../library/sys.monitoring.rst:337
msgid ""
":monitoring-event:`RAISE`, :monitoring-event:`RERAISE`, :monitoring-event:"
"`EXCEPTION_HANDLED`, :monitoring-event:`PY_UNWIND`, :monitoring-event:"
"`PY_THROW` and :monitoring-event:`STOP_ITERATION`::"
msgstr ""

#: ../../library/sys.monitoring.rst:342
msgid ":monitoring-event:`LINE`::"
msgstr ""

#: ../../library/sys.monitoring.rst:346
msgid ":monitoring-event:`BRANCH` and :monitoring-event:`JUMP`::"
msgstr ""

#: ../../library/sys.monitoring.rst:350
msgid ""
"Note that the *destination_offset* is where the code will next execute. For "
"an untaken branch this will be the offset of the instruction following the "
"branch."
msgstr ""

#: ../../library/sys.monitoring.rst:354
msgid ":monitoring-event:`INSTRUCTION`::"
msgstr ""
