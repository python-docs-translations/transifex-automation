# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# eric R <trencyclopedia@gmail.com>, 2019
# walkinrain <walkinrain2008@outlook.com>, 2019
# nick <2330458484@qq.com>, 2019
# ppcfish <ppcfish@gmail.com>, 2019
# Siyuan Xu, 2019
# Arisaka97 <solitaire2312@gmail.com>, 2019
# Shengjing Zhu <zsj950618@gmail.com>, 2019
# Freesand Leo <yuqinju@163.com>, 2020
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-06-16 16:41+0000\n"
"PO-Revision-Date: 2019-09-01 03:33+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2020\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/"
"teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:2
msgid ":mod:`pickle` --- Python object serialization"
msgstr ":mod:`pickle` —— Python 对象序列化"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:10
msgid "**Source code:** :source:`Lib/pickle.py`"
msgstr "**源代码：** :source:`Lib/pickle.py`"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:22
msgid ""
"The :mod:`pickle` module implements binary protocols for serializing and de-"
"serializing a Python object structure.  *\"Pickling\"* is the process "
"whereby a Python object hierarchy is converted into a byte stream, and "
"*\"unpickling\"* is the inverse operation, whereby a byte stream (from a :"
"term:`binary file` or :term:`bytes-like object`) is converted back into an "
"object hierarchy.  Pickling (and unpickling) is alternatively known as "
"\"serialization\", \"marshalling,\" [#]_ or \"flattening\"; however, to "
"avoid confusion, the terms used here are \"pickling\" and \"unpickling\"."
msgstr ""
"模块 :mod:`pickle` 实现了对一个 Python 对象结构的二进制序列化和反序列化。 "
"*\"Pickling\"* 是将 Python 对象及其所拥有的层次结构转化为一个字节流的过程，"
"而 *\"unpickling\"* 是相反的操作，会将（来自一个 :term:`binary file` 或者 :"
"term:`bytes-like object` 的）字节流转化回一个对象层次结构。Pickling（和 "
"unpickling）也被称为“序列化”, “编组” [#]_ 或者 “平面化”。而为了避免混乱，此处"
"采用术语 “pickling” 和 “unpickling”。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:33
msgid ""
"The :mod:`pickle` module is not secure against erroneous or maliciously "
"constructed data.  Never unpickle data received from an untrusted or "
"unauthenticated source."
msgstr ""
":mod:`pickle` 模块在接受被错误地构造或者被恶意地构造的数据时不安全。永远不要 "
"unpickle 来自于不受信任的或者未经验证的来源的数据。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:39
msgid "Relationship to other Python modules"
msgstr "与其他 Python 模块间的关系"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:42
msgid "Comparison with ``marshal``"
msgstr "与 ``marshal`` 间的关系"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:44
msgid ""
"Python has a more primitive serialization module called :mod:`marshal`, but "
"in general :mod:`pickle` should always be the preferred way to serialize "
"Python objects.  :mod:`marshal` exists primarily to support Python's :file:`."
"pyc` files."
msgstr ""
"Python 有一个更原始的序列化模块称为 :mod:`marshal`，但一般地 :mod:`pickle` 应"
"该是序列化 Python 对象时的首选。:mod:`marshal` 存在主要是为了支持 Python 的 :"
"file:`.pyc` 文件."

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:49
msgid ""
"The :mod:`pickle` module differs from :mod:`marshal` in several significant "
"ways:"
msgstr ":mod:`pickle` 模块与 :mod:`marshal` 在如下几方面显著地不同："

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:51
msgid ""
"The :mod:`pickle` module keeps track of the objects it has already "
"serialized, so that later references to the same object won't be serialized "
"again. :mod:`marshal` doesn't do this."
msgstr ""
":mod:`pickle` 模块会跟踪已被序列化的对象，所以该对象之后再次被引用时不会再次"
"被序列化。:mod:`marshal` 不会这么做。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:55
msgid ""
"This has implications both for recursive objects and object sharing.  "
"Recursive objects are objects that contain references to themselves.  These "
"are not handled by marshal, and in fact, attempting to marshal recursive "
"objects will crash your Python interpreter.  Object sharing happens when "
"there are multiple references to the same object in different places in the "
"object hierarchy being serialized.  :mod:`pickle` stores such objects only "
"once, and ensures that all other references point to the master copy.  "
"Shared objects remain shared, which can be very important for mutable "
"objects."
msgstr ""
"这隐含了递归对象和共享对象。递归对象指包含对自己的引用的对象。这种对象并不会"
"被 marshal 接受，并且实际上尝试 marshal 递归对象会让你的 Python 解释器崩溃。"
"对象共享发生在对象层级中存在多处引用同一对象时。:mod:`pickle` 只会存储这些对"
"象一次，并确保其他的引用指向同一个主副本。共享对象将保持共享，这可能对可变对"
"象非常重要。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:64
msgid ""
":mod:`marshal` cannot be used to serialize user-defined classes and their "
"instances.  :mod:`pickle` can save and restore class instances "
"transparently, however the class definition must be importable and live in "
"the same module as when the object was stored."
msgstr ""
":mod:`marshal` 不能被用于序列化用户定义类及其实例。:mod:`pickle` 能够透明地存"
"储并保存类实例，然而此时类定义必须能够从与被存储时相同的模块被引入。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:69
msgid ""
"The :mod:`marshal` serialization format is not guaranteed to be portable "
"across Python versions.  Because its primary job in life is to support :file:"
"`.pyc` files, the Python implementers reserve the right to change the "
"serialization format in non-backwards compatible ways should the need arise. "
"The :mod:`pickle` serialization format is guaranteed to be backwards "
"compatible across Python releases provided a compatible pickle protocol is "
"chosen and pickling and unpickling code deals with Python 2 to Python 3 type "
"differences if your data is crossing that unique breaking change language "
"boundary."
msgstr ""
"同样用于序列化的 :mod:`marshal` 格式不保证数据能移植到不同的 Python 版本中。"
"因为它的主要任务是支持 :file:`.pyc` 文件，必要时会以破坏向后兼容的方式更改这"
"种序列化格式，为此 Python 的实现者保留了更改格式的权利。:mod:`pickle` 序列化"
"格式可以在不同版本的 Python 中实现向后兼容，前提是选择了合适的 pickle 协议。"
"如果你的数据要在 Python 2 与 Python 3 之间跨越传递，Pickling 和 Unpickling 的"
"代码在 2 和 3 之间也是不同的。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:79
msgid "Comparison with ``json``"
msgstr "与 ``json`` 模块的比较"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:81
msgid ""
"There are fundamental differences between the pickle protocols and `JSON "
"(JavaScript Object Notation) <http://json.org>`_:"
msgstr ""
"Pickle 协议和 `JSON (JavaScript Object Notation) <http://json.org>`_ 间有着本"
"质的不同："

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:84
msgid ""
"JSON is a text serialization format (it outputs unicode text, although most "
"of the time it is then encoded to ``utf-8``), while pickle is a binary "
"serialization format;"
msgstr ""
"JSON 是一个文本序列化格式（它输出 unicode 文本，尽管在大多数时候它会接着以 "
"``utf-8`` 编码），而 pickle 是一个二进制序列化格式；"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:88
msgid "JSON is human-readable, while pickle is not;"
msgstr "JSON 是我们可以直观阅读的，而 pickle 不是；"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:90
msgid ""
"JSON is interoperable and widely used outside of the Python ecosystem, while "
"pickle is Python-specific;"
msgstr "JSON是可互操作的，在Python系统之外广泛使用，而pickle则是Python专用的；"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:93
msgid ""
"JSON, by default, can only represent a subset of the Python built-in types, "
"and no custom classes; pickle can represent an extremely large number of "
"Python types (many of them automatically, by clever usage of Python's "
"introspection facilities; complex cases can be tackled by implementing :ref:"
"`specific object APIs <pickle-inst>`)."
msgstr ""
"默认情况下，JSON 只能表示 Python 内置类型的子集，不能表示自定义的类；但 "
"pickle 可以表示大量的 Python 数据类型（可以合理使用 Python 的对象内省功能自动"
"地表示大多数类型，复杂情况可以通过实现 :ref:`specific object APIs <pickle-"
"inst>` 来解决）。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:100
msgid ""
"The :mod:`json` module: a standard library module allowing JSON "
"serialization and deserialization."
msgstr ":mod:`json` 模块:一个允许JSON序列化和反序列化的标准库模块"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:107
msgid "Data stream format"
msgstr "数据流格式"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:112
msgid ""
"The data format used by :mod:`pickle` is Python-specific.  This has the "
"advantage that there are no restrictions imposed by external standards such "
"as JSON or XDR (which can't represent pointer sharing); however it means "
"that non-Python programs may not be able to reconstruct pickled Python "
"objects."
msgstr ""
":mod:`pickle` 所使用的数据格式仅可用于 Python。这样做的好处是没有外部标准给该"
"格式强加限制，比如 JSON 或 XDR（不能表示共享指针）标准；但这也意味着非 "
"Python 程序可能无法重新读取 pickle 打包的 Python 对象。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:117
msgid ""
"By default, the :mod:`pickle` data format uses a relatively compact binary "
"representation.  If you need optimal size characteristics, you can "
"efficiently :doc:`compress <archiving>` pickled data."
msgstr ""
"默认情况下，:mod:`pickle` 格式使用相对紧凑的二进制来存储。如果需要让文件更"
"小，可以高效地 :doc:`压缩 <archiving>` 由 pickle 打包的数据。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:121
msgid ""
"The module :mod:`pickletools` contains tools for analyzing data streams "
"generated by :mod:`pickle`.  :mod:`pickletools` source code has extensive "
"comments about opcodes used by pickle protocols."
msgstr ""
":mod:`pickletools` 模块包含了相应的工具用于分析 :mod:`pickle` 生成的数据流。:"
"mod:`pickletools` 源码中包含了对 pickle 协议使用的操作码的大量注释。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:125
msgid ""
"There are currently 5 different protocols which can be used for pickling. "
"The higher the protocol used, the more recent the version of Python needed "
"to read the pickle produced."
msgstr ""
"当前用于 pickling 的协议共有 5 种。使用的协议版本越高，读取生成的 pickle 所需"
"的 Python 版本就要越新。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:129
msgid ""
"Protocol version 0 is the original \"human-readable\" protocol and is "
"backwards compatible with earlier versions of Python."
msgstr "v0 版协议是原始的“人类可读”协议，并且向后兼容早期版本的 Python。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:132
msgid ""
"Protocol version 1 is an old binary format which is also compatible with "
"earlier versions of Python."
msgstr "v1 版协议是较早的二进制格式，它也与早期版本的 Python 兼容。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:135
msgid ""
"Protocol version 2 was introduced in Python 2.3.  It provides much more "
"efficient pickling of :term:`new-style class`\\es.  Refer to :pep:`307` for "
"information about improvements brought by protocol 2."
msgstr ""
"v2 版协议是在 Python 2.3 中引入的。它为存储 :term:`new-style class` 提供了更"
"高效的机制。欲了解有关第 2 版协议带来的改进，请参阅 :pep:`307`。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:139
msgid ""
"Protocol version 3 was added in Python 3.0.  It has explicit support for :"
"class:`bytes` objects and cannot be unpickled by Python 2.x.  This is the "
"default protocol, and the recommended protocol when compatibility with other "
"Python 3 versions is required."
msgstr ""
"v3 版协议添加于 Python 3.0。它具有对 :class:`bytes` 对象的显式支持，且无法被 "
"Python 2.x 打开。这是目前默认使用的协议，也是在要求与其他 Python 3 版本兼容时"
"的推荐协议。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:144
msgid ""
"Protocol version 4 was added in Python 3.4.  It adds support for very large "
"objects, pickling more kinds of objects, and some data format "
"optimizations.  Refer to :pep:`3154` for information about improvements "
"brought by protocol 4."
msgstr ""
"v4 版协议添加于 Python 3.4。它支持存储非常大的对象，能存储更多种类的对象，还"
"包括一些针对数据格式的优化。有关第 4 版协议带来改进的信息，请参阅 :pep:"
"`3154`。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:150
msgid ""
"Serialization is a more primitive notion than persistence; although :mod:"
"`pickle` reads and writes file objects, it does not handle the issue of "
"naming persistent objects, nor the (even more complicated) issue of "
"concurrent access to persistent objects.  The :mod:`pickle` module can "
"transform a complex object into a byte stream and it can transform the byte "
"stream into an object with the same internal structure.  Perhaps the most "
"obvious thing to do with these byte streams is to write them onto a file, "
"but it is also conceivable to send them across a network or store them in a "
"database.  The :mod:`shelve` module provides a simple interface to pickle "
"and unpickle objects on DBM-style database files."
msgstr ""
"序列化是一种比持久化更底层的概念，虽然 :mod:`pickle` 读取和写入的是文件对象，"
"但它不处理持久对象的命名问题，也不处理对持久对象的并发访问（甚至更复杂）的问"
"题。:mod:`pickle` 模块可以将复杂对象转换为字节流，也可以将字节流转换为具有相"
"同内部结构的对象。处理这些字节流最常见的做法是将它们写入文件，但它们也可以通"
"过网络发送或存储在数据库中。:mod:`shelve` 模块提供了一个简单的接口，用于在 "
"DBM 类型的数据库文件上 pickle 和 unpickle 对象。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:163
msgid "Module Interface"
msgstr "模块接口"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:165
msgid ""
"To serialize an object hierarchy, you simply call the :func:`dumps` "
"function. Similarly, to de-serialize a data stream, you call the :func:"
"`loads` function. However, if you want more control over serialization and "
"de-serialization, you can create a :class:`Pickler` or an :class:`Unpickler` "
"object, respectively."
msgstr ""
"要序列化某个包含层次结构的对象，只需调用 :func:`dumps` 函数即可。同样，要反序"
"列化数据流，可以调用 :func:`loads` 函数。但是，如果要对序列化和反序列化加以更"
"多的控制，可以分别创建 :class:`Pickler` 或 :class:`Unpickler` 对象。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:170
msgid "The :mod:`pickle` module provides the following constants:"
msgstr ":mod:`pickle` 模块包含了以下常量："

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:175
msgid ""
"An integer, the highest :ref:`protocol version <pickle-protocols>` "
"available.  This value can be passed as a *protocol* value to functions :"
"func:`dump` and :func:`dumps` as well as the :class:`Pickler` constructor."
msgstr ""
"整数，可用的最高 :ref:`协议版本 <pickle-protocols>`。此值可以作为 *协议* 值传"
"递给 :func:`dump` 和 :func:`dumps` 函数，以及 :class:`Pickler` 的构造函数。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:182
msgid ""
"An integer, the default :ref:`protocol version <pickle-protocols>` used for "
"pickling.  May be less than :data:`HIGHEST_PROTOCOL`.  Currently the default "
"protocol is 3, a new protocol designed for Python 3."
msgstr ""
"一个整数，表示封存操作使用的 :ref:`协议版本 <pickle-protocols>`。 它可能小"
"于 :data:`HIGHEST_PROTOCOL`。 当前默认协议版本为 3，它是一个为 Python 3 设计"
"的新协议。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:187
msgid ""
"The :mod:`pickle` module provides the following functions to make the "
"pickling process more convenient:"
msgstr ":mod:`pickle` 模块提供了以下方法，让打包过程更加方便。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:192
msgid ""
"Write the pickled representation of the object *obj* to the open :term:`file "
"object` *file*.  This is equivalent to ``Pickler(file, protocol).dump(obj)``."
msgstr ""
"将打包好的对象 *obj* 写入已打开的 :term:`file object` *file*。它等同于 "
"``Pickler(file, protocol).dump(obj)``。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:196
#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:298
msgid ""
"The optional *protocol* argument, an integer, tells the pickler to use the "
"given protocol; supported protocols are 0 to :data:`HIGHEST_PROTOCOL`. If "
"not specified, the default is :data:`DEFAULT_PROTOCOL`.  If a negative "
"number is specified, :data:`HIGHEST_PROTOCOL` is selected."
msgstr ""
"可选参数 *protocol* 是一个整数，告知 pickler 使用指定的协议，可选择的协议范围"
"从 0 到 :data:`HIGHEST_PROTOCOL`。如果没有指定，这一参数默认值为 :data:"
"`DEFAULT_PROTOCOL`。指定一个负数就相当于指定 :data:`HIGHEST_PROTOCOL`。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:201
#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:303
msgid ""
"The *file* argument must have a write() method that accepts a single bytes "
"argument.  It can thus be an on-disk file opened for binary writing, an :"
"class:`io.BytesIO` instance, or any other custom object that meets this "
"interface."
msgstr ""
"参数 *file* 必须有一个 write() 方法，该 write() 方法要能接收字节作为其唯一参"
"数。因此，它可以是一个打开的磁盘文件（用于写入二进制内容），也可以是一个 :"
"class:`io.BytesIO` 实例，也可以是满足这一接口的其他任何自定义对象。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:206
#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:308
msgid ""
"If *fix_imports* is true and *protocol* is less than 3, pickle will try to "
"map the new Python 3 names to the old module names used in Python 2, so that "
"the pickle data stream is readable with Python 2."
msgstr ""
"如果 *fix_imports* 为 True 且 *protocol* 小于 3，pickle 将尝试将 Python 3 中"
"的新名称映射到 Python 2 中的旧模块名称，因此 Python 2 也可以读取打包出的数据"
"流。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:212
msgid ""
"Return the pickled representation of the object *obj* as a :class:`bytes` "
"object, instead of writing it to a file."
msgstr ""
"将 *obj* 打包以后的对象作为 :class:`bytes` 类型直接返回，而不是将其写入到文"
"件。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:215
msgid ""
"Arguments *protocol* and *fix_imports* have the same meaning as in :func:"
"`dump`."
msgstr ""
"参数 *protocol* 和 *fix_imports* 的含义与它们在 :func:`dump` 中的含义相同。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:220
msgid ""
"Read the pickled representation of an object from the open :term:`file "
"object` *file* and return the reconstituted object hierarchy specified "
"therein. This is equivalent to ``Unpickler(file).load()``."
msgstr ""
"从已打开的 :term:`file object` *文件* 中读取打包后的对象，重建其中特定对象的"
"层次结构并返回。它相当于 ``Unpickler(file).load()``。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:224
#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:250
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol "
"argument is needed.  Bytes past the pickled representation of the object are "
"ignored."
msgstr ""
"Pickle 协议版本是自动检测出来的，所以不需要参数来指定协议。打包对象以外的其他"
"字节将被忽略。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:228
msgid ""
"The argument *file* must have two methods, a read() method that takes an "
"integer argument, and a readline() method that requires no arguments.  Both "
"methods should return bytes.  Thus *file* can be an on-disk file opened for "
"binary reading, an :class:`io.BytesIO` object, or any other custom object "
"that meets this interface."
msgstr ""
"参数 *file* 必须有两个方法，其中 read() 方法接受一个整数参数，而 readline() "
"方法不需要参数。 两个方法都应返回字节串。 因此 *file* 可以是一个打开用于二进"
"制读取的磁盘文件、一个 :class:`io.BytesIO` 对象，或者任何满足此接口要求的其他"
"自定义对象。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:234
#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:254
msgid ""
"Optional keyword arguments are *fix_imports*, *encoding* and *errors*, which "
"are used to control compatibility support for pickle stream generated by "
"Python 2.  If *fix_imports* is true, pickle will try to map the old Python 2 "
"names to the new names used in Python 3.  The *encoding* and *errors* tell "
"pickle how to decode 8-bit string instances pickled by Python 2; these "
"default to 'ASCII' and 'strict', respectively.  The *encoding* can be "
"'bytes' to read these 8-bit string instances as bytes objects. Using "
"``encoding='latin1'`` is required for unpickling NumPy arrays and instances "
"of :class:`~datetime.datetime`, :class:`~datetime.date` and :class:"
"`~datetime.time` pickled by Python 2."
msgstr ""
"可选的关键字参数是 *fix_imports*, *encoding* 和 *errors*，用于控制由Python 2 "
"生成的 pickle 流的兼容性。如果 *fix_imports* 为 true，则 pickle 将尝试将旧的 "
"Python 2 名称映射到 Python 3 中对应的新名称。*encoding* 和 *errors* 参数告诉 "
"pickle 如何解码 Python 2 存储的 8 位字符串实例；这两个参数默认分别为 'ASCII' "
"和 'strict'。 *encoding* 参数可置为 'bytes' 来将这些 8 位字符串实例读取为字节"
"对象。读取 NumPy array 和 Python 2 存储的 :class:`~datetime.datetime`、:"
"class:`~datetime.date` 和 :class:`~datetime.time` 实例时，请使用 "
"``encoding='latin1'``。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:247
msgid ""
"Return the reconstituted object hierarchy of the pickled representation "
"*data* of an object. *data* must be a :term:`bytes-like object`."
msgstr ""
"重建并返回一个对象的封存表示形式 *data* 的对象层级结构。 *data* 必须为 :term:"
"`bytes-like object`。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:266
msgid "The :mod:`pickle` module defines three exceptions:"
msgstr ":mod:`pickle` 模块定义了以下 3 个异常："

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:270
msgid ""
"Common base class for the other pickling exceptions.  It inherits :exc:"
"`Exception`."
msgstr "其他 pickle 异常的基类。它是 :exc:`Exception` 的一个子类。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:275
msgid ""
"Error raised when an unpicklable object is encountered by :class:`Pickler`. "
"It inherits :exc:`PickleError`."
msgstr ""
"当 :class:`Pickler` 遇到无法解包的对象时抛出此错误。它是 :exc:`PickleError` "
"的子类。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:278
msgid ""
"Refer to :ref:`pickle-picklable` to learn what kinds of objects can be "
"pickled."
msgstr "参考 :ref:`pickle-picklable` 来了解哪些对象可以被打包。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:283
msgid ""
"Error raised when there is a problem unpickling an object, such as a data "
"corruption or a security violation.  It inherits :exc:`PickleError`."
msgstr ""
"当解包出错时抛出此异常，例如数据损坏或对象不安全。它是 :exc:`PickleError` 的"
"子类。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:286
msgid ""
"Note that other exceptions may also be raised during unpickling, including "
"(but not necessarily limited to) AttributeError, EOFError, ImportError, and "
"IndexError."
msgstr ""
"注意，解包时可能还会抛出其他异常，包括（但不限于） AttributeError、EOFError、"
"ImportError 和 IndexError。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:291
msgid ""
"The :mod:`pickle` module exports two classes, :class:`Pickler` and :class:"
"`Unpickler`:"
msgstr ""
":mod:`pickle` 模块可导出两个类，:class:`Pickler` 和 :class:`Unpickler`:"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:296
msgid "This takes a binary file for writing a pickle data stream."
msgstr "它接受一个二进制文件用于写入 pickle 数据流。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:314
msgid ""
"Write the pickled representation of *obj* to the open file object given in "
"the constructor."
msgstr ""
"将 *obj* 打包后的内容写入已打开的文件对象，该文件对象已经在构造函数中指定。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:319
msgid "Do nothing by default.  This exists so a subclass can override it."
msgstr "默认什么也不做。它存在是为了让子类可以重载它。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:321
msgid ""
"If :meth:`persistent_id` returns ``None``, *obj* is pickled as usual.  Any "
"other value causes :class:`Pickler` to emit the returned value as a "
"persistent ID for *obj*.  The meaning of this persistent ID should be "
"defined by :meth:`Unpickler.persistent_load`.  Note that the value returned "
"by :meth:`persistent_id` cannot itself have a persistent ID."
msgstr ""
"如果 :meth:`persistent_id` 返回 ``None``，*obj* 会被照常 pickle。如果返回其他"
"值，:class:`Pickler` 会将这个函数的返回值作为 *obj* 的持久化 ID（Pickler 本应"
"得到序列化数据流并将其写入文件，若此函数有返回值，则得到此函数的返回值并写入"
"文件）。这个持久化 ID 的解释应当定义在 :meth:`Unpickler.persistent_load` 中"
"（该方法定义还原对象的过程，并返回得到的对象）。注意，:meth:`persistent_id` "
"的返回值本身不能拥有持久化 ID。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:327
#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:399
msgid "See :ref:`pickle-persistent` for details and examples of uses."
msgstr "参阅 :ref:`pickle-persistent` 获取详情和使用示例。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:331
msgid ""
"A pickler object's dispatch table is a registry of *reduction functions* of "
"the kind which can be declared using :func:`copyreg.pickle`.  It is a "
"mapping whose keys are classes and whose values are reduction functions.  A "
"reduction function takes a single argument of the associated class and "
"should conform to the same interface as a :meth:`__reduce__` method."
msgstr ""
"Pickler 对象的 dispatch 表是 :func:`copyreg.pickle` 中用到的 *reduction 函数"
"* 的注册。dispatch 表本身是一个 class 到其 reduction 函数的映射键值对。一个 "
"reduction 函数只接受一个参数，就是其关联的 class，函数行为应当遵守 :meth:"
"`__reduce__` 接口规范。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:339
msgid ""
"By default, a pickler object will not have a :attr:`dispatch_table` "
"attribute, and it will instead use the global dispatch table managed by the :"
"mod:`copyreg` module. However, to customize the pickling for a specific "
"pickler object one can set the :attr:`dispatch_table` attribute to a dict-"
"like object.  Alternatively, if a subclass of :class:`Pickler` has a :attr:"
"`dispatch_table` attribute then this will be used as the default dispatch "
"table for instances of that class."
msgstr ""
"Pickler 对象默认并没有 :attr:`dispatch_table` 属性，该对象默认使用 :mod:"
"`copyreg` 模块中定义的全局 dispatch 表。如果要为特定 Pickler 对象自定义序列化"
"过程，可以将 :attr:`dispatch_table` 属性设置为类字典对象（dict-like "
"object）。另外，如果 :class:`Pickler` 的子类设置了 :attr:`dispatch_table` 属"
"性，则该子类的实例会使用这个表作为默认的 dispatch 表。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:348
msgid "See :ref:`pickle-dispatch` for usage examples."
msgstr "参阅 :ref:`pickle-dispatch` 获取使用示例。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:354
msgid ""
"Deprecated. Enable fast mode if set to a true value.  The fast mode disables "
"the usage of memo, therefore speeding the pickling process by not generating "
"superfluous PUT opcodes.  It should not be used with self-referential "
"objects, doing otherwise will cause :class:`Pickler` to recurse infinitely."
msgstr ""
"已弃用。设为 True 则启用快速模式。快速模式禁用了“备忘录” (memo) 的使用，即不"
"生成多余的 PUT 操作码来加快打包过程。不应将其与自指 (self-referential) 对象一"
"起使用，否则将导致 :class:`Pickler` 无限递归。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:360
msgid "Use :func:`pickletools.optimize` if you need more compact pickles."
msgstr ""
"如果需要进一步提高 pickle 的压缩率，请使用 :func:`pickletools.optimize`。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:365
msgid "This takes a binary file for reading a pickle data stream."
msgstr "它接受一个二进制文件用于读取 pickle 数据流。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:367
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol "
"argument is needed."
msgstr "Pickle 协议版本是自动检测出来的，所以不需要参数来指定协议。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:370
msgid ""
"The argument *file* must have two methods, a read() method that takes an "
"integer argument, and a readline() method that requires no arguments.  Both "
"methods should return bytes.  Thus *file* can be an on-disk file object "
"opened for binary reading, an :class:`io.BytesIO` object, or any other "
"custom object that meets this interface."
msgstr ""
"参数 *file* 必须有两个方法，其中 read() 方法接受一个整数参数，而 readline() "
"方法不需要参数。 两个方法都应返回字节串。 因此 *file* 可以是一个打开用于二进"
"制读取的磁盘文件对象、一个 :class:`io.BytesIO` 对象，或者任何满足此接口要求的"
"其他自定义对象。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:376
msgid ""
"Optional keyword arguments are *fix_imports*, *encoding* and *errors*, which "
"are used to control compatibility support for pickle stream generated by "
"Python 2.  If *fix_imports* is true, pickle will try to map the old Python 2 "
"names to the new names used in Python 3.  The *encoding* and *errors* tell "
"pickle how to decode 8-bit string instances pickled by Python 2; these "
"default to 'ASCII' and 'strict', respectively.  The *encoding* can be "
"'bytes' to read these 8-bit string instances as bytes objects."
msgstr ""
"可选的关键字参数有 *fix_imports*, *encoding* 和 *errors*，它们用于控制由 "
"Python 2 所生成 pickle 流的兼容性支持。 如果 *fix_imports* 为真值，则 pickle "
"将尝试把旧的 Python 2 名称映射到 Python 3 所使用的新名称。 *encoding* 和 "
"*errors* 将告知 pickle 如何解码由 Python 2 所封存的 8 位字符串实例；这两个参"
"数的默认值分别为 'ASCII' 和 'strict'。 *encoding* 可设为 'bytes' 以将这些 8 "
"位字符串实例作为字节对象来读取。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:386
msgid ""
"Read the pickled representation of an object from the open file object given "
"in the constructor, and return the reconstituted object hierarchy specified "
"therein.  Bytes past the pickled representation of the object are ignored."
msgstr ""
"从构造函数中指定的文件对象里读取打包好的对象，重建其中特定对象的层次结构并返"
"回。打包对象以外的其他字节将被忽略。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:393
msgid "Raise an :exc:`UnpicklingError` by default."
msgstr "默认抛出 :exc:`UnpicklingError` 异常。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:395
msgid ""
"If defined, :meth:`persistent_load` should return the object specified by "
"the persistent ID *pid*.  If an invalid persistent ID is encountered, an :"
"exc:`UnpicklingError` should be raised."
msgstr ""
"如果定义了此方法，:meth:`persistent_load` 应当返回持久化 ID *pid* 所指定的对"
"象。 如果遇到无效的持久化 ID，则应当引发 :exc:`UnpicklingError`。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:403
msgid ""
"Import *module* if necessary and return the object called *name* from it, "
"where the *module* and *name* arguments are :class:`str` objects.  Note, "
"unlike its name suggests, :meth:`find_class` is also used for finding "
"functions."
msgstr ""
"如有必要，导入 *module* 模块并返回其中名叫 *name* 的对象，其中 *module* 和 "
"*name* 参数都是 :class:`str` 对象。注意，不要被这个函数的名字迷惑，:meth:"
"`find_class` 同样可以用来导入函数。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:408
msgid ""
"Subclasses may override this to gain control over what type of objects and "
"how they can be loaded, potentially reducing security risks. Refer to :ref:"
"`pickle-restrict` for details."
msgstr ""
"子类可以重载此方法，来控制加载对象的类型和加载对象的方式，从而尽可能降低安全"
"风险。参阅 :ref:`pickle-restrict` 获取更详细的信息。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:416
msgid "What can be pickled and unpickled?"
msgstr "可以被打包/解包的对象"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:418
msgid "The following types can be pickled:"
msgstr "下列类型可以被打包："

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:420
msgid "``None``, ``True``, and ``False``"
msgstr "``None``、``True`` 和 ``False``"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:422
msgid "integers, floating point numbers, complex numbers"
msgstr "整数、浮点数、复数"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:424
msgid "strings, bytes, bytearrays"
msgstr "str、byte、bytearray"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:426
msgid "tuples, lists, sets, and dictionaries containing only picklable objects"
msgstr "只包含可打包对象的集合，包括 tuple、list、set 和 dict"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:428
msgid ""
"functions defined at the top level of a module (using :keyword:`def`, not :"
"keyword:`lambda`)"
msgstr ""
"定义在模块顶层的函数（使用 :keyword:`def` 定义，:keyword:`lambda` 函数则不可"
"以）"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:431
msgid "built-in functions defined at the top level of a module"
msgstr "定义在模块顶层的内置函数"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:433
msgid "classes that are defined at the top level of a module"
msgstr "定义在模块顶层的类"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:435
msgid ""
"instances of such classes whose :attr:`~object.__dict__` or the result of "
"calling :meth:`__getstate__` is picklable  (see section :ref:`pickle-inst` "
"for details)."
msgstr ""
"某些类实例，这些类的 :attr:`~object.__dict__` 属性值或 :meth:`__getstate__` "
"函数的返回值可以被打包（详情参阅 :ref:`pickle-inst` 这一段）。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:439
msgid ""
"Attempts to pickle unpicklable objects will raise the :exc:`PicklingError` "
"exception; when this happens, an unspecified number of bytes may have "
"already been written to the underlying file.  Trying to pickle a highly "
"recursive data structure may exceed the maximum recursion depth, a :exc:"
"`RecursionError` will be raised in this case.  You can carefully raise this "
"limit with :func:`sys.setrecursionlimit`."
msgstr ""
"尝试打包不能被打包的对象会抛出 :exc:`PicklingError` 异常，异常发生时，可能有"
"部分字节已经被写入指定文件中。尝试打包递归层级很深的对象时，可能会超出最大递"
"归层级限制，此时会抛出 :exc:`RecursionError` 异常，可以通过 :func:`sys."
"setrecursionlimit` 调整递归层级，不过请谨慎使用这个函数，因为可能会导致解释器"
"崩溃。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:446
msgid ""
"Note that functions (built-in and user-defined) are pickled by \"fully "
"qualified\" name reference, not by value. [#]_  This means that only the "
"function name is pickled, along with the name of the module the function is "
"defined in.  Neither the function's code, nor any of its function attributes "
"are pickled.  Thus the defining module must be importable in the unpickling "
"environment, and the module must contain the named object, otherwise an "
"exception will be raised. [#]_"
msgstr ""
"注意，函数（内建函数或用户自定义函数）在被打包时，引用的是函数全名。[#]_ 这意"
"味着只有函数所在的模块名，与函数名会被打包，函数体及其属性不会被打包。因此，"
"在解包的环境中，函数所属的模块必须是可以被导入的，而且模块必须包含这个函数被"
"打包时的名称，否则会抛出异常。[#]_"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:453
msgid ""
"Similarly, classes are pickled by named reference, so the same restrictions "
"in the unpickling environment apply.  Note that none of the class's code or "
"data is pickled, so in the following example the class attribute ``attr`` is "
"not restored in the unpickling environment::"
msgstr ""
"同样的，类也只打包名称，所以在解包环境中也有和函数相同的限制。注意，类体及其"
"数据不会被打包，所以在下面的例子中类属性 ``attr`` 不会存在于解包后的环境中："

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:463
msgid ""
"These restrictions are why picklable functions and classes must be defined "
"in the top level of a module."
msgstr "这些限制决定了为什么必须在一个模块的顶层定义可打包的函数和类。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:466
msgid ""
"Similarly, when class instances are pickled, their class's code and data are "
"not pickled along with them.  Only the instance data are pickled.  This is "
"done on purpose, so you can fix bugs in a class or add methods to the class "
"and still load objects that were created with an earlier version of the "
"class.  If you plan to have long-lived objects that will see many versions "
"of a class, it may be worthwhile to put a version number in the objects so "
"that suitable conversions can be made by the class's :meth:`__setstate__` "
"method."
msgstr ""
"类似的，在打包类的实例时，其类体和类数据不会跟着实例一起被打包，只有实例数据"
"会被打包。这样设计是有目的的，在将来修复类中的错误、给类增加方法之后，仍然可"
"以载入原来版本类实例的打包数据来还原该实例。如果你准备长期使用一个对象，可能"
"会同时存在较多版本的类体，可以为对象添加版本号，这样就可以通过类的 :meth:"
"`__setstate__` 方法将老版本转换成新版本。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:478
msgid "Pickling Class Instances"
msgstr "打包类实例"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:482
msgid ""
"In this section, we describe the general mechanisms available to you to "
"define, customize, and control how class instances are pickled and unpickled."
msgstr ""
"在本节中，我们描述了可用于定义、自定义和控制如何打包和解包类实例的通用流程。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:485
msgid ""
"In most cases, no additional code is needed to make instances picklable.  By "
"default, pickle will retrieve the class and the attributes of an instance "
"via introspection. When a class instance is unpickled, its :meth:`__init__` "
"method is usually *not* invoked.  The default behaviour first creates an "
"uninitialized instance and then restores the saved attributes.  The "
"following code shows an implementation of this behaviour::"
msgstr ""
"通常，使一个实例可被打包不需要附加任何代码。Pickle 默认会通过 Python 的内省机"
"制获得实例的类及属性。而当实例解包时，它的 :meth:`__init__` 方法通常 *不会* "
"被调用。其默认动作是：先创建一个未初始化的实例，然后还原其属性，下面的代码展"
"示了这种行为的实现机制："

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:500
msgid ""
"Classes can alter the default behaviour by providing one or several special "
"methods:"
msgstr "类可以改变默认行为，只需定义以下一种或几种特殊方法："

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:505
msgid ""
"In protocols 2 and newer, classes that implements the :meth:"
"`__getnewargs_ex__` method can dictate the values passed to the :meth:"
"`__new__` method upon unpickling.  The method must return a pair ``(args, "
"kwargs)`` where *args* is a tuple of positional arguments and *kwargs* a "
"dictionary of named arguments for constructing the object.  Those will be "
"passed to the :meth:`__new__` method upon unpickling."
msgstr ""
"对于使用第 2 版或更高版协议的 pickle，实现了 :meth:`__getnewargs_ex__` 方法的"
"类可以控制在解包时传给 :meth:`__new__` 方法的参数。本方法必须返回一对 "
"``(args, kwargs)`` 用于构建对象，其中 *args* 是表示位置参数的 tuple，而 "
"*kwargs* 是表示命名参数的 dict。它们会在解包时传递给 :meth:`__new__` 方法。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:513
msgid ""
"You should implement this method if the :meth:`__new__` method of your class "
"requires keyword-only arguments.  Otherwise, it is recommended for "
"compatibility to implement :meth:`__getnewargs__`."
msgstr ""
"如果类的 :meth:`__new__` 方法只接受关键字参数，则应当实现这个方法。否则，为了"
"兼容性，更推荐实现 :meth:`__getnewargs__` 方法。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:517
msgid ":meth:`__getnewargs_ex__` is now used in protocols 2 and 3."
msgstr ":meth:`__getnewargs_ex__` 现在可用于第 2 和第 3 版协议。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:523
msgid ""
"This method serves a similar purpose as :meth:`__getnewargs_ex__`, but "
"supports only positional arguments.  It must return a tuple of arguments "
"``args`` which will be passed to the :meth:`__new__` method upon unpickling."
msgstr ""
"这个方法与上一个 :meth:`__getnewargs_ex__` 方法类似，但仅支持位置参数。它要求"
"返回一个 tuple 类型的 ``args``，用于解包时传递给 :meth:`__new__` 方法。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:527
msgid ""
":meth:`__getnewargs__` will not be called if :meth:`__getnewargs_ex__` is "
"defined."
msgstr ""
"如果定义了 :meth:`__getnewargs_ex__`，那么 :meth:`__getnewargs__` 就不会被调"
"用。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:530
msgid ""
"Before Python 3.6, :meth:`__getnewargs__` was called instead of :meth:"
"`__getnewargs_ex__` in protocols 2 and 3."
msgstr ""
"在 Python 3.6 前，第 2、3 版协议会调用 :meth:`__getnewargs__`，更高版本协议会"
"调用 :meth:`__getnewargs_ex__`。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:537
msgid ""
"Classes can further influence how their instances are pickled; if the class "
"defines the method :meth:`__getstate__`, it is called and the returned "
"object is pickled as the contents for the instance, instead of the contents "
"of the instance's dictionary.  If the :meth:`__getstate__` method is absent, "
"the instance's :attr:`~object.__dict__` is pickled as usual."
msgstr ""
"类还可以进一步控制其实例的打包过程。如果类定义了 :meth:`__getstate__`，它就会"
"被调用，其返回的对象是被当做实例内容来打包的，否则打包的是实例的 __dict__。如"
"果 :meth:`__getstate__` 未定义，实例的 :attr:`~object.__dict__` 会被照常打"
"包。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:546
msgid ""
"Upon unpickling, if the class defines :meth:`__setstate__`, it is called "
"with the unpickled state.  In that case, there is no requirement for the "
"state object to be a dictionary.  Otherwise, the pickled state must be a "
"dictionary and its items are assigned to the new instance's dictionary."
msgstr ""
"当解包时，如果类定义了 :meth:`__setstate__`，就会在已解包状态下调用它。此时不"
"要求实例的 state 对象必须是 dict。没有定义此方法的话，先前打包的 state 对象必"
"须是 dict，且该 dict 内容会在解包时赋给新实例的 __dict__。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:553
msgid ""
"If :meth:`__getstate__` returns a false value, the :meth:`__setstate__` "
"method will not be called upon unpickling."
msgstr ""
"如果 :meth:`__getstate__` 返回 False，那么在解包时就不会调用 :meth:"
"`__setstate__` 方法。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:557
msgid ""
"Refer to the section :ref:`pickle-state` for more information about how to "
"use the methods :meth:`__getstate__` and :meth:`__setstate__`."
msgstr ""
"参考 :ref:`pickle-state` 一段获取如何使用 :meth:`__getstate__` 和 :meth:"
"`__setstate__` 方法的更多信息。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:562
msgid ""
"At unpickling time, some methods like :meth:`__getattr__`, :meth:"
"`__getattribute__`, or :meth:`__setattr__` may be called upon the instance.  "
"In case those methods rely on some internal invariant being true, the type "
"should implement :meth:`__new__` to establish such an invariant, as :meth:"
"`__init__` is not called when unpickling an instance."
msgstr ""
"在解封时，实例的某些方法例如 :meth:`__getattr__`, :meth:`__getattribute__` "
"或 :meth:`__setattr__` 可能会被调用。 由于这些方法可能要求某些内部不变量为真"
"值，因此该类型应当实现 :meth:`__new__` 以建立这样的不变量，因为当解封一个实例"
"时 :meth:`__init__` 并不会被调用。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:571
msgid ""
"As we shall see, pickle does not use directly the methods described above.  "
"In fact, these methods are part of the copy protocol which implements the :"
"meth:`__reduce__` special method.  The copy protocol provides a unified "
"interface for retrieving the data necessary for pickling and copying "
"objects. [#]_"
msgstr ""
"可以看出，其实 pickle 并不直接调用上面的几个函数。事实上，这几个函数是复制协"
"议的一部分，它们实现了 :meth:`__reduce__` 这一特殊接口。复制协议提供了统一的"
"接口，用于在打包或复制对象的过程中取得所需数据。[#]_"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:577
msgid ""
"Although powerful, implementing :meth:`__reduce__` directly in your classes "
"is error prone.  For this reason, class designers should use the high-level "
"interface (i.e., :meth:`__getnewargs_ex__`, :meth:`__getstate__` and :meth:"
"`__setstate__`) whenever possible.  We will show, however, cases where "
"using :meth:`__reduce__` is the only option or leads to more efficient "
"pickling or both."
msgstr ""
"尽管这个协议功能很强，但是直接在类中实现 :meth:`__reduce__` 接口容易产生错"
"误。因此，设计类时应当尽可能的使用高级接口（比如 :meth:`__getnewargs_ex__`、:"
"meth:`__getstate__` 和 :meth:`__setstate__`）。后面仍然可以看到直接实现 :"
"meth:`__reduce__` 接口的状况，可能别无他法，可能为了获得更好的性能，或者两者"
"皆有之。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:586
msgid ""
"The interface is currently defined as follows.  The :meth:`__reduce__` "
"method takes no argument and shall return either a string or preferably a "
"tuple (the returned object is often referred to as the \"reduce value\")."
msgstr ""
"该接口当前定义如下。:meth:`__reduce__` 方法不带任何参数，并且应返回字符串或最"
"好返回一个元组（返回的对象通常称为“reduce 值”）。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:590
msgid ""
"If a string is returned, the string should be interpreted as the name of a "
"global variable.  It should be the object's local name relative to its "
"module; the pickle module searches the module namespace to determine the "
"object's module.  This behaviour is typically useful for singletons."
msgstr ""
"如果返回字符串，该字符串会被当做一个全局变量的名称。它应该是对象相对于其模块"
"的本地名称，pickle 模块会搜索模块命名空间来确定对象所属的模块。这种行为常在单"
"例模式使用。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:595
msgid ""
"When a tuple is returned, it must be between two and five items long. "
"Optional items can either be omitted, or ``None`` can be provided as their "
"value.  The semantics of each item are in order:"
msgstr ""
"当返回的是一个元组时，它的长度必须在二至五项之间。 可选项可以被省略或将值设"
"为 ``None``。 每项的语义分别如下所示："

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:601
msgid ""
"A callable object that will be called to create the initial version of the "
"object."
msgstr "一个可调用对象，该对象会在创建对象的最初版本时调用。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:604
msgid ""
"A tuple of arguments for the callable object.  An empty tuple must be given "
"if the callable does not accept any argument."
msgstr ""
"可调用对象的参数，是一个元组。如果可调用对象不接受参数，必须提供一个空元组。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:607
msgid ""
"Optionally, the object's state, which will be passed to the object's :meth:"
"`__setstate__` method as previously described.  If the object has no such "
"method then, the value must be a dictionary and it will be added to the "
"object's :attr:`~object.__dict__` attribute."
msgstr ""
"可选元素，用于表示对象的状态，将被传给前述的 :meth:`__setstate__` 方法。 如果"
"对象没有此方法，则这个元素必须是字典类型，并会被添加至 :attr:`~object."
"__dict__` 属性中。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:612
msgid ""
"Optionally, an iterator (and not a sequence) yielding successive items. "
"These items will be appended to the object either using ``obj.append(item)`` "
"or, in batch, using ``obj.extend(list_of_items)``. This is primarily used "
"for list subclasses, but may be used by other classes as long as they have :"
"meth:`append` and :meth:`extend` methods with the appropriate signature.  "
"(Whether :meth:`append` or :meth:`extend` is used depends on which pickle "
"protocol version is used as well as the number of items to append, so both "
"must be supported.)"
msgstr ""
"可选元素，一个返回连续项的迭代器（而不是序列）。这些项会被 ``obj."
"append(item)`` 逐个加入对象，或被 ``obj.extend(list_of_items)`` 批量加入对"
"象。这个元素主要用于 list 的子类，也可以用于那些正确实现了 :meth:`append` "
"和 :meth:`extend` 方法的类。（具体是使用 :meth:`append` 还是 :meth:`extend` "
"取决于 pickle 协议版本以及待插入元素的项数，所以这两个方法必须同时被类支"
"持。）"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:621
msgid ""
"Optionally, an iterator (not a sequence) yielding successive key-value "
"pairs.  These items will be stored to the object using ``obj[key] = "
"value``.  This is primarily used for dictionary subclasses, but may be used "
"by other classes as long as they implement :meth:`__setitem__`."
msgstr ""
"可选元素，一个返回连续键值对的迭代器（而不是序列）。这些键值对将会以 "
"``obj[key] = value`` 的方式存储于对象中。该元素主要用于 dict 子类，也可以用于"
"那些实现了 :meth:`__setitem__` 的类。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:629
msgid ""
"Alternatively, a :meth:`__reduce_ex__` method may be defined.  The only "
"difference is this method should take a single integer argument, the "
"protocol version.  When defined, pickle will prefer it over the :meth:"
"`__reduce__` method.  In addition, :meth:`__reduce__` automatically becomes "
"a synonym for the extended version.  The main use for this method is to "
"provide backwards-compatible reduce values for older Python releases."
msgstr ""
"作为替代选项，也可以实现 :meth:`__reduce_ex__` 方法。 此方法的唯一不同之处在"
"于它应接受一个整型参数用于指定协议版本。 如果定义了这个函数，则会覆盖 :meth:"
"`__reduce__` 的行为。 此外，:meth:`__reduce__` 方法会自动成为扩展版方法的同义"
"词。 这个函数主要用于为以前的 Python 版本提供向后兼容的 reduce 值。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:641
msgid "Persistence of External Objects"
msgstr "持久化外部对象"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:647
msgid ""
"For the benefit of object persistence, the :mod:`pickle` module supports the "
"notion of a reference to an object outside the pickled data stream.  Such "
"objects are referenced by a persistent ID, which should be either a string "
"of alphanumeric characters (for protocol 0) [#]_ or just an arbitrary object "
"(for any newer protocol)."
msgstr ""
"为了获取对象持久化的利益， :mod:`pickle` 模块支持引用已封存数据流之外的对"
"象。 这样的对象是通过一个持久化 ID 来引用的，它应当是一个由字母数字类字符组成"
"的字符串 (对于第 0 版协议) [#]_ 或是一个任意对象 (用于任意新版协议)。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:653
msgid ""
"The resolution of such persistent IDs is not defined by the :mod:`pickle` "
"module; it will delegate this resolution to the user-defined methods on the "
"pickler and unpickler, :meth:`~Pickler.persistent_id` and :meth:`~Unpickler."
"persistent_load` respectively."
msgstr ""
":mod:`pickle` 模块不提供对持久化 ID 的解析工作，它将解析工作分配给用户定义的"
"方法，分别是 pickler 中的 :meth:`~Pickler.persistent_id` 方法和 unpickler 中"
"的 :meth:`~Unpickler.persistent_load` 方法。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:658
msgid ""
"To pickle objects that have an external persistent ID, the pickler must have "
"a custom :meth:`~Pickler.persistent_id` method that takes an object as an "
"argument and returns either ``None`` or the persistent ID for that object. "
"When ``None`` is returned, the pickler simply pickles the object as normal. "
"When a persistent ID string is returned, the pickler will pickle that "
"object, along with a marker so that the unpickler will recognize it as a "
"persistent ID."
msgstr ""
"要通过持久化 ID 将外部对象打包，必须在 pickler 中实现 :meth:`~Pickler."
"persistent_id` 方法，该方法接受需要被打包的对象作为参数，返回一个 ``None`` 或"
"返回该对象的持久化 ID。如果返回 ``None``，该对象会被按照默认方式打包为数据"
"流。如果返回字符串形式的持久化 ID，则会打包这个字符串和一个标记，这样 "
"unpickler 才能将其识别为持久化 ID。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:665
msgid ""
"To unpickle external objects, the unpickler must have a custom :meth:"
"`~Unpickler.persistent_load` method that takes a persistent ID object and "
"returns the referenced object."
msgstr ""
"要解封外部对象，Unpickler 必须实现 :meth:`~Unpickler.persistent_load` 方法，"
"接受一个持久化 ID 对象作为参数并返回一个引用的对象。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:669
msgid ""
"Here is a comprehensive example presenting how persistent ID can be used to "
"pickle external objects by reference."
msgstr "下面是一个全面的例子，展示了如何使用持久化 ID 来封存外部对象。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:677
msgid "Dispatch Tables"
msgstr "Dispatch 表"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:679
msgid ""
"If one wants to customize pickling of some classes without disturbing any "
"other code which depends on pickling, then one can create a pickler with a "
"private dispatch table."
msgstr ""
"如果想对某些类进行自定义封存，而又不想在类中增加用于封存的代码，就可以创建带"
"有特殊 dispatch 表的 pickler。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:683
msgid ""
"The global dispatch table managed by the :mod:`copyreg` module is available "
"as :data:`copyreg.dispatch_table`.  Therefore, one may choose to use a "
"modified copy of :data:`copyreg.dispatch_table` as a private dispatch table."
msgstr ""
"在 :mod:`copyreg` 模块的 :data:`copyreg.dispatch_table` 中定义了全局 "
"dispatch 表。因此，可以使用 :data:`copyreg.dispatch_table` 修改后的副本作为自"
"有 dispatch 表。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:688
msgid "For example ::"
msgstr "例如："

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:695
msgid ""
"creates an instance of :class:`pickle.Pickler` with a private dispatch table "
"which handles the ``SomeClass`` class specially.  Alternatively, the code ::"
msgstr ""
"创建了一个带有自有 dispatch 表的 :class:`pickle.Pickler` 实例，它可以对 "
"``SomeClass`` 类进行特殊处理。另外，下列代码："

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:705
msgid ""
"does the same, but all instances of ``MyPickler`` will by default share the "
"same dispatch table.  The equivalent code using the :mod:`copyreg` module "
"is ::"
msgstr ""
"完成了相同的操作，但所有 ``MyPickler`` 的实例都会共用同一份 dispatch 表。使"
"用 :mod:`copyreg` 模块实现的等效代码是："

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:716
msgid "Handling Stateful Objects"
msgstr "处理有状态的对象"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:722
msgid ""
"Here's an example that shows how to modify pickling behavior for a class. "
"The :class:`TextReader` class opens a text file, and returns the line number "
"and line contents each time its :meth:`!readline` method is called. If a :"
"class:`TextReader` instance is pickled, all attributes *except* the file "
"object member are saved. When the instance is unpickled, the file is "
"reopened, and reading resumes from the last location. The :meth:"
"`__setstate__` and :meth:`__getstate__` methods are used to implement this "
"behavior. ::"
msgstr ""
"下面的示例展示了如何修改类在封存时的行为。其中 :class:`TextReader` 类打开了一"
"个文本文件，每次调用其 :meth:`!readline` 方法则返回行号和该行的字符。 在封存"
"这个 :class:`TextReader` 的实例时，*除了* 文件对象，其他属性都会被保存。 当解"
"封实例时，需要重新打开文件，然后从上次的位置开始继续读取。实现这些功能需要实"
"现 :meth:`__setstate__` 和 :meth:`__getstate__` 方法。 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:768
msgid "A sample usage might be something like this::"
msgstr "使用方法如下所示："

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:783
msgid "Restricting Globals"
msgstr "限制全局变量"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:788
msgid ""
"By default, unpickling will import any class or function that it finds in "
"the pickle data.  For many applications, this behaviour is unacceptable as "
"it permits the unpickler to import and invoke arbitrary code.  Just consider "
"what this hand-crafted pickle data stream does when loaded::"
msgstr ""
"默认情况下，解封将会导入在 pickle 数据中找到的任何类或函数。 对于许多应用来"
"说，此行为是不可接受的，因为它会允许解封器导入并发起调用任意代码。 只须考虑当"
"这个手工构建的 pickle 数据流被加载时会做什么::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:798
msgid ""
"In this example, the unpickler imports the :func:`os.system` function and "
"then apply the string argument \"echo hello world\".  Although this example "
"is inoffensive, it is not difficult to imagine one that could damage your "
"system."
msgstr ""
"在这个例子里，解封器导入 :func:`os.system` 函数然后应用字符串参数 \"echo "
"hello world\"。 虽然这个例子不具攻击性，但是不难想象别人能够通过此方式对你的"
"系统造成损害。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:802
msgid ""
"For this reason, you may want to control what gets unpickled by customizing :"
"meth:`Unpickler.find_class`.  Unlike its name suggests, :meth:`Unpickler."
"find_class` is called whenever a global (i.e., a class or a function) is "
"requested.  Thus it is possible to either completely forbid globals or "
"restrict them to a safe subset."
msgstr ""
"出于这样的理由，你可能会希望通过定制 :meth:`Unpickler.find_class` 来控制要解"
"封的对象。 与其名称所提示的不同，:meth:`Unpickler.find_class` 会在执行对任何"
"全局对象（例如一个类或一个函数）的请求时被调用。 因此可以完全禁止全局对象或是"
"将它们限制在一个安全的子集中。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:808
msgid ""
"Here is an example of an unpickler allowing only few safe classes from the :"
"mod:`builtins` module to be loaded::"
msgstr ""
"下面的例子是一个解封器，它只允许某一些安全的来自 :mod:`builtins` 模块的类被加"
"载::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:837
msgid "A sample usage of our unpickler working has intended::"
msgstr "我们这个解封器的一个示例用法所达成的目标::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:856
msgid ""
"As our examples shows, you have to be careful with what you allow to be "
"unpickled.  Therefore if security is a concern, you may want to consider "
"alternatives such as the marshalling API in :mod:`xmlrpc.client` or third-"
"party solutions."
msgstr ""
"正如我们这个例子所显示的，对于允许解封的对象你必须要保持谨慎。 因此如果要保证"
"安全，你可以考虑其他选择例如 :mod:`xmlrpc.client` 中的编组 API 或是第三方解决"
"方案。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:863
msgid "Performance"
msgstr "性能"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:865
msgid ""
"Recent versions of the pickle protocol (from protocol 2 and upwards) feature "
"efficient binary encodings for several common features and built-in types. "
"Also, the :mod:`pickle` module has a transparent optimizer written in C."
msgstr ""
"较新版本的 pickle 协议（第 2 版或更高）具有针对某些常见特性和内置类型的高效二"
"进制编码格式。 此外，:mod:`pickle` 模块还拥有一个以 C 编写的透明优化器。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:873
msgid "Examples"
msgstr "例子"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:875
msgid ""
"For the simplest code, use the :func:`dump` and :func:`load` functions. ::"
msgstr "对于最简单的代码，请使用 :func:`dump` 和 :func:`load` 函数。 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:891
msgid "The following example reads the resulting pickled data. ::"
msgstr "以下示例读取之前封存的数据。 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:908
msgid "Module :mod:`copyreg`"
msgstr "模块 :mod:`copyreg`"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:908
msgid "Pickle interface constructor registration for extension types."
msgstr "为扩展类型提供 pickle 接口所需的构造函数。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:911
msgid "Module :mod:`pickletools`"
msgstr "模块 :mod:`pickletools`"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:911
msgid "Tools for working with and analyzing pickled data."
msgstr "用于处理和分析已打包数据的工具。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:914
msgid "Module :mod:`shelve`"
msgstr "模块 :mod:`shelve`"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:914
msgid "Indexed databases of objects; uses :mod:`pickle`."
msgstr "带索引的数据库，用于存放对象，使用了 :mod:`pickle` 模块。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:917
msgid "Module :mod:`copy`"
msgstr "模块 :mod:`copy`"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:917
msgid "Shallow and deep object copying."
msgstr "浅层 (shallow) 和深层 (deep) 复制对象操作"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:919
msgid "Module :mod:`marshal`"
msgstr "模块 :mod:`marshal`"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:920
msgid "High-performance serialization of built-in types."
msgstr "高效地序列化内置类型的数据。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:924
msgid "Footnotes"
msgstr "备注"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:925
msgid "Don't confuse this with the :mod:`marshal` module"
msgstr "不要把它与 :mod:`marshal` 模块混淆。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:927
msgid ""
"This is why :keyword:`lambda` functions cannot be pickled:  all :keyword:`!"
"lambda` functions share the same name:  ``<lambda>``."
msgstr ""
"这就是为什么 :keyword:`lambda` 函数不可以被打包：所有的匿名函数都有同一个名"
"字：``<lambda>``。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:930
msgid ""
"The exception raised will likely be an :exc:`ImportError` or an :exc:"
"`AttributeError` but it could be something else."
msgstr ""
"抛出的异常有可能是 :exc:`ImportError` 或 :exc:`AttributeError`，也可能是其他"
"异常。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:933
msgid ""
"The :mod:`copy` module uses this protocol for shallow and deep copying "
"operations."
msgstr ""
":mod:`copy` 模块使用这一协议实现浅层 (shallow) 和深层 (deep) 复制操作。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/pickle.rst:936
msgid ""
"The limitation on alphanumeric characters is due to the fact the persistent "
"IDs, in protocol 0, are delimited by the newline character.  Therefore if "
"any kind of newline characters occurs in persistent IDs, the resulting "
"pickle will become unreadable."
msgstr ""
"对字母数字类字符的限制是由于持久化 ID 在协议版本 0 中是由分行符来分隔的。 因"
"此如果持久化 ID 中出现任何形式的分行符，封存结果就将变得无法读取。"
