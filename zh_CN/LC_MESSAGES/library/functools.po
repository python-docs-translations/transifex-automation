# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# ww song <sww4718168@gmail.com>, 2019
# zc Jin <zhengcao.jin@gmail.com>, 2019
# Konge <zkonge@outlook.com>, 2019
# dannyvi <dannyvis@icloud.com>, 2019
# MuSheng Chen <sheng.2179@gmail.com>, 2019
# akira asura <i@001.moe>, 2019
# Makdon <makdon@makdon.me>, 2019
# MustAndy <andy20030901@126.com>, 2019
# Freesand Leo <yuqinju@163.com>, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-06-16 16:41+0000\n"
"PO-Revision-Date: 2019-09-01 03:21+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2022\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/"
"teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:2
msgid ""
":mod:`functools` --- Higher-order functions and operations on callable "
"objects"
msgstr ":mod:`functools` --- 高阶函数和可调用对象上的操作"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:13
msgid "**Source code:** :source:`Lib/functools.py`"
msgstr "**源代码:** :source:`Lib/functools.py`"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:17
msgid ""
"The :mod:`functools` module is for higher-order functions: functions that "
"act on or return other functions. In general, any callable object can be "
"treated as a function for the purposes of this module."
msgstr ""
":mod:`functools` 模块应用于高阶函数，即——参数或（和）返回值为其他函数的函数。"
"通常来说，此模块的功能适用于所有可调用对象。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:21
msgid "The :mod:`functools` module defines the following functions:"
msgstr ":mod:`functools` 模块定义了以下函数:"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:25
msgid ""
"Transform an old-style comparison function to a :term:`key function`.  Used "
"with tools that accept key functions (such as :func:`sorted`, :func:`min`, :"
"func:`max`, :func:`heapq.nlargest`, :func:`heapq.nsmallest`, :func:"
"`itertools.groupby`).  This function is primarily used as a transition tool "
"for programs being converted from Python 2 which supported the use of "
"comparison functions."
msgstr ""
"将(旧式的)比较函数转换为新式的 :term:`key function` .  在类似于 :func:"
"`sorted` ， :func:`min` ， :func:`max` ， :func:`heapq.nlargest` ， :func:"
"`heapq.nsmallest` ， :func:`itertools.groupby` 等函数的 `key` 参数中使用。此"
"函数主要用作将 Python 2 程序转换至新版的转换工具，以保持对比较函数的兼容。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:32
msgid ""
"A comparison function is any callable that accept two arguments, compares "
"them, and returns a negative number for less-than, zero for equality, or a "
"positive number for greater-than.  A key function is a callable that accepts "
"one argument and returns another value to be used as the sort key."
msgstr ""
"比较函数意为一个可调用对象，该对象接受两个参数并比较它们，结果为小于则返回一"
"个负数，相等则返回零，大于则返回一个正数。key function则是一个接受一个参数，"
"并返回另一个用以排序的值的可调用对象。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:37
#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:231
msgid "Example::"
msgstr "示例::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:41
msgid ""
"For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr "有关排序示例和简要排序教程，请参阅 :ref:`sortinghowto` 。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:48
msgid ""
"Decorator to wrap a function with a memoizing callable that saves up to the "
"*maxsize* most recent calls.  It can save time when an expensive or I/O "
"bound function is periodically called with the same arguments."
msgstr ""
"一个为函数提供缓存功能的装饰器，缓存 *maxsize* 组传入参数，在下次以相同参数调"
"用时直接返回上一次的结果。用以节约高开销或I/O函数的调用时间。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:52
msgid ""
"Since a dictionary is used to cache results, the positional and keyword "
"arguments to the function must be hashable."
msgstr ""
"由于使用了字典存储缓存，所以该函数的固定参数和关键字参数必须是可哈希的。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:55
msgid ""
"Distinct argument patterns may be considered to be distinct calls with "
"separate cache entries.  For example, `f(a=1, b=2)` and `f(b=2, a=1)` differ "
"in their keyword argument order and may have two separate cache entries."
msgstr ""
"不同模式的参数可能被视为不同从而产生多个缓存项，例如, `f(a=1, b=2)` 和 "
"`f(b=2, a=1)` 因其参数顺序不同，可能会被缓存两次。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:60
msgid ""
"If *maxsize* is set to ``None``, the LRU feature is disabled and the cache "
"can grow without bound.  The LRU feature performs best when *maxsize* is a "
"power-of-two."
msgstr ""
"如果 *maxsize* 设置为 ``None`` ，LRU功能将被禁用且缓存数量无上限。 *maxsize* "
"设置为2的幂时可获得最佳性能。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:64
msgid ""
"If *typed* is set to true, function arguments of different types will be "
"cached separately.  For example, ``f(3)`` and ``f(3.0)`` will be treated as "
"distinct calls with distinct results."
msgstr ""
"如果 *typed* 设置为true，不同类型的函数参数将被分别缓存。例如， ``f(3)`` 和 "
"``f(3.0)`` 将被视为不同而分别缓存。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:68
msgid ""
"To help measure the effectiveness of the cache and tune the *maxsize* "
"parameter, the wrapped function is instrumented with a :func:`cache_info` "
"function that returns a :term:`named tuple` showing *hits*, *misses*, "
"*maxsize* and *currsize*.  In a multi-threaded environment, the hits and "
"misses are approximate."
msgstr ""
"为了衡量缓存的有效性以便调整 *maxsize* 形参，被装饰的函数带有一个 :func:"
"`cache_info` 函数。当调用 :func:`cache_info` 函数时，返回一个具名元组，包含命"
"中次数 *hits*，未命中次数 *misses* ，最大缓存数量 *maxsize* 和 当前缓存大小 "
"*currsize*。在多线程环境中，命中数与未命中数是不完全准确的。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:74
msgid ""
"The decorator also provides a :func:`cache_clear` function for clearing or "
"invalidating the cache."
msgstr "该装饰器也提供了一个用于清理/使缓存失效的函数 :func:`cache_clear` 。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:77
msgid ""
"The original underlying function is accessible through the :attr:"
"`__wrapped__` attribute.  This is useful for introspection, for bypassing "
"the cache, or for rewrapping the function with a different cache."
msgstr ""
"原始的未经装饰的函数可以通过 :attr:`__wrapped__` 属性访问。它可以用于检查、绕"
"过缓存，或使用不同的缓存再次装饰原始函数。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:81
msgid ""
"An `LRU (least recently used) cache <https://en.wikipedia.org/wiki/"
"Cache_algorithms#Examples>`_ works best when the most recent calls are the "
"best predictors of upcoming calls (for example, the most popular articles on "
"a news server tend to change each day). The cache's size limit assures that "
"the cache does not grow without bound on long-running processes such as web "
"servers."
msgstr ""
"`“最久未使用算法”（LRU）缓存 <https://en.wikipedia.org/wiki/"
"Cache_algorithms#Examples>`_ 在“最近的调用是即将到来的调用的最佳预测因子”时性"
"能最好（比如，新闻服务器上最受欢迎的文章倾向于每天更改）。 “缓存大小限制”参数"
"保证缓存不会在长时间运行的进程比如说网站服务器上无限制的增加自身的大小。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:88
msgid ""
"In general, the LRU cache should only be used when you want to reuse "
"previously computed values.  Accordingly, it doesn't make sense to cache "
"functions with side-effects, functions that need to create distinct mutable "
"objects on each call, or impure functions such as time() or random()."
msgstr ""
"一般来说，LRU缓存只在当你想要重用之前计算的结果时使用。因此，用它缓存具有副作"
"用的函数、需要在每次调用时创建不同、易变的对象的函数或者诸如time（）或random"
"（）之类的不纯函数是没有意义的。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:93
msgid "Example of an LRU cache for static web content::"
msgstr "静态 Web 内容的 LRU 缓存示例::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:112
msgid ""
"Example of efficiently computing `Fibonacci numbers <https://en.wikipedia."
"org/wiki/Fibonacci_number>`_ using a cache to implement a `dynamic "
"programming <https://en.wikipedia.org/wiki/Dynamic_programming>`_ technique::"
msgstr ""
"以下是使用缓存通过 `动态规划 <https://zh.wikipedia.org/wiki/动态规划>`_  计"
"算 `斐波那契数列 <https://zh.wikipedia.org/wiki/斐波那契数列>`_  的例子。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:132
msgid "Added the *typed* option."
msgstr "添加 *typed* 选项。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:137
msgid ""
"Given a class defining one or more rich comparison ordering methods, this "
"class decorator supplies the rest.  This simplifies the effort involved in "
"specifying all of the possible rich comparison operations:"
msgstr ""
"给定一个声明一个或多个全比较排序方法的类，这个类装饰器实现剩余的方法。这减轻"
"了指定所有可能的全比较操作的工作。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:141
msgid ""
"The class must define one of :meth:`__lt__`, :meth:`__le__`, :meth:`__gt__`, "
"or :meth:`__ge__`. In addition, the class should supply an :meth:`__eq__` "
"method."
msgstr ""
"此类必须包含以下方法之一：:meth:`__lt__` 、:meth:`__le__`、:meth:`__gt__` "
"或 :meth:`__ge__`。另外，此类必须支持 :meth:`__eq__` 方法。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:145
msgid "For example::"
msgstr "例如 ::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:165
msgid ""
"While this decorator makes it easy to create well behaved totally ordered "
"types, it *does* come at the cost of slower execution and more complex stack "
"traces for the derived comparison methods. If performance benchmarking "
"indicates this is a bottleneck for a given application, implementing all six "
"rich comparison methods instead is likely to provide an easy speed boost."
msgstr ""
"虽然此装饰器使得创建具有良好行为的完全有序类型变得非常容易，但它 *确实* 是以"
"执行速度更缓慢和派生比较方法的堆栈回溯更复杂为代价的。 如果性能基准测试表明这"
"是特定应用的瓶颈所在，则改为实现全部六个富比较方法应该会轻松提升速度。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:174
msgid ""
"Returning NotImplemented from the underlying comparison function for "
"unrecognised types is now supported."
msgstr "现在已支持从未识别类型的下层比较函数返回 NotImplemented 异常。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:180
msgid ""
"Return a new :ref:`partial object<partial-objects>` which when called will "
"behave like *func* called with the positional arguments *args* and keyword "
"arguments *keywords*. If more arguments are supplied to the call, they are "
"appended to *args*. If additional keyword arguments are supplied, they "
"extend and override *keywords*. Roughly equivalent to::"
msgstr ""
"返回一个新的 :ref:`部分对象<partial-objects>`，当被调用时其行为类似于 *func* "
"附带位置参数 *args* 和关键字参数 *keywords* 被调用。 如果为调用提供了更多的参"
"数，它们会被附加到 *args*。 如果提供了额外的关键字参数，它们会扩展并重载 "
"*keywords*。 大致等价于::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:197
msgid ""
"The :func:`partial` is used for partial function application which "
"\"freezes\" some portion of a function's arguments and/or keywords resulting "
"in a new object with a simplified signature.  For example, :func:`partial` "
"can be used to create a callable that behaves like the :func:`int` function "
"where the *base* argument defaults to two:"
msgstr ""
":func:`partial` 会被“冻结了”一部分函数参数和/或关键字的部分函数应用所使用，从"
"而得到一个具有简化签名的新对象。 例如，:func:`partial` 可用来创建一个行为类似"
"于 :func:`int` 函数的可调用对象，其中 *base* 参数默认为二："

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:212
msgid ""
"Return a new :class:`partialmethod` descriptor which behaves like :class:"
"`partial` except that it is designed to be used as a method definition "
"rather than being directly callable."
msgstr ""
"返回一个新的 :class:`partialmethod` 描述器，其行为类似 :class:`partial` 但它"
"被设计用作方法定义而非直接用作可调用对象。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:216
msgid ""
"*func* must be a :term:`descriptor` or a callable (objects which are both, "
"like normal functions, are handled as descriptors)."
msgstr ""
"*func* 必须是一个 :term:`descriptor` 或可调用对象（同属两者的对象例如普通函数"
"会被当作描述器来处理）。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:219
msgid ""
"When *func* is a descriptor (such as a normal Python function, :func:"
"`classmethod`, :func:`staticmethod`, :func:`abstractmethod` or another "
"instance of :class:`partialmethod`), calls to ``__get__`` are delegated to "
"the underlying descriptor, and an appropriate :ref:`partial object<partial-"
"objects>` returned as the result."
msgstr ""
"当 *func* 是一个描述器（例如普通 Python 函数, :func:`classmethod`, :func:"
"`staticmethod`, :func:`abstractmethod` 或其他 :class:`partialmethod` 的实例）"
"时, 对 ``__get__`` 的调用会被委托给底层的描述器，并会返回一个适当的 :ref:`部"
"分对象<partial-objects>` 作为结果。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:225
msgid ""
"When *func* is a non-descriptor callable, an appropriate bound method is "
"created dynamically. This behaves like a normal Python function when used as "
"a method: the *self* argument will be inserted as the first positional "
"argument, even before the *args* and *keywords* supplied to the :class:"
"`partialmethod` constructor."
msgstr ""
"当 *func* 是一个非描述器类可调用对象时，则会动态创建一个适当的绑定方法。 当用"
"作方法时其行为类似普通 Python 函数：将会插入 *self* 参数作为第一个位置参数，"
"其位置甚至会处于提供给 :class:`partialmethod` 构造器的 *args* 和 *keywords* "
"之前。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:256
msgid ""
"Apply *function* of two arguments cumulatively to the items of *sequence*, "
"from left to right, so as to reduce the sequence to a single value.  For "
"example, ``reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])`` calculates "
"``((((1+2)+3)+4)+5)``. The left argument, *x*, is the accumulated value and "
"the right argument, *y*, is the update value from the *sequence*.  If the "
"optional *initializer* is present, it is placed before the items of the "
"sequence in the calculation, and serves as a default when the sequence is "
"empty.  If *initializer* is not given and *sequence* contains only one item, "
"the first item is returned."
msgstr ""
"将两个参数的 *function* 从左至右累积地应用到 *sequence* 的条目，以便将该序列"
"缩减为单一值。 例如，``reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])`` 是计算 "
"``((((1+2)+3)+4)+5)`` 的值。 左边的参数 *x* 是累积值而右边的参数 *y* 则是来"
"自 *sequence* 的更新值。 如果存在可选项 *initializer*，它会被放在参与计算的序"
"列的条目之前，并在序列对象为空时作为默认值。 如果没有给出 *initializer* 并且 "
"*sequence* 仅包含一个条目，则将返回第一项。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:265
msgid "Roughly equivalent to::"
msgstr "大致相当于："

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:280
msgid ""
"Transform a function into a :term:`single-dispatch <single dispatch>` :term:"
"`generic function`."
msgstr ""
"将一个函数转换为 :term:`单分派 <single dispatch>` :term:`generic function`。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:283
msgid ""
"To define a generic function, decorate it with the ``@singledispatch`` "
"decorator. Note that the dispatch happens on the type of the first argument, "
"create your function accordingly::"
msgstr ""
"要定义一个泛型函数，应使用 ``@singledispatch`` 装饰器进行装饰。 请注意分派是"
"作用于第一个参数的类型，要相应地创建你的函数::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:294
msgid ""
"To add overloaded implementations to the function, use the :func:`register` "
"attribute of the generic function.  It is a decorator.  For functions "
"annotated with types, the decorator will infer the type of the first "
"argument automatically::"
msgstr ""
"要将重载的实现添加到函数中，请使用泛型函数的 :func:`register` 属性。 它是一个"
"装饰器。 对于带有类型标注的函数，该装饰器将自动推断第一个参数的类型::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:312
msgid ""
"For code which doesn't use type annotations, the appropriate type argument "
"can be passed explicitly to the decorator itself::"
msgstr "对于不使用类型标注的代码，可以将适当的类型参数显式地传给装饰器本身::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:323
msgid ""
"To enable registering lambdas and pre-existing functions, the :func:"
"`register` attribute can be used in a functional form::"
msgstr ""
"要启用注册 lambda 和现有函数，可以使用函数形式的 :func:`register` 属性::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:331
msgid ""
"The :func:`register` attribute returns the undecorated function which "
"enables decorator stacking, pickling, as well as creating unit tests for "
"each variant independently::"
msgstr ""
":func:`register` 属性将返回启用了装饰器堆栈、封存的未装饰函数，并会为每个变量"
"单独创建单元测试::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:345
msgid ""
"When called, the generic function dispatches on the type of the first "
"argument::"
msgstr "在调用时，泛型函数会根据第一个参数的类型进行分派::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:365
msgid ""
"Where there is no registered implementation for a specific type, its method "
"resolution order is used to find a more generic implementation. The original "
"function decorated with ``@singledispatch`` is registered for the base "
"``object`` type, which means it is used if no better implementation is found."
msgstr ""
"在没有用于特定类型的已注册实现的情况下，则会使用其方法解析顺序来查找更通用的"
"实现。 以 ``@singledispatch`` 装饰的原始函数将为最基本的 ``object`` 类型进行"
"注册，这意味着它将在找不到更好的实现时被使用。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:371
msgid ""
"To check which implementation will the generic function choose for a given "
"type, use the ``dispatch()`` attribute::"
msgstr "要检查泛型函数将为给定类型选择哪个实现，请使用 ``dispatch()`` 属性::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:379
msgid ""
"To access all registered implementations, use the read-only ``registry`` "
"attribute::"
msgstr "要访问所有已注册实现，请使用只读的 ``registry`` 属性::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:393
msgid "The :func:`register` attribute supports using type annotations."
msgstr ":func:`register` 属性支持使用类型标注。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:399
msgid ""
"Update a *wrapper* function to look like the *wrapped* function. The "
"optional arguments are tuples to specify which attributes of the original "
"function are assigned directly to the matching attributes on the wrapper "
"function and which attributes of the wrapper function are updated with the "
"corresponding attributes from the original function. The default values for "
"these arguments are the module level constants ``WRAPPER_ASSIGNMENTS`` "
"(which assigns to the wrapper function's ``__module__``, ``__name__``, "
"``__qualname__``, ``__annotations__`` and ``__doc__``, the documentation "
"string) and ``WRAPPER_UPDATES`` (which updates the wrapper function's "
"``__dict__``, i.e. the instance dictionary)."
msgstr ""
"更新一个 *wrapper* 函数以使其类似于 *wrapped* 函数。 可选参数为指明原函数的哪"
"些属性要直接被赋值给 wrapper 函数的匹配属性的元组，并且这些 wrapper 函数的属"
"性将使用原函数的对应属性来更新。 这些参数的默认值是模块级常量 "
"``WRAPPER_ASSIGNMENTS`` (它将被赋值给 wrapper 函数的 ``__module__``, "
"``__name__``, ``__qualname__``, ``__annotations__`` 和 ``__doc__`` 即文档字符"
"串) 以及 ``WRAPPER_UPDATES`` (它将更新 wrapper 函数的 ``__dict__`` 即实例字"
"典)。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:409
msgid ""
"To allow access to the original function for introspection and other "
"purposes (e.g. bypassing a caching decorator such as :func:`lru_cache`), "
"this function automatically adds a ``__wrapped__`` attribute to the wrapper "
"that refers to the function being wrapped."
msgstr ""
"为了允许出于内省和其他目的访问原始函数（例如绕过 :func:`lru_cache` 之类的缓存"
"装饰器），此函数会自动为 wrapper 添加一个指向被包装函数的 ``__wrapped__`` 属"
"性。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:414
msgid ""
"The main intended use for this function is in :term:`decorator` functions "
"which wrap the decorated function and return the wrapper. If the wrapper "
"function is not updated, the metadata of the returned function will reflect "
"the wrapper definition rather than the original function definition, which "
"is typically less than helpful."
msgstr ""
"此函数的主要目的是在 :term:`decorator` 函数中用来包装被装饰的函数并返回包装"
"器。 如果包装器函数未被更新，则被返回函数的元数据将反映包装器定义而不是原始函"
"数定义，这通常没有什么用处。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:420
msgid ""
":func:`update_wrapper` may be used with callables other than functions. Any "
"attributes named in *assigned* or *updated* that are missing from the object "
"being wrapped are ignored (i.e. this function will not attempt to set them "
"on the wrapper function). :exc:`AttributeError` is still raised if the "
"wrapper function itself is missing any attributes named in *updated*."
msgstr ""
":func:`update_wrapper` 可以与函数之外的可调用对象一同使用。 在 *assigned* 或 "
"*updated* 中命名的任何属性如果不存在于被包装对象则会被忽略（即该函数将不会尝"
"试在包装器函数上设置它们）。 如果包装器函数自身缺少在 *updated* 中命名的任何"
"属性则仍将引发 :exc:`AttributeError`。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:426
msgid "Automatic addition of the ``__wrapped__`` attribute."
msgstr "自动添加 ``__wrapped__`` 属性。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:429
msgid "Copying of the ``__annotations__`` attribute by default."
msgstr "默认拷贝 ``__annotations__`` 属性。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:432
msgid "Missing attributes no longer trigger an :exc:`AttributeError`."
msgstr "不存在的属性将不再触发 :exc:`AttributeError`。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:435
msgid ""
"The ``__wrapped__`` attribute now always refers to the wrapped function, "
"even if that function defined a ``__wrapped__`` attribute. (see :issue:"
"`17482`)"
msgstr ""
"``__wrapped__`` 属性现在总是指向被包装的函数，即使该函数定义了 "
"``__wrapped__`` 属性。 (参见 :issue:`17482`)"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:443
msgid ""
"This is a convenience function for invoking :func:`update_wrapper` as a "
"function decorator when defining a wrapper function.  It is equivalent to "
"``partial(update_wrapper, wrapped=wrapped, assigned=assigned, "
"updated=updated)``. For example::"
msgstr ""
"这是一个便捷函数，用于在定义包装器函数时发起调用 :func:`update_wrapper` 作为"
"函数装饰器。 它等价于 ``partial(update_wrapper, wrapped=wrapped, "
"assigned=assigned, updated=updated)``。 例如::"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:469
msgid ""
"Without the use of this decorator factory, the name of the example function "
"would have been ``'wrapper'``, and the docstring of the original :func:"
"`example` would have been lost."
msgstr ""
"如果不使用这个装饰器工厂函数，则 example 函数的名称将变为 ``'wrapper'``，并"
"且 :func:`example` 原本的文档字符串将会丢失。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:477
msgid ":class:`partial` Objects"
msgstr ":class:`partial` 对象"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:479
msgid ""
":class:`partial` objects are callable objects created by :func:`partial`. "
"They have three read-only attributes:"
msgstr ""
":class:`partial` 对象是由 :func:`partial` 创建的可调用对象。 它们具有三个只读"
"属性："

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:485
msgid ""
"A callable object or function.  Calls to the :class:`partial` object will be "
"forwarded to :attr:`func` with new arguments and keywords."
msgstr ""
"一个可调用对象或函数。 对 :class:`partial` 对象的调用将被转发给 :attr:`func` "
"并附带新的参数和关键字。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:491
msgid ""
"The leftmost positional arguments that will be prepended to the positional "
"arguments provided to a :class:`partial` object call."
msgstr ""
"最左边的位置参数将放置在提供给 :class:`partial` 对象调用的位置参数之前。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:497
msgid ""
"The keyword arguments that will be supplied when the :class:`partial` object "
"is called."
msgstr "当调用 :class:`partial` 对象时将要提供的关键字参数。"

#: /home/runner/work/python-docs-tx-translations/python-docs-tx-translations/cpython/Doc/library/functools.rst:500
msgid ""
":class:`partial` objects are like :class:`function` objects in that they are "
"callable, weak referencable, and can have attributes.  There are some "
"important differences.  For instance, the :attr:`~definition.__name__` and :"
"attr:`__doc__` attributes are not created automatically.  Also, :class:"
"`partial` objects defined in classes behave like static methods and do not "
"transform into bound methods during instance attribute look-up."
msgstr ""
":class:`partial` 对象与 :class:`function` 对象的类似之处在于它们都是可调用、"
"可弱引用的对象并可拥有属性。 但两者也存在一些重要的区别。 例如前者不会自动创"
"建 :attr:`~definition.__name__` 和 :attr:`__doc__` 属性。 而且，在类中定义"
"的 :class:`partial` 对象的行为类似于静态方法，并且不会在实例属性查找期间转换"
"为绑定方法。"
