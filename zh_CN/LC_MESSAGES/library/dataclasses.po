# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# ww song <sww4718168@gmail.com>, 2020
# Alpha Du <alphanow@gmail.com>, 2020
# nick <2330458484@qq.com>, 2020
# Freesand Leo <yuqinju@163.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-06-02 14:43+0000\n"
"PO-Revision-Date: 2020-05-30 11:59+0000\n"
"Last-Translator: Freesand Leo <yuqinju@163.com>, 2021\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../library/dataclasses.rst:2
msgid ":mod:`dataclasses` --- Data Classes"
msgstr ":mod:`dataclasses` --- 数据类"

#: ../../library/dataclasses.rst:10
msgid "**Source code:** :source:`Lib/dataclasses.py`"
msgstr "**源码：** :source:`Lib/dataclasses.py`"

#: ../../library/dataclasses.rst:14
msgid ""
"This module provides a decorator and functions for automatically adding "
"generated :term:`special method`\\s such as :meth:`__init__` and "
":meth:`__repr__` to user-defined classes.  It was originally described in "
":pep:`557`."
msgstr ""
"这个模块提供了一个装饰器和一些函数，用于自动添加生成的 :term:`special method`，例如 :meth:`__init__` 和 "
":meth:`__repr__` 到用户定义的类。 它最初描述于 :pep:`557` 。"

#: ../../library/dataclasses.rst:19
msgid ""
"The member variables to use in these generated methods are defined using "
":pep:`526` type annotations.  For example this code::"
msgstr "在这些生成的方法中使用的成员变量使用 :pep:`526` 类型注释定义。例如这段代码::"

#: ../../library/dataclasses.rst:34
msgid "Will add, among other things, a :meth:`__init__` that looks like::"
msgstr "除其他事情外，将添加 :meth:`__init__` ，其看起来像::"

#: ../../library/dataclasses.rst:41
msgid ""
"Note that this method is automatically added to the class: it is not "
"directly specified in the ``InventoryItem`` definition shown above."
msgstr "请注意，此方法会自动添加到类中：它不会在上面显示的 ``InventoryItem`` 定义中直接指定。"

#: ../../library/dataclasses.rst:47
msgid "Module-level decorators, classes, and functions"
msgstr "模块级装饰器、类和函数"

#: ../../library/dataclasses.rst:51
msgid ""
"This function is a :term:`decorator` that is used to add generated "
":term:`special method`\\s to classes, as described below."
msgstr "这个函数是 :term:`decorator` ，用于将生成的 :term:`special method` 添加到类中，如下所述。"

#: ../../library/dataclasses.rst:54
msgid ""
"The :func:`dataclass` decorator examines the class to find ``field``\\s.  A "
"``field`` is defined as class variable that has a :term:`type annotation "
"<variable annotation>`.  With two exceptions described below, nothing in "
":func:`dataclass` examines the type specified in the variable annotation."
msgstr ""
":func:`dataclass` 装饰器检查类以找到 ``field``。 ``field`` 被定义为具有 :term:`类型标注 "
"<variable annotation>` 的类变量。除了下面描述的两个例外，在 :func:`dataclass` "
"中没有任何内容检查变量标注中指定的类型。"

#: ../../library/dataclasses.rst:60
msgid ""
"The order of the fields in all of the generated methods is the order in "
"which they appear in the class definition."
msgstr "所有生成的方法中的字段顺序是它们在类定义中出现的顺序。"

#: ../../library/dataclasses.rst:63
msgid ""
"The :func:`dataclass` decorator will add various \"dunder\" methods to the "
"class, described below.  If any of the added methods already exist on the "
"class, the behavior depends on the parameter, as documented below. The "
"decorator returns the same class that is called on; no new class is created."
msgstr ""
":func:`dataclass` "
"装饰器将向类中添加各种“dunder”方法，如下所述。如果类中已存在任何添加的方法，则行为取决于参数，如下所述。装饰器返回被调用的同一个类；没有创建新类。"

#: ../../library/dataclasses.rst:69
msgid ""
"If :func:`dataclass` is used just as a simple decorator with no parameters, "
"it acts as if it has the default values documented in this signature.  That "
"is, these three uses of :func:`dataclass` are equivalent::"
msgstr ""
"如果 :func:`dataclass` 仅用作没有参数的简单装饰器，它就像它具有此签名中记录的默认值一样。也就是说，这三种 "
":func:`dataclass` 用法是等价的::"

#: ../../library/dataclasses.rst:86
msgid "The parameters to :func:`dataclass` are:"
msgstr ":func:`dataclass` 的参数有："

#: ../../library/dataclasses.rst:88
msgid ""
"``init``: If true (the default), a :meth:`__init__` method will be "
"generated."
msgstr "``init``: 如果为真值（默认），将生成一个 :meth:`__init__` 方法。"

#: ../../library/dataclasses.rst:91
msgid ""
"If the class already defines :meth:`__init__`, this parameter is ignored."
msgstr "如果类已定义 :meth:`__init__` ，则忽略此参数。"

#: ../../library/dataclasses.rst:94
msgid ""
"``repr``: If true (the default), a :meth:`__repr__` method will be "
"generated.  The generated repr string will have the class name and the name "
"and repr of each field, in the order they are defined in the class.  Fields "
"that are marked as being excluded from the repr are not included.  For "
"example: ``InventoryItem(name='widget', unit_price=3.0, "
"quantity_on_hand=10)``."
msgstr ""
"``repr`` ：如果为真值（默认），将生成一个 :meth:`__repr__` 方法。 生成的 repr 字符串将具有类名以及每个字段的名称和 "
"repr ，按照它们在类中定义的顺序。不包括标记为从 repr 中排除的字段。 例如：``InventoryItem(name='widget', "
"unit_price=3.0, quantity_on_hand=10)``。"

#: ../../library/dataclasses.rst:101
msgid ""
"If the class already defines :meth:`__repr__`, this parameter is ignored."
msgstr "如果类已定义 :meth:`__repr__` ，则忽略此参数。"

#: ../../library/dataclasses.rst:104
msgid ""
"``eq``: If true (the default), an :meth:`__eq__` method will be generated.  "
"This method compares the class as if it were a tuple of its fields, in "
"order.  Both instances in the comparison must be of the identical type."
msgstr ""
"``eq`` ：如果为true（默认值），将生成 :meth:`__eq__` "
"方法。此方法将类作为其字段的元组按顺序比较。比较中的两个实例必须是相同的类型。"

#: ../../library/dataclasses.rst:109
msgid ""
"If the class already defines :meth:`__eq__`, this parameter is ignored."
msgstr "如果类已定义 :meth:`__eq__` ，则忽略此参数。"

#: ../../library/dataclasses.rst:112
msgid ""
"``order``: If true (the default is ``False``), :meth:`__lt__`, "
":meth:`__le__`, :meth:`__gt__`, and :meth:`__ge__` methods will be "
"generated.  These compare the class as if it were a tuple of its fields, in "
"order.  Both instances in the comparison must be of the identical type.  If "
"``order`` is true and ``eq`` is false, a :exc:`ValueError` is raised."
msgstr ""
"``order`` ：如果为真值（默认为 ``False`` ），则 :meth:`__lt__` 、 :meth:`__le__` 、 "
":meth:`__gt__` 和 :meth:`__ge__` 方法将生成。 这将类作为其字段的元组按顺序比较。比较中的两个实例必须是相同的类型。如果 "
"``order`` 为真值并且 ``eq`` 为假值 ，则引发 :exc:`ValueError` 。"

#: ../../library/dataclasses.rst:119
msgid ""
"If the class already defines any of :meth:`__lt__`, :meth:`__le__`, "
":meth:`__gt__`, or :meth:`__ge__`, then :exc:`TypeError` is raised."
msgstr ""
"如果类已经定义了 :meth:`__lt__` 、 :meth:`__le__` 、 :meth:`__gt__` 或者 :meth:`__ge__` "
"中的任意一个，将引发 :exc:`TypeError` 。"

#: ../../library/dataclasses.rst:123
msgid ""
"``unsafe_hash``: If ``False`` (the default), a :meth:`__hash__` method is "
"generated according to how ``eq`` and ``frozen`` are set."
msgstr ""
"``unsafe_hash`` ：如果为 ``False`` （默认值），则根据 ``eq`` 和 ``frozen`` 的设置方式生成 "
":meth:`__hash__` 方法。"

#: ../../library/dataclasses.rst:126
msgid ""
":meth:`__hash__` is used by built-in :meth:`hash()`, and when objects are "
"added to hashed collections such as dictionaries and sets.  Having a "
":meth:`__hash__` implies that instances of the class are immutable. "
"Mutability is a complicated property that depends on the programmer's "
"intent, the existence and behavior of :meth:`__eq__`, and the values of the "
"``eq`` and ``frozen`` flags in the :func:`dataclass` decorator."
msgstr ""
":meth:`__hash__` 由内置的 :meth:`hash()` 使用，当对象被添加到散列集合（如字典和集合）时。有一个 "
":meth:`__hash__` 意味着类的实例是不可变的。可变性是一个复杂的属性，取决于程序员的意图， :meth:`__eq__` "
"的存在性和行为，以及 :func:`dataclass` 装饰器中 ``eq`` 和 ``frozen`` 标志的值。"

#: ../../library/dataclasses.rst:133
msgid ""
"By default, :func:`dataclass` will not implicitly add a :meth:`__hash__` "
"method unless it is safe to do so.  Neither will it add or change an "
"existing explicitly defined :meth:`__hash__` method.  Setting the class "
"attribute ``__hash__ = None`` has a specific meaning to Python, as described"
" in the :meth:`__hash__` documentation."
msgstr ""
"默认情况下， :func:`dataclass` 不会隐式添加 :meth:`__hash__` 方法，除非这样做是安全的。 "
"它也不会添加或更改现有的明确定义的 :meth:`__hash__` 方法。 设置类属性 ``__hash__ = None`` 对 Python "
"具有特定含义，如 :meth:`__hash__` 文档中所述。"

#: ../../library/dataclasses.rst:139
msgid ""
"If :meth:`__hash__` is not explicitly defined, or if it is set to ``None``, "
"then :func:`dataclass` *may* add an implicit :meth:`__hash__` method. "
"Although not recommended, you can force :func:`dataclass` to create a "
":meth:`__hash__` method with ``unsafe_hash=True``. This might be the case if"
" your class is logically immutable but can nonetheless be mutated. This is a"
" specialized use case and should be considered carefully."
msgstr ""
"如果 :meth:`__hash__` 没有显式定义，或者它被设为 ``None``，则 :func:`dataclass` *可能* 会添加一个隐式 "
":meth:`__hash__` 方法。 虽然并不推荐，但你可以用 ``unsafe_hash=True`` 来强制 :func:`dataclass`"
" 创建一个 :meth:`__hash__` 方法。 如果你的类在逻辑上不可变但却仍然可被修改那么可能就是这种情况。 "
"这是一个特殊用例并且应当被仔细地考虑。"

#: ../../library/dataclasses.rst:146
msgid ""
"Here are the rules governing implicit creation of a :meth:`__hash__` method."
"  Note that you cannot both have an explicit :meth:`__hash__` method in your"
" dataclass and set ``unsafe_hash=True``; this will result in a "
":exc:`TypeError`."
msgstr ""
"以下是隐式创建 :meth:`__hash__` 方法的规则。请注意，你不能在数据类中都使用显式的 :meth:`__hash__` 方法并设置 "
"``unsafe_hash=True`` ；这将导致 :exc:`TypeError` 。"

#: ../../library/dataclasses.rst:151
msgid ""
"If ``eq`` and ``frozen`` are both true, by default :func:`dataclass` will "
"generate a :meth:`__hash__` method for you.  If ``eq`` is true and "
"``frozen`` is false, :meth:`__hash__` will be set to ``None``, marking it "
"unhashable (which it is, since it is mutable).  If ``eq`` is false, "
":meth:`__hash__` will be left untouched meaning the :meth:`__hash__` method "
"of the superclass will be used (if the superclass is :class:`object`, this "
"means it will fall back to id-based hashing)."
msgstr ""
"如果 ``eq`` 和 ``frozen`` 都是 true，默认情况下 :func:`dataclass` 将为你生成一个 "
":meth:`__hash__` 方法。如果 ``eq`` 为 true 且 ``frozen`` 为 false ，则 "
":meth:`__hash__` 将被设置为 ``None`` ，标记它不可用（因为它是可变的）。如果 ``eq`` 为 false ，则 "
":meth:`__hash__` 将保持不变，这意味着将使用超类的 :meth:`__hash__` 方法（如果超类是 :class:`object` "
"，这意味着它将回到基于id的hash）。"

#: ../../library/dataclasses.rst:159
msgid ""
"``frozen``: If true (the default is ``False``), assigning to fields will "
"generate an exception.  This emulates read-only frozen instances.  If "
":meth:`__setattr__` or :meth:`__delattr__` is defined in the class, then "
":exc:`TypeError` is raised.  See the discussion below."
msgstr ""
"``frozen``: 如为真值 (默认值为 ``False``)，则对字段赋值将会产生异常。 这模拟了只读的冻结实例。 如果在类中定义了 "
":meth:`__setattr__` 或 :meth:`__delattr__` 则将会引发 :exc:`TypeError`。 参见下文的讨论。"

#: ../../library/dataclasses.rst:164
msgid ""
"``field``\\s may optionally specify a default value, using normal Python "
"syntax::"
msgstr "``field``\\s 可以选择使用普通的 Python 语法指定默认值::"

#: ../../library/dataclasses.rst:172
msgid ""
"In this example, both ``a`` and ``b`` will be included in the added "
":meth:`__init__` method, which will be defined as::"
msgstr "在这个例子中， ``a`` 和 ``b`` 都将包含在添加的 :meth:`__init__` 方法中，它们将被定义为::"

#: ../../library/dataclasses.rst:177
msgid ""
":exc:`TypeError` will be raised if a field without a default value follows a"
" field with a default value.  This is true either when this occurs in a "
"single class, or as a result of class inheritance."
msgstr ""
"如果没有默认值的字段跟在具有默认值的字段后，将引发 :exc:`TypeError` 。当这发生在单个类中时，或者作为类继承的结果时，都是如此。"

#: ../../library/dataclasses.rst:183
msgid ""
"For common and simple use cases, no other functionality is required.  There "
"are, however, some dataclass features that require additional per-field "
"information.  To satisfy this need for additional information, you can "
"replace the default field value with a call to the provided :func:`field` "
"function.  For example::"
msgstr ""
"对于常见和简单的用例，不需要其他功能。但是，有些数据类功能需要额外的每字段信息。为了满足这种对附加信息的需求，你可以通过调用提供的 "
":func:`field` 函数来替换默认字段值。例如::"

#: ../../library/dataclasses.rst:196
msgid ""
"As shown above, the ``MISSING`` value is a sentinel object used to detect if"
" the ``default`` and ``default_factory`` parameters are provided.  This "
"sentinel is used because ``None`` is a valid value for ``default``.  No code"
" should directly use the ``MISSING`` value."
msgstr ""
"如上所示， ``MISSING`` 值是一个 sentinel 对象，用于检测是否提供了 ``default`` 和 "
"``default_factory`` 参数。 使用此 sentinel 是因为 ``None`` 是 ``default`` "
"的有效值。没有代码应该直接使用 ``MISSING`` 值。"

#: ../../library/dataclasses.rst:202
msgid "The parameters to :func:`field` are:"
msgstr ":func:`field` 参数有："

#: ../../library/dataclasses.rst:204
msgid ""
"``default``: If provided, this will be the default value for this field.  "
"This is needed because the :meth:`field` call itself replaces the normal "
"position of the default value."
msgstr "``default`` ：如果提供，这将是该字段的默认值。这是必需的，因为 :meth:`field` 调用本身会替换一般的默认值。"

#: ../../library/dataclasses.rst:208
msgid ""
"``default_factory``: If provided, it must be a zero-argument callable that "
"will be called when a default value is needed for this field.  Among other "
"purposes, this can be used to specify fields with mutable default values, as"
" discussed below.  It is an error to specify both ``default`` and "
"``default_factory``."
msgstr ""
"``default_factory`` "
"：如果提供，它必须是一个零参数可调用对象，当该字段需要一个默认值时，它将被调用。除了其他目的之外，这可以用于指定具有可变默认值的字段，如下所述。 "
"同时指定 ``default`` 和 ``default_factory`` 将产生错误。"

#: ../../library/dataclasses.rst:214
msgid ""
"``init``: If true (the default), this field is included as a parameter to "
"the generated :meth:`__init__` method."
msgstr "``init`` ：如果为true（默认值），则该字段作为参数包含在生成的 :meth:`__init__` 方法中。"

#: ../../library/dataclasses.rst:217
msgid ""
"``repr``: If true (the default), this field is included in the string "
"returned by the generated :meth:`__repr__` method."
msgstr "``repr`` ：如果为true（默认值），则该字段包含在生成的 :meth:`__repr__` 方法返回的字符串中。"

#: ../../library/dataclasses.rst:220
msgid ""
"``compare``: If true (the default), this field is included in the generated "
"equality and comparison methods (:meth:`__eq__`, :meth:`__gt__`, et al.)."
msgstr ""
"``compare`` ：如果为true（默认值），则该字段包含在生成的相等性和比较方法中（ :meth:`__eq__` ， "
":meth:`__gt__` 等等）。"

#: ../../library/dataclasses.rst:224
msgid ""
"``hash``: This can be a bool or ``None``.  If true, this field is included "
"in the generated :meth:`__hash__` method.  If ``None`` (the default), use "
"the value of ``compare``: this would normally be the expected behavior.  A "
"field should be considered in the hash if it's used for comparisons.  "
"Setting this value to anything other than ``None`` is discouraged."
msgstr ""
"``hash`` ：这可以是布尔值或 ``None`` 。如果为true，则此字段包含在生成的 :meth:`__hash__` 方法中。如果为 "
"``None`` （默认值），请使用 ``compare`` 的值，这通常是预期的行为。如果字段用于比较，则应在 hash "
"中考虑该字段。不鼓励将此值设置为 ``None`` 以外的任何值。"

#: ../../library/dataclasses.rst:231
msgid ""
"One possible reason to set ``hash=False`` but ``compare=True`` would be if a"
" field is expensive to compute a hash value for, that field is needed for "
"equality testing, and there are other fields that contribute to the type's "
"hash value.  Even if a field is excluded from the hash, it will still be "
"used for comparisons."
msgstr ""
"设置 ``hash=False`` 但 ``compare=True`` 的一个可能原因是，如果一个计算 hash "
"的代价很高的字段是检验等价性需要的，但还有其他字段可以计算类型的 hash 。 即使从 hash 中排除某个字段，它仍将用于比较。"

#: ../../library/dataclasses.rst:237
msgid ""
"``metadata``: This can be a mapping or None. None is treated as an empty "
"dict.  This value is wrapped in :func:`~types.MappingProxyType` to make it "
"read-only, and exposed on the :class:`Field` object. It is not used at all "
"by Data Classes, and is provided as a third-party extension mechanism. "
"Multiple third-parties can each have their own key, to use as a namespace in"
" the metadata."
msgstr ""
"``metadata`` ：这可以是映射或 None 。 None 被视为一个空的字典。这个值包含在 "
":func:`~insterss.MappingProxyType` 中，使其成为只读，并暴露在 :class:`Field` "
"对象上。数据类根本不使用它，它是作为第三方扩展机制提供的。多个第三方可以各自拥有自己的键值，以用作元数据中的命名空间。"

#: ../../library/dataclasses.rst:245
msgid ""
"If the default value of a field is specified by a call to :func:`field()`, "
"then the class attribute for this field will be replaced by the specified "
"``default`` value.  If no ``default`` is provided, then the class attribute "
"will be deleted.  The intent is that after the :func:`dataclass` decorator "
"runs, the class attributes will all contain the default values for the "
"fields, just as if the default value itself were specified.  For example, "
"after::"
msgstr ""
"如果通过调用 :func:`field()` 指定字段的默认值，则该字段的类属性将替换为指定的 ``default`` 值。如果没有提供 "
"``default`` ，那么将删除类属性。目的是在 :func:`dataclass` "
"装饰器运行之后，类属性将包含字段的默认值，就像指定了默认值一样。例如，之后::"

#: ../../library/dataclasses.rst:261
msgid ""
"The class attribute ``C.z`` will be ``10``, the class attribute ``C.t`` will"
" be ``20``, and the class attributes ``C.x`` and ``C.y`` will not be set."
msgstr ""
"类属性 ``C.z`` 将是 ``10`` ，类属性 ``C.t`` 将是 ``20``，类属性 ``C.x`` 和 ``C.y`` 将不设置。"

#: ../../library/dataclasses.rst:267
msgid ""
":class:`Field` objects describe each defined field. These objects are "
"created internally, and are returned by the :func:`fields` module-level "
"method (see below).  Users should never instantiate a :class:`Field` object "
"directly.  Its documented attributes are:"
msgstr ""
":class:`Field` 对象描述每个定义的字段。这些对象在内部创建，并由 :func:`fields` "
"模块级方法返回（见下文）。用户永远不应该直接实例化 :class:`Field` 对象。 其有文档的属性是："

#: ../../library/dataclasses.rst:272
msgid "``name``: The name of the field."
msgstr "``name`` ：字段的名字。"

#: ../../library/dataclasses.rst:274
msgid "``type``: The type of the field."
msgstr "``type`` ：字段的类型。"

#: ../../library/dataclasses.rst:276
msgid ""
"``default``, ``default_factory``, ``init``, ``repr``, ``hash``, ``compare``,"
" and ``metadata`` have the identical meaning and values as they do in the "
":func:`field` declaration."
msgstr ""
"``default`` 、 ``default_factory`` 、 ``init`` 、 ``repr`` 、 ``hash`` 、 "
"``compare`` 以及 ``metadata`` 与具有和 :func:`field` 声明中相同的意义和值。"

#: ../../library/dataclasses.rst:280
msgid ""
"Other attributes may exist, but they are private and must not be inspected "
"or relied on."
msgstr "可能存在其他属性，但它们是私有的，不能被审查或依赖。"

#: ../../library/dataclasses.rst:285
msgid ""
"Returns a tuple of :class:`Field` objects that define the fields for this "
"dataclass.  Accepts either a dataclass, or an instance of a dataclass. "
"Raises :exc:`TypeError` if not passed a dataclass or instance of one. Does "
"not return pseudo-fields which are ``ClassVar`` or ``InitVar``."
msgstr ""
"返回 :class:`Field` 对象的元组，用于定义此数据类的字段。 接受数据类或数据类的实例。如果没有传递一个数据类或实例将引发 "
":exc:`TypeError` 。 不返回 ``ClassVar`` 或 ``InitVar`` 的伪字段。"

#: ../../library/dataclasses.rst:292
msgid ""
"Converts the dataclass ``instance`` to a dict (by using the factory function"
" ``dict_factory``).  Each dataclass is converted to a dict of its fields, as"
" ``name: value`` pairs.  dataclasses, dicts, lists, and tuples are recursed "
"into.  For example::"
msgstr ""
"将数据类 ``instance`` 转换为字典（使用工厂函数 ``dict_factory`` ）。每个数据类都转换为其字段的字典，如 ``name: "
"value`` 对。数据类、字典、列表和元组被递归。例如::"

#: ../../library/dataclasses.rst:312 ../../library/dataclasses.rst:326
msgid "Raises :exc:`TypeError` if ``instance`` is not a dataclass instance."
msgstr "引发 :exc:`TypeError` 如果 ``instance`` 不是数据类实例。"

#: ../../library/dataclasses.rst:316
msgid ""
"Converts the dataclass ``instance`` to a tuple (by using the factory "
"function ``tuple_factory``).  Each dataclass is converted to a tuple of its "
"field values.  dataclasses, dicts, lists, and tuples are recursed into."
msgstr ""
"将数据类 ``instance`` 转换为元组（通过使用工厂函数 ``tuple_factory`` "
"）。每个数据类都转换为其字段值的元组。数据类、字典、列表和元组被递归。"

#: ../../library/dataclasses.rst:321
msgid "Continuing from the previous example::"
msgstr "继续前一个例子::"

#: ../../library/dataclasses.rst:330
msgid ""
"Creates a new dataclass with name ``cls_name``, fields as defined in "
"``fields``, base classes as given in ``bases``, and initialized with a "
"namespace as given in ``namespace``.  ``fields`` is an iterable whose "
"elements are each either ``name``, ``(name, type)``, or ``(name, type, "
"Field)``.  If just ``name`` is supplied, ``typing.Any`` is used for "
"``type``.  The values of ``init``, ``repr``, ``eq``, ``order``, "
"``unsafe_hash``, and ``frozen`` have the same meaning as they do in "
":func:`dataclass`."
msgstr ""
"创建一个名为 ``cls_name`` 的新数据类，字段为 ``fields`` 中定义的字段，基类为 ``bases`` 中给出的基类，并使用 "
"``namespace`` 中给出的命名空间进行初始化。 ``fields`` 是一个可迭代的元素，每个元素都是 ``name`` 、 ``(name,"
" type)`` 或 ``(name, type, Field)`` 。 如果只提供``name`` ， ``type`` 为 "
"``typing.Any`` 。 ``init`` 、 ``repr`` 、 ``eq`` 、 ``order`` 、 ``unsafe_hash`` "
"和 ``frozen`` 的值与它们在  :func:`dataclass` 中的含义相同。"

#: ../../library/dataclasses.rst:339
msgid ""
"This function is not strictly required, because any Python mechanism for "
"creating a new class with ``__annotations__`` can then apply the "
":func:`dataclass` function to convert that class to a dataclass.  This "
"function is provided as a convenience.  For example::"
msgstr ""
"此函数不是严格要求的，因为用于任何创建带有 ``__annotations__`` 的新类的 Python 机制都可以应用 "
":func:`dataclass` 函数将该类转换为数据类。提供此功能是为了方便。例如::"

#: ../../library/dataclasses.rst:351
msgid "Is equivalent to::"
msgstr "等价于"

#: ../../library/dataclasses.rst:364
msgid ""
"Creates a new object of the same type of ``instance``, replacing fields with"
" values from ``changes``.  If ``instance`` is not a Data Class, raises "
":exc:`TypeError`.  If values in ``changes`` do not specify fields, raises "
":exc:`TypeError`."
msgstr ""
"创建一个 ``instance`` 相同类型的新对象，用 ``changes`` 中的值替换字段。如果 ``instance`` 不是数据类，则引发 "
":exc:`TypeError` 。如果 ``changes`` 中的值没有指定字段，则引发 :exc:`TypeError` 。"

#: ../../library/dataclasses.rst:369
msgid ""
"The newly returned object is created by calling the :meth:`__init__` method "
"of the dataclass.  This ensures that :meth:`__post_init__`, if present, is "
"also called."
msgstr ""
"新返回的对象通过调用数据类的 :meth:`__init__` 方法创建。这确保了如果存在 :meth:`__post_init__` ，其也被调用。"

#: ../../library/dataclasses.rst:373
msgid ""
"Init-only variables without default values, if any exist, must be specified "
"on the call to :func:`replace` so that they can be passed to "
":meth:`__init__` and :meth:`__post_init__`."
msgstr ""
"如果存在没有默认值的仅初始化变量，必须在调用 :func:`replace` 时指定，以便它们可以传递给 :meth:`__init__` 和 "
":meth:`__post_init__` 。"

#: ../../library/dataclasses.rst:377
msgid ""
"It is an error for ``changes`` to contain any fields that are defined as "
"having ``init=False``.  A :exc:`ValueError` will be raised in this case."
msgstr ""
"``changes`` 包含任何定义为 ``init=False`` 的字段是错误的。在这种情况下会引发 :exc:`ValueError` 。"

#: ../../library/dataclasses.rst:381
msgid ""
"Be forewarned about how ``init=False`` fields work during a call to "
":func:`replace`.  They are not copied from the source object, but rather are"
" initialized in :meth:`__post_init__`, if they're initialized at all.  It is"
" expected that ``init=False`` fields will be rarely and judiciously used.  "
"If they are used, it might be wise to have alternate class constructors, or "
"perhaps a custom ``replace()`` (or similarly named) method which handles "
"instance copying."
msgstr ""
"提前提醒 ``init=False`` 字段在调用 :func:`replace` "
"时的工作方式。如果它们完全被初始化的话，它们不是从源对象复制的，而是在 :meth:`__post_init__` 中初始化。估计 "
"``init=False`` 字段很少能被正确地使用。如果使用它们，那么使用备用类构造函数或者可能是处理实例复制的自定义 ``replace()`` "
"（或类似命名的）方法可能是明智的。"

#: ../../library/dataclasses.rst:392
msgid ""
"Return ``True`` if its parameter is a dataclass or an instance of one, "
"otherwise return ``False``."
msgstr "如果其形参为 dataclass 或其实例则返回 ``True``，否则返回 ``False``。"

#: ../../library/dataclasses.rst:395
msgid ""
"If you need to know if a class is an instance of a dataclass (and not a "
"dataclass itself), then add a further check for ``not isinstance(obj, "
"type)``::"
msgstr ""
"如果你需要知道一个类是否是一个数据类的实例（而不是一个数据类本身），那么再添加一个 ``not isinstance(obj, type)`` 检查::"

#: ../../library/dataclasses.rst:403
msgid "Post-init processing"
msgstr "初始化后处理"

#: ../../library/dataclasses.rst:405
msgid ""
"The generated :meth:`__init__` code will call a method named "
":meth:`__post_init__`, if :meth:`__post_init__` is defined on the class.  It"
" will normally be called as ``self.__post_init__()``. However, if any "
"``InitVar`` fields are defined, they will also be passed to "
":meth:`__post_init__` in the order they were defined in the class.  If no "
":meth:`__init__` method is generated, then :meth:`__post_init__` will not "
"automatically be called."
msgstr ""
"生成的 :meth:`__init__` 代码将调用一个名为 :meth:`__post_init__` 的方法，如果在类上已经定义了 "
":meth:`__post_init__` 。它通常被称为 ``self.__post_init__()`` 。但是，如果定义了任何 "
"``InitVar`` 字段，它们也将按照它们在类中定义的顺序传递给 :meth:`__post_init__` 。 如果没有 "
":meth:`__init__` 方法生成，那么 :meth:`__post_init__` 将不会被自动调用。"

#: ../../library/dataclasses.rst:413
msgid ""
"Among other uses, this allows for initializing field values that depend on "
"one or more other fields.  For example::"
msgstr "在其他用途中，这允许初始化依赖于一个或多个其他字段的字段值。例如::"

#: ../../library/dataclasses.rst:425
msgid ""
"See the section below on init-only variables for ways to pass parameters to "
":meth:`__post_init__`.  Also see the warning about how :func:`replace` "
"handles ``init=False`` fields."
msgstr ""
"有关将参数传递给 :meth:`__post_init__` 的方法，请参阅下面有关仅初始化变量的段落。另请参阅关于 :func:`replace` "
"处理 ``init=False`` 字段的警告。"

#: ../../library/dataclasses.rst:430
msgid "Class variables"
msgstr "类变量"

#: ../../library/dataclasses.rst:432
msgid ""
"One of two places where :func:`dataclass` actually inspects the type of a "
"field is to determine if a field is a class variable as defined in "
":pep:`526`.  It does this by checking if the type of the field is "
"``typing.ClassVar``.  If a field is a ``ClassVar``, it is excluded from "
"consideration as a field and is ignored by the dataclass mechanisms.  Such "
"``ClassVar`` pseudo-fields are not returned by the module-level "
":func:`fields` function."
msgstr ""
"两个地方 :func:`dataclass` 实际检查字段类型的之一是确定字段是否是如 :pep:`526` 所定义的类变量。它通过检查字段的类型是否为"
" ``typing.ClassVar`` 来完成此操作。如果一个字段是一个 ``ClassVar`` "
"，它将被排除在考虑范围之外，并被数据类机制忽略。这样的 ``ClassVar`` 伪字段不会由模块级的 :func:`fields` 函数返回。"

#: ../../library/dataclasses.rst:441
msgid "Init-only variables"
msgstr "仅初始化变量"

#: ../../library/dataclasses.rst:443
msgid ""
"The other place where :func:`dataclass` inspects a type annotation is to "
"determine if a field is an init-only variable.  It does this by seeing if "
"the type of a field is of type ``dataclasses.InitVar``.  If a field is an "
"``InitVar``, it is considered a pseudo-field called an init-only field.  As "
"it is not a true field, it is not returned by the module-level "
":func:`fields` function.  Init-only fields are added as parameters to the "
"generated :meth:`__init__` method, and are passed to the optional "
":meth:`__post_init__` method.  They are not otherwise used by dataclasses."
msgstr ""
"另一个 :func:`dataclass` 检查类型注解地方是为了确定一个字段是否是一个仅初始化变量。它通过查看字段的类型是否为 "
"``dataclasses.InitVar`` 类型来实现。如果一个字段是一个 ``InitVar`` "
"，它被认为是一个称为仅初始化字段的伪字段。因为它不是一个真正的字段，所以它不会被模块级的 :func:`fields` "
"函数返回。仅初始化字段作为参数添加到生成的 :meth:`__init__` 方法中，并传递给可选的 :meth:`__post_init__` "
"方法。数据类不会使用它们。"

#: ../../library/dataclasses.rst:453
msgid ""
"For example, suppose a field will be initialized from a database, if a value"
" is not provided when creating the class::"
msgstr "例如，假设一个字段将从数据库初始化，如果在创建类时未提供其值::"

#: ../../library/dataclasses.rst:468
msgid ""
"In this case, :func:`fields` will return :class:`Field` objects for ``i`` "
"and ``j``, but not for ``database``."
msgstr ""
"在这种情况下， :func:`fields` 将返回 ``i`` 和 ``j`` 的 :class:`Field` 对象，但不包括 "
"``database`` 。"

#: ../../library/dataclasses.rst:472
msgid "Frozen instances"
msgstr "冻结的实例"

#: ../../library/dataclasses.rst:474
msgid ""
"It is not possible to create truly immutable Python objects.  However, by "
"passing ``frozen=True`` to the :meth:`dataclass` decorator you can emulate "
"immutability.  In that case, dataclasses will add :meth:`__setattr__` and "
":meth:`__delattr__` methods to the class.  These methods will raise a "
":exc:`FrozenInstanceError` when invoked."
msgstr ""
"无法创建真正不可变的 Python 对象。但是，通过将 ``frozen=True`` 传递给 :meth:`dataclass` "
"装饰器，你可以模拟不变性。在这种情况下，数据类将向类添加 :meth:`__setattr__` 和 :meth:`__delattr__` 方法。 "
"些方法在调用时会引发 :exc:`FrozenInstanceError` 。"

#: ../../library/dataclasses.rst:480
msgid ""
"There is a tiny performance penalty when using ``frozen=True``: "
":meth:`__init__` cannot use simple assignment to initialize fields, and must"
" use :meth:`object.__setattr__`."
msgstr ""
"使用 ``frozen=True`` 时会有很小的性能损失： :meth:`__init__` 不能使用简单的赋值来初始化字段，并必须使用 "
":meth:`object.__setattr__`。"

#: ../../library/dataclasses.rst:485
msgid "Inheritance"
msgstr "继承"

#: ../../library/dataclasses.rst:487
msgid ""
"When the dataclass is being created by the :meth:`dataclass` decorator, it "
"looks through all of the class's base classes in reverse MRO (that is, "
"starting at :class:`object`) and, for each dataclass that it finds, adds the"
" fields from that base class to an ordered mapping of fields. After all of "
"the base class fields are added, it adds its own fields to the ordered "
"mapping.  All of the generated methods will use this combined, calculated "
"ordered mapping of fields.  Because the fields are in insertion order, "
"derived classes override base classes.  An example::"
msgstr ""
"当数组由 :meth:`dataclass` 装饰器创建时，它会查看反向 MRO 中的所有类的基类（即从 :class:`object` 开始 "
"），并且对于它找到的每个数据类， "
"将该基类中的字段添加到字段的有序映射中。添加完所有基类字段后，它会将自己的字段添加到有序映射中。所有生成的方法都将使用这种组合的，计算的有序字段映射。由于字段是按插入顺序排列的，因此派生类会重载基类。一个例子::"

#: ../../library/dataclasses.rst:507
msgid ""
"The final list of fields is, in order, ``x``, ``y``, ``z``.  The final type "
"of ``x`` is ``int``, as specified in class ``C``."
msgstr ""
"最后的字段列表依次是 ``x`` 、 ``y`` 、 ``z`` 。 ``x`` 的最终类型是 ``int`` ，如类 ``C`` 中所指定的那样。"

#: ../../library/dataclasses.rst:510
msgid "The generated :meth:`__init__` method for ``C`` will look like::"
msgstr "为 ``C`` 生成的 :meth:`__init__` 方法看起来像::"

#: ../../library/dataclasses.rst:515
msgid "Default factory functions"
msgstr "默认工厂函数"

#: ../../library/dataclasses.rst:517
msgid ""
"If a :func:`field` specifies a ``default_factory``, it is called with zero "
"arguments when a default value for the field is needed.  For example, to "
"create a new instance of a list, use::"
msgstr ""
"如果一个 :func:`field` 指定了一个 ``default_factory`` "
"，当需要该字段的默认值时，将使用零参数调用它。例如，要创建列表的新实例，请使用::"

#: ../../library/dataclasses.rst:523
msgid ""
"If a field is excluded from :meth:`__init__` (using ``init=False``) and the "
"field also specifies ``default_factory``, then the default factory function "
"will always be called from the generated :meth:`__init__` function.  This "
"happens because there is no other way to give the field an initial value."
msgstr ""
"如果一个字段被排除在 :meth:`__init__` 之外（使用 ``init=False`` ）并且字段也指定 "
"``default_factory`` ，则默认的工厂函数将始终从生成的 :meth:`__init__` "
"函数调用。发生这种情况是因为没有其他方法可以为字段提供初始值。"

#: ../../library/dataclasses.rst:530
msgid "Mutable default values"
msgstr "可变的默认值"

#: ../../library/dataclasses.rst:532
msgid ""
"Python stores default member variable values in class attributes. Consider "
"this example, not using dataclasses::"
msgstr "Python 在类属性中存储默认成员变量值。思考这个例子，不使用数据类::"

#: ../../library/dataclasses.rst:547
msgid ""
"Note that the two instances of class ``C`` share the same class variable "
"``x``, as expected."
msgstr "请注意，类 ``C`` 的两个实例共享相同的类变量 ``x`` ，如预期的那样。"

#: ../../library/dataclasses.rst:550
msgid "Using dataclasses, *if* this code was valid::"
msgstr "使用数据类， *如果* 此代码有效::"

#: ../../library/dataclasses.rst:558
msgid "it would generate code similar to::"
msgstr "它生成的代码类似于::"

#: ../../library/dataclasses.rst:569
msgid ""
"This has the same issue as the original example using class ``C``. That is, "
"two instances of class ``D`` that do not specify a value for ``x`` when "
"creating a class instance will share the same copy of ``x``.  Because "
"dataclasses just use normal Python class creation they also share this "
"behavior.  There is no general way for Data Classes to detect this "
"condition.  Instead, dataclasses will raise a :exc:`TypeError` if it detects"
" a default parameter of type ``list``, ``dict``, or ``set``.  This is a "
"partial solution, but it does protect against many common errors."
msgstr ""
"这与使用类 ``C`` 的原始示例具有相同的问题。也就是说，在创建类实例时没有为 ``x`` 指定值的类 ``D`` 的两个实例将共享相同的 ``x``"
" 副本。由于数据类只使用普通的 Python 类创建，因此它们也会共享此行为。数据类没有通用的方法来检测这种情况。相反，如果数据类检测到类型为 "
"``list`` 、 ``dict`` 或 ``set`` 的默认参数，则会引发 :exc:`TypeError` "
"。这是一个部分解决方案，但它可以防止许多常见错误。"

#: ../../library/dataclasses.rst:579
msgid ""
"Using default factory functions is a way to create new instances of mutable "
"types as default values for fields::"
msgstr "使用默认工厂函数是一种创建可变类型新实例的方法，并将其作为字段的默认值::"

#: ../../library/dataclasses.rst:589
msgid "Exceptions"
msgstr "异常"

#: ../../library/dataclasses.rst:593
msgid ""
"Raised when an implicitly defined :meth:`__setattr__` or :meth:`__delattr__`"
" is called on a dataclass which was defined with ``frozen=True``. It is a "
"subclass of :exc:`AttributeError`."
msgstr ""
"在使用 ``frozen=True`` 定义的数据类上调用隐式定义的 :meth:`__setattr__` 或 :meth:`__delattr__`"
" 时引发。 这是 :exc:`AttributeError` 的一个子类。"
