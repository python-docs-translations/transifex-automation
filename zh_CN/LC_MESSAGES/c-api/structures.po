# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# ppcfish <ppcfish@gmail.com>, 2020
# 8af080f2e6702c64bedd01873aed27e8_25aec74 <fd99d14239138a1f987c22e7736dde81_777475>, 2020
# Fw[a]rd <howard.main@outlook.com>, 2021
# Freesand Leo <yuqinju@163.com>, 2023
# Rafael Fontenelle <rffontenelle@gmail.com>, 2023
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-01-13 00:12+0000\n"
"PO-Revision-Date: 2020-05-30 11:51+0000\n"
"Last-Translator: Rafael Fontenelle <rffontenelle@gmail.com>, 2023\n"
"Language-Team: Chinese (China) (https://app.transifex.com/python-doc/"
"teams/5390/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../c-api/structures.rst:6
msgid "Common Object Structures"
msgstr "公用对象结构体"

#: ../../c-api/structures.rst:8
msgid ""
"There are a large number of structures which are used in the definition of "
"object types for Python.  This section describes these structures and how "
"they are used."
msgstr ""
"大量的结构体被用于定义Python的对象类型。这一节描述了这些的结构体和它们的使用"
"方法。"

#: ../../c-api/structures.rst:12
msgid ""
"All Python objects ultimately share a small number of fields at the "
"beginning of the object's representation in memory.  These are represented "
"by the :c:type:`PyObject` and :c:type:`PyVarObject` types, which are "
"defined, in turn, by the expansions of some macros also used, whether "
"directly or indirectly, in the definition of all other Python objects."
msgstr ""
"所有的 Python 对象都在对象的内存表示的开始部分共享少量的字段。 这些字段用 :c:"
"type:`PyObject` 或 :c:type:`PyVarObject` 类型来表示，这些类型又由一些宏定义，"
"这些宏也直接或间接地用于所有其他 Python 对象的定义。"

#: ../../c-api/structures.rst:21
msgid ""
"All object types are extensions of this type.  This is a type which contains "
"the information Python needs to treat a pointer to an object as an object.  "
"In a normal \"release\" build, it contains only the object's reference count "
"and a pointer to the corresponding type object. Nothing is actually declared "
"to be a :c:type:`PyObject`, but every pointer to a Python object can be cast "
"to a :c:type:`PyObject*`.  Access to the members must be done by using the "
"macros :c:macro:`Py_REFCNT` and :c:macro:`Py_TYPE`."
msgstr ""

#: ../../c-api/structures.rst:33
msgid ""
"This is an extension of :c:type:`PyObject` that adds the :attr:`ob_size` "
"field.  This is only used for objects that have some notion of *length*. "
"This type does not often appear in the Python/C API. Access to the members "
"must be done by using the macros :c:macro:`Py_REFCNT`, :c:macro:`Py_TYPE`, "
"and :c:macro:`Py_SIZE`."
msgstr ""
"这是一个 :c:type:`PyObject` 的添加了 :attr:`ob_size` 字段的扩展。 它仅用于具"
"有某种 *长度* 标记的对象。 此类型并不经常在 Python/C API 中出现。 对成员的访"
"问必须通过使用 :c:macro:`Py_REFCNT`, :c:macro:`Py_TYPE` 和 :c:macro:"
"`Py_SIZE` 宏来完成。"

#: ../../c-api/structures.rst:42
msgid ""
"This is a macro used when declaring new types which represent objects "
"without a varying length.  The PyObject_HEAD macro expands to::"
msgstr ""
"这是一个在声明代表无可变长度对象的新类型时所使用的宏。 PyObject_HEAD 宏被扩展"
"为::"

#: ../../c-api/structures.rst:47
msgid "See documentation of :c:type:`PyObject` above."
msgstr "参见上面 :c:type:`PyObject` 的文档。"

#: ../../c-api/structures.rst:52
msgid ""
"This is a macro used when declaring new types which represent objects with a "
"length that varies from instance to instance. The PyObject_VAR_HEAD macro "
"expands to::"
msgstr ""
"这是一个在声明代表每个实例具有可变长度的对象时所使用的宏。 PyObject_VAR_HEAD "
"宏被扩展为::"

#: ../../c-api/structures.rst:58
msgid "See documentation of :c:type:`PyVarObject` above."
msgstr "参见上面 :c:type:`PyVarObject` 的文档。"

#: ../../c-api/structures.rst:63
msgid ""
"This macro is used to access the :attr:`ob_type` member of a Python object. "
"It expands to::"
msgstr ""

#: ../../c-api/structures.rst:71
msgid ""
"This macro is used to access the :attr:`ob_refcnt` member of a Python "
"object. It expands to::"
msgstr ""

#: ../../c-api/structures.rst:80
msgid ""
"This macro is used to access the :attr:`ob_size` member of a Python object. "
"It expands to::"
msgstr ""

#: ../../c-api/structures.rst:88
msgid ""
"This is a macro which expands to initialization values for a new :c:type:"
"`PyObject` type.  This macro expands to::"
msgstr "这是一个为新的 :c:type:`PyObject` 类型扩展初始化值的宏。 该宏扩展为::"

#: ../../c-api/structures.rst:97
msgid ""
"This is a macro which expands to initialization values for a new :c:type:"
"`PyVarObject` type, including the :attr:`ob_size` field. This macro expands "
"to::"
msgstr ""
"这是一个为新的 :c:type:`PyVarObject` 类型扩展初始化值的宏，包括 :attr:"
"`ob_size` 字段。 该宏扩展为::"

#: ../../c-api/structures.rst:107
msgid ""
"Type of the functions used to implement most Python callables in C. "
"Functions of this type take two :c:type:`PyObject*` parameters and return "
"one such value.  If the return value is ``NULL``, an exception shall have "
"been set.  If not ``NULL``, the return value is interpreted as the return "
"value of the function as exposed in Python.  The function must return a new "
"reference."
msgstr ""

#: ../../c-api/structures.rst:117
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :const:`METH_VARARGS | METH_KEYWORDS`."
msgstr ""

#: ../../c-api/structures.rst:123
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :const:`METH_FASTCALL`."
msgstr ""

#: ../../c-api/structures.rst:129
msgid ""
"Type of the functions used to implement Python callables in C with "
"signature :const:`METH_FASTCALL | METH_KEYWORDS`."
msgstr ""

#: ../../c-api/structures.rst:135
msgid ""
"Structure used to describe a method of an extension type.  This structure "
"has four fields:"
msgstr "用于描述一个扩展类型的方法的结构体。 该结构体有四个字段:"

#: ../../c-api/structures.rst:139 ../../c-api/structures.rst:279
#: ../../c-api/structures.rst:345
msgid "Field"
msgstr "域"

#: ../../c-api/structures.rst:139 ../../c-api/structures.rst:279
#: ../../c-api/structures.rst:345
msgid "C Type"
msgstr "C 类型"

#: ../../c-api/structures.rst:139 ../../c-api/structures.rst:279
#: ../../c-api/structures.rst:345
msgid "Meaning"
msgstr "含意"

#: ../../c-api/structures.rst:141
msgid ":attr:`ml_name`"
msgstr ":attr:`ml_name`"

#: ../../c-api/structures.rst:141 ../../c-api/structures.rst:149
#: ../../c-api/structures.rst:281 ../../c-api/structures.rst:294
#: ../../c-api/structures.rst:310 ../../c-api/structures.rst:347
#: ../../c-api/structures.rst:355
msgid "const char \\*"
msgstr "const char \\*"

#: ../../c-api/structures.rst:141
msgid "name of the method"
msgstr "方法名"

#: ../../c-api/structures.rst:143
msgid ":attr:`ml_meth`"
msgstr ":attr:`ml_meth`"

#: ../../c-api/structures.rst:143
msgid "PyCFunction"
msgstr ""

#: ../../c-api/structures.rst:143
msgid "pointer to the C implementation"
msgstr "指向 C 实现的指针"

#: ../../c-api/structures.rst:146
msgid ":attr:`ml_flags`"
msgstr ""

#: ../../c-api/structures.rst:146 ../../c-api/structures.rst:283
#: ../../c-api/structures.rst:290 ../../c-api/structures.rst:306
msgid "int"
msgstr "int"

#: ../../c-api/structures.rst:146
msgid "flag bits indicating how the call should be constructed"
msgstr ""

#: ../../c-api/structures.rst:149
msgid ":attr:`ml_doc`"
msgstr ":attr:`ml_doc`"

#: ../../c-api/structures.rst:149 ../../c-api/structures.rst:294
msgid "points to the contents of the docstring"
msgstr "指向文档字符串的内容"

#: ../../c-api/structures.rst:153
msgid ""
"The :attr:`ml_meth` is a C function pointer.  The functions may be of "
"different types, but they always return :c:type:`PyObject*`.  If the "
"function is not of the :c:type:`PyCFunction`, the compiler will require a "
"cast in the method table. Even though :c:type:`PyCFunction` defines the "
"first parameter as :c:type:`PyObject*`, it is common that the method "
"implementation uses the specific C type of the *self* object."
msgstr ""

#: ../../c-api/structures.rst:160
msgid ""
"The :attr:`ml_flags` field is a bitfield which can include the following "
"flags. The individual flags indicate either a calling convention or a "
"binding convention."
msgstr ""

#: ../../c-api/structures.rst:164
msgid ""
"There are four basic calling conventions for positional arguments and two of "
"them can be combined with :const:`METH_KEYWORDS` to support also keyword "
"arguments.  So there are a total of 6 calling conventions:"
msgstr ""

#: ../../c-api/structures.rst:170
msgid ""
"This is the typical calling convention, where the methods have the type :c:"
"type:`PyCFunction`. The function expects two :c:type:`PyObject*` values. The "
"first one is the *self* object for methods; for module functions, it is the "
"module object.  The second parameter (often called *args*) is a tuple object "
"representing all arguments. This parameter is typically processed using :c:"
"func:`PyArg_ParseTuple` or :c:func:`PyArg_UnpackTuple`."
msgstr ""

#: ../../c-api/structures.rst:180
msgid ""
"Methods with these flags must be of type :c:type:`PyCFunctionWithKeywords`. "
"The function expects three parameters: *self*, *args*, *kwargs* where "
"*kwargs* is a dictionary of all the keyword arguments or possibly ``NULL`` "
"if there are no keyword arguments.  The parameters are typically processed "
"using :c:func:`PyArg_ParseTupleAndKeywords`."
msgstr ""
"带有这些旗标的方法必须为 :c:type:`PyCFunctionWithKeywords` 类型。 该函数接受"
"三个形参: *self*, *args*, *kwargs* 其中 *kwargs* 是一个包含所有关键字参数的字"
"典或者如果没有关键字参数则可以为 ``NULL``。 这些形参通常是使用 :c:func:"
"`PyArg_ParseTupleAndKeywords` 来处理的。"

#: ../../c-api/structures.rst:189
msgid ""
"Fast calling convention supporting only positional arguments. The methods "
"have the type :c:type:`_PyCFunctionFast`. The first parameter is *self*, the "
"second parameter is a C array of :c:type:`PyObject*` values indicating the "
"arguments and the third parameter is the number of arguments (the length of "
"the array)."
msgstr ""

#: ../../c-api/structures.rst:195 ../../c-api/structures.rst:210
msgid "This is not part of the :ref:`limited API <stable>`."
msgstr ""

#: ../../c-api/structures.rst:202
msgid ""
"Extension of :const:`METH_FASTCALL` supporting also keyword arguments, with "
"methods of type :c:type:`_PyCFunctionFastWithKeywords`. Keyword arguments "
"are passed the same way as in the vectorcall protocol: there is an "
"additional fourth :c:type:`PyObject*` parameter which is a tuple "
"representing the names of the keyword arguments or possibly ``NULL`` if "
"there are no keywords.  The values of the keyword arguments are stored in "
"the *args* array, after the positional arguments."
msgstr ""

#: ../../c-api/structures.rst:217
msgid ""
"Methods without parameters don't need to check whether arguments are given "
"if they are listed with the :const:`METH_NOARGS` flag.  They need to be of "
"type :c:type:`PyCFunction`.  The first parameter is typically named *self* "
"and will hold a reference to the module or object instance.  In all cases "
"the second parameter will be ``NULL``."
msgstr ""
"没有形参的方法如果通过 :const:`METH_NOARGS` 旗标列出了参数则不需要检查是否提"
"供了参数。 它们必须为 :c:type:`PyCFunction` 类型。 第一个形参通常命名为 "
"*self* 并将存放一个指向模块或对象实例的引用。 在所有情况下第二个形参都将为 "
"``NULL``。"

#: ../../c-api/structures.rst:226
msgid ""
"Methods with a single object argument can be listed with the :const:`METH_O` "
"flag, instead of invoking :c:func:`PyArg_ParseTuple` with a ``\"O\"`` "
"argument. They have the type :c:type:`PyCFunction`, with the *self* "
"parameter, and a :c:type:`PyObject*` parameter representing the single "
"argument."
msgstr ""

#: ../../c-api/structures.rst:232
msgid ""
"These two constants are not used to indicate the calling convention but the "
"binding when use with methods of classes.  These may not be used for "
"functions defined for modules.  At most one of these flags may be set for "
"any given method."
msgstr ""
"这两个常量不是被用来指明调用惯例而是在配合类方法使用时指明绑定。 它们不会被用"
"于在模块上定义的函数。 对于任何给定方法这些旗标最多只会设置其中一个。"

#: ../../c-api/structures.rst:242
msgid ""
"The method will be passed the type object as the first parameter rather than "
"an instance of the type.  This is used to create *class methods*, similar to "
"what is created when using the :func:`classmethod` built-in function."
msgstr ""
"该方法将接受类型对象而不是类型的实例作为第一个形参。 它会被用于创建 *类方法"
"*，类似于使用 :func:`classmethod` 内置函数所创建的结果。"

#: ../../c-api/structures.rst:252
msgid ""
"The method will be passed ``NULL`` as the first parameter rather than an "
"instance of the type.  This is used to create *static methods*, similar to "
"what is created when using the :func:`staticmethod` built-in function."
msgstr ""
"该方法将接受 ``NULL`` 而不是类型的实例作为第一个形参。 它会被用于创建 *静态方"
"法*，类似于使用 :func:`staticmethod` 内置函数所创建的结果。"

#: ../../c-api/structures.rst:256
msgid ""
"One other constant controls whether a method is loaded in place of another "
"definition with the same method name."
msgstr "另一个常量控制方法是否将被载入来替代具有相同方法名的另一个定义。"

#: ../../c-api/structures.rst:262
msgid ""
"The method will be loaded in place of existing definitions.  Without "
"*METH_COEXIST*, the default is to skip repeated definitions.  Since slot "
"wrappers are loaded before the method table, the existence of a "
"*sq_contains* slot, for example, would generate a wrapped method named :meth:"
"`__contains__` and preclude the loading of a corresponding PyCFunction with "
"the same name.  With the flag defined, the PyCFunction will be loaded in "
"place of the wrapper object and will co-exist with the slot.  This is "
"helpful because calls to PyCFunctions are optimized more than wrapper object "
"calls."
msgstr ""
"该方法将被载入来替代现有的定义。 如果没有 *METH_COEXIST*，默认将跳过重复的定"
"义。 由于槽位包装器会在方法表之前被载入，例如当存在 *sq_contains* 槽位时，将"
"会生成一个名为 :meth:`__contains__` 的已包装方法并阻止载入具有相同名称的对应 "
"PyCFunction。 如果定义了此旗标，则 PyCFunction 将被载入来替代此包装器对象并将"
"与槽位共存。 因为对This is helpful because calls to PyCFunctions 的调用比包装"
"器对象调用更为优化所以这是很有帮助的。"

#: ../../c-api/structures.rst:275
msgid ""
"Structure which describes an attribute of a type which corresponds to a C "
"struct member.  Its fields are:"
msgstr "描述与某个 C 结构体成员相对应的类型的属性的结构体。 它的字段有:"

#: ../../c-api/structures.rst:281
msgid ":attr:`name`"
msgstr ":attr:`name`"

#: ../../c-api/structures.rst:281
msgid "name of the member"
msgstr "成员名称"

#: ../../c-api/structures.rst:283
msgid ":attr:`!type`"
msgstr ":attr:`!type`"

#: ../../c-api/structures.rst:283
msgid "the type of the member in the C struct"
msgstr "C 结构体中成员的类型"

#: ../../c-api/structures.rst:286
msgid ":attr:`offset`"
msgstr ":attr:`offset`"

#: ../../c-api/structures.rst:286 ../../c-api/structures.rst:322
msgid "Py_ssize_t"
msgstr "Py_ssize_t"

#: ../../c-api/structures.rst:286
msgid ""
"the offset in bytes that the member is located on the type's object struct"
msgstr "成员在类型的对象结构体中所在位置的以字节表示的偏移量"

#: ../../c-api/structures.rst:290
msgid ":attr:`flags`"
msgstr ":attr:`flags`"

#: ../../c-api/structures.rst:290
msgid "flag bits indicating if the field should be read-only or writable"
msgstr "指明字段是否应为只读或可写的旗标位"

#: ../../c-api/structures.rst:294
msgid ":attr:`doc`"
msgstr ":attr:`doc`"

#: ../../c-api/structures.rst:298
msgid ""
":attr:`!type` can be one of many ``T_`` macros corresponding to various C "
"types.  When the member is accessed in Python, it will be converted to the "
"equivalent Python type."
msgstr ""
":attr:`!type` 可以是与各种 C 类型相对应的许多 ``T_`` 宏中的一个。 当在 "
"Python 中访问该成员时，它将被转换为等价的 Python 类型。"

#: ../../c-api/structures.rst:303
msgid "Macro name"
msgstr "宏名称"

#: ../../c-api/structures.rst:303
msgid "C type"
msgstr "C 类型"

#: ../../c-api/structures.rst:305
msgid "T_SHORT"
msgstr "T_SHORT"

#: ../../c-api/structures.rst:305
msgid "short"
msgstr "short"

#: ../../c-api/structures.rst:306
msgid "T_INT"
msgstr "T_INT"

#: ../../c-api/structures.rst:307
msgid "T_LONG"
msgstr "T_LONG"

#: ../../c-api/structures.rst:307
msgid "long"
msgstr "长整型"

#: ../../c-api/structures.rst:308
msgid "T_FLOAT"
msgstr "T_FLOAT"

#: ../../c-api/structures.rst:308
msgid "float"
msgstr "float"

#: ../../c-api/structures.rst:309
msgid "T_DOUBLE"
msgstr "T_DOUBLE"

#: ../../c-api/structures.rst:309
msgid "double"
msgstr "double"

#: ../../c-api/structures.rst:310
msgid "T_STRING"
msgstr "T_STRING"

#: ../../c-api/structures.rst:311
msgid "T_OBJECT"
msgstr "T_OBJECT"

#: ../../c-api/structures.rst:311 ../../c-api/structures.rst:312
msgid "PyObject \\*"
msgstr "PyObject \\*"

#: ../../c-api/structures.rst:312
msgid "T_OBJECT_EX"
msgstr "T_OBJECT_EX"

#: ../../c-api/structures.rst:313
msgid "T_CHAR"
msgstr "T_CHAR"

#: ../../c-api/structures.rst:313 ../../c-api/structures.rst:314
#: ../../c-api/structures.rst:319
msgid "char"
msgstr "char"

#: ../../c-api/structures.rst:314
msgid "T_BYTE"
msgstr "T_BYTE"

#: ../../c-api/structures.rst:315
msgid "T_UBYTE"
msgstr "T_UBYTE"

#: ../../c-api/structures.rst:315
msgid "unsigned char"
msgstr "unsigned char"

#: ../../c-api/structures.rst:316
msgid "T_UINT"
msgstr "T_UINT"

#: ../../c-api/structures.rst:316
msgid "unsigned int"
msgstr "unsigned int"

#: ../../c-api/structures.rst:317
msgid "T_USHORT"
msgstr "T_USHORT"

#: ../../c-api/structures.rst:317
msgid "unsigned short"
msgstr "unsigned short"

#: ../../c-api/structures.rst:318
msgid "T_ULONG"
msgstr "T_ULONG"

#: ../../c-api/structures.rst:318
msgid "unsigned long"
msgstr "unsigned long"

#: ../../c-api/structures.rst:319
msgid "T_BOOL"
msgstr "T_BOOL"

#: ../../c-api/structures.rst:320
msgid "T_LONGLONG"
msgstr "T_LONGLONG"

#: ../../c-api/structures.rst:320
msgid "long long"
msgstr "long long"

#: ../../c-api/structures.rst:321
msgid "T_ULONGLONG"
msgstr "T_ULONGLONG"

#: ../../c-api/structures.rst:321
msgid "unsigned long long"
msgstr "unsigned long long"

#: ../../c-api/structures.rst:322
msgid "T_PYSSIZET"
msgstr "T_PYSSIZET"

#: ../../c-api/structures.rst:325
msgid ""
":c:macro:`T_OBJECT` and :c:macro:`T_OBJECT_EX` differ in that :c:macro:"
"`T_OBJECT` returns ``None`` if the member is ``NULL`` and :c:macro:"
"`T_OBJECT_EX` raises an :exc:`AttributeError`.  Try to use :c:macro:"
"`T_OBJECT_EX` over :c:macro:`T_OBJECT` because :c:macro:`T_OBJECT_EX` "
"handles use of the :keyword:`del` statement on that attribute more correctly "
"than :c:macro:`T_OBJECT`."
msgstr ""
":c:macro:`T_OBJECT` 和 :c:macro:`T_OBJECT_EX` 的区别在于 :c:macro:`T_OBJECT` "
"返回 ``None`` 表示其成员为 ``NULL`` 并且 :c:macro:`T_OBJECT_EX` 引发了 :exc:"
"`AttributeError`。 请尝试使用 :c:macro:`T_OBJECT_EX` 取代 :c:macro:"
"`T_OBJECT` 因为 :c:macro:`T_OBJECT_EX` 处理在属性上使用 :keyword:`del` 语句"
"比 :c:macro:`T_OBJECT` 更正确。"

#: ../../c-api/structures.rst:332
msgid ""
":attr:`flags` can be ``0`` for write and read access or :c:macro:`READONLY` "
"for read-only access.  Using :c:macro:`T_STRING` for :attr:`type` implies :c:"
"macro:`READONLY`.  :c:macro:`T_STRING` data is interpreted as UTF-8. Only :c:"
"macro:`T_OBJECT` and :c:macro:`T_OBJECT_EX` members can be deleted.  (They "
"are set to ``NULL``)."
msgstr ""
":attr:`flags` 可以为 ``0`` 表示读写访问或 :c:macro:`READONLY` 表示只读访问。 "
"使用 :c:macro:`T_STRING` 作为 :attr:`type` 表示 :c:macro:`READONLY`。 :c:"
"macro:`T_STRING` 数据将被解读为 UTF-8 编码格式。 只有 :c:macro:`T_OBJECT` "
"和 :c:macro:`T_OBJECT_EX` 成员可以被删除。 (它们会被设为 ``NULL``)。"

#: ../../c-api/structures.rst:341
msgid ""
"Structure to define property-like access for a type. See also description of "
"the :c:member:`PyTypeObject.tp_getset` slot."
msgstr ""
"用于定义针对某个类型的特征属性式的访问的结构体。 另请参阅 :c:member:"
"`PyTypeObject.tp_getset` 槽位的描述。"

#: ../../c-api/structures.rst:347
msgid "name"
msgstr "name"

#: ../../c-api/structures.rst:347
msgid "attribute name"
msgstr "属性名称"

#: ../../c-api/structures.rst:349
msgid "get"
msgstr "get"

#: ../../c-api/structures.rst:349
msgid "getter"
msgstr "getter"

#: ../../c-api/structures.rst:349
msgid "C Function to get the attribute"
msgstr ""

#: ../../c-api/structures.rst:351
msgid "set"
msgstr "set"

#: ../../c-api/structures.rst:351
msgid "setter"
msgstr "setter"

#: ../../c-api/structures.rst:351
msgid ""
"optional C function to set or delete the attribute, if omitted the attribute "
"is readonly"
msgstr "用于设置或删除属性的可选 C 函数，如果省略则属性将为只读"

#: ../../c-api/structures.rst:355
msgid "doc"
msgstr "doc"

#: ../../c-api/structures.rst:355
msgid "optional docstring"
msgstr "可选的文档字符串"

#: ../../c-api/structures.rst:357
msgid "closure"
msgstr "closure"

#: ../../c-api/structures.rst:357
msgid "void \\*"
msgstr "void \\*"

#: ../../c-api/structures.rst:357
msgid ""
"optional function pointer, providing additional data for getter and setter"
msgstr "可选的函数指针，为 getter 和 setter 提供附加数据"

#: ../../c-api/structures.rst:362
msgid ""
"The ``get`` function takes one :c:type:`PyObject*` parameter (the instance) "
"and a function pointer (the associated ``closure``)::"
msgstr ""

#: ../../c-api/structures.rst:367
msgid ""
"It should return a new reference on success or ``NULL`` with a set exception "
"on failure."
msgstr "它应当在成功时返回一个新的引用或在失败时返回 ``NULL`` 并设置异常。"

#: ../../c-api/structures.rst:370
msgid ""
"``set`` functions take two :c:type:`PyObject*` parameters (the instance and "
"the value to be set) and a function pointer (the associated ``closure``)::"
msgstr ""

#: ../../c-api/structures.rst:375
msgid ""
"In case the attribute should be deleted the second parameter is ``NULL``. "
"Should return ``0`` on success or ``-1`` with a set exception on failure."
msgstr ""
"对于属性要被删除的情况第二个形参应为 ``NULL``。 成功时应返回 ``0`` 或在失败时"
"返回 ``-1`` 并设置异常。"
