# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2023, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.9\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-06-23 15:52+0000\n"
"PO-Revision-Date: 2017-02-16 23:27+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://app.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

#: ../../library/sqlite3.rst:2
msgid ":mod:`sqlite3` --- DB-API 2.0 interface for SQLite databases"
msgstr ":mod:`sqlite3` --- інтерфейс DB-API 2.0 для баз даних SQLite"

#: ../../library/sqlite3.rst:9
msgid "**Source code:** :source:`Lib/sqlite3/`"
msgstr "**Вихідний код:** :source:`Lib/sqlite3/`"

#: ../../library/sqlite3.rst:13
msgid ""
"SQLite is a C library that provides a lightweight disk-based database that "
"doesn't require a separate server process and allows accessing the database "
"using a nonstandard variant of the SQL query language. Some applications can "
"use SQLite for internal data storage.  It's also possible to prototype an "
"application using SQLite and then port the code to a larger database such as "
"PostgreSQL or Oracle."
msgstr ""
"SQLite — це бібліотека C, яка надає легку дискову базу даних, яка не "
"потребує окремого серверного процесу та дозволяє отримувати доступ до бази "
"даних за допомогою нестандартного варіанту мови запитів SQL. Деякі програми "
"можуть використовувати SQLite для внутрішнього зберігання даних. Також можна "
"створити прототип програми за допомогою SQLite, а потім перенести код у "
"більшу базу даних, таку як PostgreSQL або Oracle."

#: ../../library/sqlite3.rst:20
msgid ""
"The sqlite3 module was written by Gerhard Häring.  It provides an SQL "
"interface compliant with the DB-API 2.0 specification described by :pep:"
"`249`."
msgstr ""

#: ../../library/sqlite3.rst:23
msgid ""
"To use the module, start by creating a :class:`Connection` object that "
"represents the database.  Here the data will be stored in the :file:`example."
"db` file::"
msgstr ""
"Щоб використовувати модуль, почніть із створення об’єкта :class:"
"`Connection`, який представлятиме базу даних. Тут дані зберігатимуться у "
"файлі :file:`example.db`::"

#: ../../library/sqlite3.rst:30
msgid ""
"The special path name ``:memory:`` can be provided to create a temporary "
"database in RAM."
msgstr ""
"Для створення тимчасової бази даних у оперативній пам’яті можна вказати "
"спеціальне ім’я шляху ``:memory:``."

#: ../../library/sqlite3.rst:33
msgid ""
"Once a :class:`Connection` has been established, create a :class:`Cursor` "
"object and call its :meth:`~Cursor.execute` method to perform SQL commands::"
msgstr ""
"Після встановлення :class:`Connection` створіть об’єкт :class:`Cursor` і "
"викличте його метод :meth:`~Cursor.execute` для виконання команд SQL::"

#: ../../library/sqlite3.rst:52
msgid ""
"The saved data is persistent: it can be reloaded in a subsequent session "
"even after restarting the Python interpreter::"
msgstr ""
"Збережені дані є постійними: їх можна перезавантажити в наступному сеансі "
"навіть після перезапуску інтерпретатора Python::"

#: ../../library/sqlite3.rst:59
msgid ""
"To retrieve data after executing a SELECT statement, either treat the cursor "
"as an :term:`iterator`, call the cursor's :meth:`~Cursor.fetchone` method to "
"retrieve a single matching row, or call :meth:`~Cursor.fetchall` to get a "
"list of the matching rows."
msgstr ""
"Щоб отримати дані після виконання оператора SELECT, обробляйте курсор як :"
"term:`iterator`, викличте метод курсора :meth:`~Cursor.fetchone`, щоб "
"отримати один відповідний рядок, або викликайте :meth:`~Cursor .fetchall`, "
"щоб отримати список відповідних рядків."

#: ../../library/sqlite3.rst:64
msgid "This example uses the iterator form::"
msgstr "У цьому прикладі використовується форма ітератора::"

#: ../../library/sqlite3.rst:77
msgid ""
"SQL operations usually need to use values from Python variables. However, "
"beware of using Python's string operations to assemble queries, as they are "
"vulnerable to SQL injection attacks (see the `xkcd webcomic <https://xkcd."
"com/327/>`_ for a humorous example of what can go wrong)::"
msgstr ""
"Для операцій SQL зазвичай потрібно використовувати значення зі змінних "
"Python. Однак остерігайтеся використання рядкових операцій Python для "
"збирання запитів, оскільки вони вразливі до атак SQL-ін’єкцій (дивіться "
"`xkcd webcomic <https://xkcd.com/327/>`_ для жартівливого прикладу того, що "
"може піти не так):"

#: ../../library/sqlite3.rst:86
msgid ""
"Instead, use the DB-API's parameter substitution. To insert a variable into "
"a query string, use a placeholder in the string, and substitute the actual "
"values into the query by providing them as a :class:`tuple` of values to the "
"second argument of the cursor's :meth:`~Cursor.execute` method. An SQL "
"statement may use one of two kinds of placeholders: question marks (qmark "
"style) or named placeholders (named style). For the qmark style, "
"``parameters`` must be a :term:`sequence <sequence>`. For the named style, "
"it can be either a :term:`sequence <sequence>` or :class:`dict` instance. "
"The length of the :term:`sequence <sequence>` must match the number of "
"placeholders, or a :exc:`ProgrammingError` is raised. If a :class:`dict` is "
"given, it must contain keys for all named parameters. Any extra items are "
"ignored. Here's an example of both styles:"
msgstr ""
"Замість цього використовуйте підстановку параметрів DB-API. Щоб вставити "
"змінну в рядок запиту, використовуйте заповнювач у рядку та підставте "
"фактичні значення в запит, надавши їх як :class:`tuple` значень у другому "
"аргументі :meth:`~курсора курсора .execute` метод. Інструкція SQL може "
"використовувати один із двох видів заповнювачів: знаки питання (стиль qmark) "
"або іменовані заповнювачі (іменований стиль). Для стилю qmark ``параметри`` "
"мають бути :term:`послідовністю <sequence>`. Для названого стилю це може "
"бути екземпляр :term:`sequence <sequence>` або :class:`dict`. Довжина :term:"
"`послідовності <sequence>` має збігатися з кількістю заповнювачів, інакше "
"виникне :exc:`ProgrammingError`. Якщо вказано :class:`dict`, він повинен "
"містити ключі для всіх названих параметрів. Будь-які додаткові елементи "
"ігноруються. Ось приклад обох стилів:"

#: ../../library/sqlite3.rst:106
msgid "https://www.sqlite.org"
msgstr "https://www.sqlite.org"

#: ../../library/sqlite3.rst:105
msgid ""
"The SQLite web page; the documentation describes the syntax and the "
"available data types for the supported SQL dialect."
msgstr ""
"Веб-сторінка SQLite; документація описує синтаксис і доступні типи даних для "
"підтримуваного діалекту SQL."

#: ../../library/sqlite3.rst:109
msgid "https://www.w3schools.com/sql/"
msgstr "https://www.w3schools.com/sql/"

#: ../../library/sqlite3.rst:109
msgid "Tutorial, reference and examples for learning SQL syntax."
msgstr "Підручник, довідник і приклади для вивчення синтаксису SQL."

#: ../../library/sqlite3.rst:111
msgid ":pep:`249` - Database API Specification 2.0"
msgstr ":pep:`249` - Специфікація API бази даних 2.0"

#: ../../library/sqlite3.rst:112
msgid "PEP written by Marc-André Lemburg."
msgstr "PEP, написаний Марком-Андре Лембургом."

#: ../../library/sqlite3.rst:118
msgid "Module functions and constants"
msgstr "Функції модуля та константи"

#: ../../library/sqlite3.rst:123
msgid ""
"String constant stating the supported DB-API level. Required by the DB-API. "
"Hard-coded to ``\"2.0\"``."
msgstr ""
"Рядкова константа, що вказує підтримуваний рівень DB-API. Потрібний для DB-"
"API. Жорстко закодований на ``\"2.0\"``."

#: ../../library/sqlite3.rst:128
msgid ""
"String constant stating the type of parameter marker formatting expected by "
"the :mod:`sqlite3` module. Required by the DB-API. Hard-coded to "
"``\"qmark\"``."
msgstr ""
"Рядкова константа, що вказує тип форматування маркера параметра, який очікує "
"модуль :mod:`sqlite3`. Потрібний для DB-API. Жорстко закодований на "
"``\"qmark\"``."

#: ../../library/sqlite3.rst:134
msgid ""
"The :mod:`sqlite3` module supports both ``qmark`` and ``numeric`` DB-API "
"parameter styles, because that is what the underlying SQLite library "
"supports. However, the DB-API does not allow multiple values for the "
"``paramstyle`` attribute."
msgstr ""
"Модуль :mod:`sqlite3` підтримує як стилі параметрів ``qmark``, так і "
"``numeric`` DB-API, тому що це те, що підтримує базова бібліотека SQLite. "
"Однак DB-API не допускає кількох значень для атрибута ``paramstyle``."

#: ../../library/sqlite3.rst:141
msgid ""
"The version number of this module, as a string. This is not the version of "
"the SQLite library."
msgstr ""
"Номер версії цього модуля у вигляді рядка. Це не версія бібліотеки SQLite."

#: ../../library/sqlite3.rst:147
msgid ""
"The version number of this module, as a tuple of integers. This is not the "
"version of the SQLite library."
msgstr ""
"Номер версії цього модуля у вигляді кортежу цілих чисел. Це не версія "
"бібліотеки SQLite."

#: ../../library/sqlite3.rst:153
msgid "The version number of the run-time SQLite library, as a string."
msgstr "Номер версії бібліотеки SQLite під час виконання у вигляді рядка."

#: ../../library/sqlite3.rst:158
msgid ""
"The version number of the run-time SQLite library, as a tuple of integers."
msgstr ""
"Номер версії бібліотеки SQLite під час виконання у вигляді кортежу цілих "
"чисел."

#: ../../library/sqlite3.rst:163
msgid ""
"Integer constant required by the DB-API, stating the level of thread safety "
"the :mod:`sqlite3` module supports. Currently hard-coded to ``1``, meaning "
"*\"Threads may share the module, but not connections.\"* However, this may "
"not always be true. You can check the underlying SQLite library's compile-"
"time threaded mode using the following query::"
msgstr ""

#: ../../library/sqlite3.rst:176
msgid ""
"Note that the `SQLITE_THREADSAFE levels <https://sqlite.org/compile."
"html#threadsafe>`_ do not match the DB-API 2.0 ``threadsafety`` levels."
msgstr ""

#: ../../library/sqlite3.rst:183 ../../library/sqlite3.rst:196
msgid ""
"This constant is meant to be used with the *detect_types* parameter of the :"
"func:`connect` function."
msgstr ""

#: ../../library/sqlite3.rst:186
msgid ""
"Setting it makes the :mod:`sqlite3` module parse the declared type for each "
"column it returns.  It will parse out the first word of the declared type, "
"i. e.  for \"integer primary key\", it will parse out \"integer\", or for "
"\"number(10)\" it will parse out \"number\". Then for that column, it will "
"look into the converters dictionary and use the converter function "
"registered for that type there."
msgstr ""

#: ../../library/sqlite3.rst:199
msgid ""
"Setting this makes the SQLite interface parse the column name for each "
"column it returns.  It will look for a string formed [mytype] in there, and "
"then decide that 'mytype' is the type of the column. It will try to find an "
"entry of 'mytype' in the converters dictionary and then use the converter "
"function found there to return the value. The column name found in :attr:"
"`Cursor.description` does not include the type, i. e. if you use something "
"like ``'as \"Expiration date [datetime]\"'`` in your SQL, then we will parse "
"out everything until the first ``'['`` for the column name and strip the "
"preceding space: the column name would simply be \"Expiration date\"."
msgstr ""

#: ../../library/sqlite3.rst:212
msgid ""
"Opens a connection to the SQLite database file *database*. By default "
"returns a :class:`Connection` object, unless a custom *factory* is given."
msgstr ""
"Відкриває підключення до файлу бази даних SQLite *database*. За "
"замовчуванням повертає об’єкт :class:`Connection`, якщо не вказано "
"спеціальну *фабрику*."

#: ../../library/sqlite3.rst:215
msgid ""
"*database* is a :term:`path-like object` giving the pathname (absolute or "
"relative to the current  working directory) of the database file to be "
"opened. You can use ``\":memory:\"`` to open a database connection to a "
"database that resides in RAM instead of on disk."
msgstr ""
"*database* — це :term:`path-like object`, який надає шлях (абсолютний або "
"відносний до поточного робочого каталогу) до файлу бази даних, який потрібно "
"відкрити. Ви можете використовувати ``\":memory:\"``, щоб відкрити "
"підключення до бази даних, яка знаходиться в оперативній пам’яті, а не на "
"диску."

#: ../../library/sqlite3.rst:220
msgid ""
"When a database is accessed by multiple connections, and one of the "
"processes modifies the database, the SQLite database is locked until that "
"transaction is committed. The *timeout* parameter specifies how long the "
"connection should wait for the lock to go away until raising an exception. "
"The default for the timeout parameter is 5.0 (five seconds)."
msgstr ""
"Коли доступ до бази даних здійснюється через кілька з’єднань, і один із "
"процесів змінює базу даних, база даних SQLite блокується, доки ця транзакція "
"не буде зафіксована. Параметр *timeout* визначає, як довго з’єднання має "
"чекати, поки блокування зникне, доки не буде створено виняток. За "
"замовчуванням параметр часу очікування становить 5,0 (п’ять секунд)."

#: ../../library/sqlite3.rst:226
msgid ""
"For the *isolation_level* parameter, please see the :attr:`~Connection."
"isolation_level` property of :class:`Connection` objects."
msgstr ""
"Для параметра *isolation_level* див. властивість :attr:`~Connection."
"isolation_level` об’єктів :class:`Connection`."

#: ../../library/sqlite3.rst:229
msgid ""
"SQLite natively supports only the types TEXT, INTEGER, REAL, BLOB and NULL. "
"If you want to use other types you must add support for them yourself. The "
"*detect_types* parameter and the using custom **converters** registered with "
"the module-level :func:`register_converter` function allow you to easily do "
"that."
msgstr ""

#: ../../library/sqlite3.rst:234
msgid ""
"*detect_types* defaults to 0 (i. e. off, no type detection), you can set it "
"to any combination of :const:`PARSE_DECLTYPES` and :const:`PARSE_COLNAMES` "
"to turn type detection on. Due to SQLite behaviour, types can't be detected "
"for generated fields (for example ``max(data)``), even when *detect_types* "
"parameter is set. In such case, the returned type is :class:`str`."
msgstr ""

#: ../../library/sqlite3.rst:240
msgid ""
"By default, *check_same_thread* is :const:`True` and only the creating "
"thread may use the connection. If set :const:`False`, the returned "
"connection may be shared across multiple threads. When using multiple "
"threads with the same connection writing operations should be serialized by "
"the user to avoid data corruption."
msgstr ""
"За замовчуванням *check_same_thread* має значення :const:`True`, і лише "
"потік, який створює, може використовувати з’єднання. Якщо встановлено :const:"
"`False`, повернуте з’єднання може використовуватися кількома потоками. У "
"разі використання кількох потоків з однаковим з’єднанням операції запису "
"повинні бути серіалізовані користувачем, щоб уникнути пошкодження даних."

#: ../../library/sqlite3.rst:245
msgid ""
"By default, the :mod:`sqlite3` module uses its :class:`Connection` class for "
"the connect call.  You can, however, subclass the :class:`Connection` class "
"and make :func:`connect` use your class instead by providing your class for "
"the *factory* parameter."
msgstr ""
"За замовчуванням модуль :mod:`sqlite3` використовує свій клас :class:"
"`Connection` для виклику підключення. Однак ви можете створити підклас "
"класу :class:`Connection` і змусити :func:`connect` використовувати ваш клас "
"замість цього, надавши ваш клас для параметра *factory*."

#: ../../library/sqlite3.rst:250
msgid "Consult the section :ref:`sqlite3-types` of this manual for details."
msgstr ""
"Зверніться до розділу :ref:`sqlite3-types` цього посібника, щоб дізнатися "
"більше."

#: ../../library/sqlite3.rst:252
msgid ""
"The :mod:`sqlite3` module internally uses a statement cache to avoid SQL "
"parsing overhead. If you want to explicitly set the number of statements "
"that are cached for the connection, you can set the *cached_statements* "
"parameter. The currently implemented default is to cache 100 statements."
msgstr ""

#: ../../library/sqlite3.rst:257
msgid ""
"If *uri* is :const:`True`, *database* is interpreted as a :abbr:`URI "
"(Uniform Resource Identifier)` with a file path and an optional query "
"string.  The scheme part *must* be ``\"file:\"``.  The path can be a "
"relative or absolute file path.  The query string allows us to pass "
"parameters to SQLite. Some useful URI tricks include::"
msgstr ""
"Якщо *uri* має значення :const:`True`, *база даних* інтерпретується як :abbr:"
"`URI (уніфікований ідентифікатор ресурсу)` із шляхом до файлу та "
"необов’язковим рядком запиту. Частина схеми *має* бути ``\"file:\"``. Шлях "
"може бути відносним або абсолютним шляхом до файлу. Рядок запиту дозволяє "
"нам передавати параметри в SQLite. Деякі корисні прийоми URI включають:"

#: ../../library/sqlite3.rst:276
msgid ""
"More information about this feature, including a list of recognized "
"parameters, can be found in the `SQLite URI documentation <https://www."
"sqlite.org/uri.html>`_."
msgstr ""
"Додаткову інформацію про цю функцію, включаючи список розпізнаних "
"параметрів, можна знайти в `документації SQLite URI <https://www.sqlite.org/"
"uri.html>`_."

#: ../../library/sqlite3.rst:280
msgid ""
"Raises an :ref:`auditing event <auditing>` ``sqlite3.connect`` with argument "
"``database``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``sqlite3.connect`` з аргументом "
"``база даних``."

#: ../../library/sqlite3.rst:282
msgid "Added the *uri* parameter."
msgstr "Додано параметр *uri*."

#: ../../library/sqlite3.rst:285
msgid ""
"*database* can now also be a :term:`path-like object`, not only a string."
msgstr ""
"*database* тепер також може бути :term:`path-like object`, а не лише рядком."

#: ../../library/sqlite3.rst:291
msgid ""
"Registers a callable to convert a bytestring from the database into a custom "
"Python type. The callable will be invoked for all database values that are "
"of the type *typename*. Confer the parameter *detect_types* of the :func:"
"`connect` function for how the type detection works. Note that *typename* "
"and the name of the type in your query are matched in case-insensitive "
"manner."
msgstr ""

#: ../../library/sqlite3.rst:300
msgid ""
"Registers a callable to convert the custom Python type *type* into one of "
"SQLite's supported types. The callable *callable* accepts as single "
"parameter the Python value, and must return a value of the following types: "
"int, float, str or bytes."
msgstr ""

#: ../../library/sqlite3.rst:308
msgid ""
"Returns :const:`True` if the string *sql* contains one or more complete SQL "
"statements terminated by semicolons. It does not verify that the SQL is "
"syntactically correct, only that there are no unclosed string literals and "
"the statement is terminated by a semicolon."
msgstr ""

#: ../../library/sqlite3.rst:313
msgid ""
"This can be used to build a shell for SQLite, as in the following example:"
msgstr ""
"Це можна використовувати для створення оболонки для SQLite, як у наступному "
"прикладі:"

#: ../../library/sqlite3.rst:321
msgid ""
"By default you will not get any tracebacks in user-defined functions, "
"aggregates, converters, authorizer callbacks etc. If you want to debug them, "
"you can call this function with *flag* set to ``True``. Afterwards, you will "
"get tracebacks from callbacks on ``sys.stderr``. Use :const:`False` to "
"disable the feature again."
msgstr ""

#: ../../library/sqlite3.rst:331
msgid "Connection Objects"
msgstr "Об'єкти підключення"

#: ../../library/sqlite3.rst:335
msgid "An SQLite database connection has the following attributes and methods:"
msgstr "Підключення до бази даних SQLite має такі атрибути та методи:"

#: ../../library/sqlite3.rst:339
msgid ""
"Get or set the current default isolation level. :const:`None` for autocommit "
"mode or one of \"DEFERRED\", \"IMMEDIATE\" or \"EXCLUSIVE\". See section :"
"ref:`sqlite3-controlling-transactions` for a more detailed explanation."
msgstr ""
"Отримати або встановити поточний рівень ізоляції за замовчуванням. :const:"
"`None` для режиму автозакріплення або одного з \"ВІДкладено\", \"НЕГАЙНО\" "
"чи \"ВИКЛЮЧНО\". Перегляньте розділ :ref:`sqlite3-controlling-transactions` "
"для більш детального пояснення."

#: ../../library/sqlite3.rst:345
msgid ""
":const:`True` if a transaction is active (there are uncommitted changes), :"
"const:`False` otherwise.  Read-only attribute."
msgstr ""
":const:`True`, якщо транзакція активна (є незафіксовані зміни), :const:"
"`False` інакше. Атрибут лише для читання."

#: ../../library/sqlite3.rst:352
msgid ""
"The cursor method accepts a single optional parameter *factory*. If "
"supplied, this must be a callable returning an instance of :class:`Cursor` "
"or its subclasses."
msgstr ""
"Метод cursor приймає один необов’язковий параметр *factory*. Якщо вказано, "
"це має бути виклик, що повертає екземпляр :class:`Cursor` або його підкласів."

#: ../../library/sqlite3.rst:358
msgid ""
"This method commits the current transaction. If you don't call this method, "
"anything you did since the last call to ``commit()`` is not visible from "
"other database connections. If you wonder why you don't see the data you've "
"written to the database, please check you didn't forget to call this method."
msgstr ""

#: ../../library/sqlite3.rst:365
msgid ""
"This method rolls back any changes to the database since the last call to :"
"meth:`commit`."
msgstr ""

#: ../../library/sqlite3.rst:370
msgid ""
"This closes the database connection. Note that this does not automatically "
"call :meth:`commit`. If you just close your database connection without "
"calling :meth:`commit` first, your changes will be lost!"
msgstr ""

#: ../../library/sqlite3.rst:376
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.execute` on it "
"with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""
"Створіть новий об’єкт :class:`Cursor` і викличте :meth:`~Cursor.execute` для "
"нього з заданими *sql* і *параметрами*. Повернути новий об’єкт курсору."

#: ../../library/sqlite3.rst:382
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executemany` on "
"it with the given *sql* and *parameters*. Return the new cursor object."
msgstr ""
"Створіть новий об’єкт :class:`Cursor` і викличте :meth:`~Cursor.executemany` "
"для нього з заданими *sql* і *параметрами*. Повернути новий об’єкт курсору."

#: ../../library/sqlite3.rst:388
msgid ""
"Create a new :class:`Cursor` object and call :meth:`~Cursor.executescript` "
"on it with the given *sql_script*. Return the new cursor object."
msgstr ""
"Створіть новий об’єкт :class:`Cursor` і викличте :meth:`~Cursor."
"executescript` для нього за допомогою заданого *sql_script*. Повернути новий "
"об’єкт курсору."

#: ../../library/sqlite3.rst:394
msgid ""
"Creates a user-defined function that you can later use from within SQL "
"statements under the function name *name*. *num_params* is the number of "
"parameters the function accepts (if *num_params* is -1, the function may "
"take any number of arguments), and *func* is a Python callable that is "
"called as the SQL function. If *deterministic* is true, the created function "
"is marked as `deterministic <https://sqlite.org/deterministic.html>`_, which "
"allows SQLite to perform additional optimizations. This flag is supported by "
"SQLite 3.8.3 or higher, :exc:`NotSupportedError` will be raised if used with "
"older versions."
msgstr ""

#: ../../library/sqlite3.rst:404
msgid ""
"The function can return any of the types supported by SQLite: bytes, str, "
"int, float and ``None``."
msgstr ""
"Функція може повертати будь-які типи, які підтримує SQLite: bytes, str, int, "
"float і ``None``."

#: ../../library/sqlite3.rst:407
msgid "The *deterministic* parameter was added."
msgstr "Додано параметр *детермінований*."

#: ../../library/sqlite3.rst:410 ../../library/sqlite3.rst:427
#: ../../library/sqlite3.rst:549 ../../library/sqlite3.rst:702
msgid "Example:"
msgstr "приклад:"

#: ../../library/sqlite3.rst:417
msgid "Creates a user-defined aggregate function."
msgstr "Створює визначену користувачем агрегатну функцію."

#: ../../library/sqlite3.rst:419
msgid ""
"The aggregate class must implement a ``step`` method, which accepts the "
"number of parameters *num_params* (if *num_params* is -1, the function may "
"take any number of arguments), and a ``finalize`` method which will return "
"the final result of the aggregate."
msgstr ""

#: ../../library/sqlite3.rst:424
msgid ""
"The ``finalize`` method can return any of the types supported by SQLite: "
"bytes, str, int, float and ``None``."
msgstr ""
"Метод ``finalize`` може повертати будь-які типи, які підтримує SQLite: "
"bytes, str, int, float і ``None``."

#: ../../library/sqlite3.rst:434
msgid ""
"Creates a collation with the specified *name* and *callable*. The callable "
"will be passed two string arguments. It should return -1 if the first is "
"ordered lower than the second, 0 if they are ordered equal and 1 if the "
"first is ordered higher than the second.  Note that this controls sorting "
"(ORDER BY in SQL) so your comparisons don't affect other SQL operations."
msgstr ""

#: ../../library/sqlite3.rst:440
msgid ""
"Note that the callable will get its parameters as Python bytestrings, which "
"will normally be encoded in UTF-8."
msgstr ""

#: ../../library/sqlite3.rst:443
msgid ""
"The following example shows a custom collation that sorts \"the wrong way\":"
msgstr ""

#: ../../library/sqlite3.rst:447
msgid ""
"To remove a collation, call ``create_collation`` with ``None`` as callable::"
msgstr ""

#: ../../library/sqlite3.rst:454
msgid ""
"You can call this method from a different thread to abort any queries that "
"might be executing on the connection. The query will then abort and the "
"caller will get an exception."
msgstr ""
"Ви можете викликати цей метод з іншого потоку, щоб скасувати будь-які "
"запити, які можуть виконуватися на з’єднанні. Після цього запит буде "
"перервано, а абонент отримає виняток."

#: ../../library/sqlite3.rst:461
msgid ""
"This routine registers a callback. The callback is invoked for each attempt "
"to access a column of a table in the database. The callback should return :"
"const:`SQLITE_OK` if access is allowed, :const:`SQLITE_DENY` if the entire "
"SQL statement should be aborted with an error and :const:`SQLITE_IGNORE` if "
"the column should be treated as a NULL value. These constants are available "
"in the :mod:`sqlite3` module."
msgstr ""
"Ця процедура реєструє зворотний виклик. Зворотний виклик викликається для "
"кожної спроби отримати доступ до стовпця таблиці в базі даних. Зворотний "
"виклик має повернути :const:`SQLITE_OK`, якщо доступ дозволено, :const:"
"`SQLITE_DENY`, якщо весь оператор SQL має бути перервано з помилкою, і :"
"const:`SQLITE_IGNORE`, якщо стовпець має розглядатися як значення NULL. Ці "
"константи доступні в модулі :mod:`sqlite3`."

#: ../../library/sqlite3.rst:468
msgid ""
"The first argument to the callback signifies what kind of operation is to be "
"authorized. The second and third argument will be arguments or :const:`None` "
"depending on the first argument. The 4th argument is the name of the "
"database (\"main\", \"temp\", etc.) if applicable. The 5th argument is the "
"name of the inner-most trigger or view that is responsible for the access "
"attempt or :const:`None` if this access attempt is directly from input SQL "
"code."
msgstr ""
"Перший аргумент зворотного виклику вказує, яку операцію потрібно "
"авторизувати. Другий і третій аргументи будуть аргументами або :const:`None` "
"залежно від першого аргументу. Четвертий аргумент — це ім’я бази даних "
"(\"main\", \"temp\" тощо), якщо це можливо. 5-й аргумент — це ім’я самого "
"внутрішнього тригера або перегляду, який відповідає за спробу доступу, або :"
"const:`None`, якщо ця спроба доступу здійснюється безпосередньо з вхідного "
"коду SQL."

#: ../../library/sqlite3.rst:475
msgid ""
"Please consult the SQLite documentation about the possible values for the "
"first argument and the meaning of the second and third argument depending on "
"the first one. All necessary constants are available in the :mod:`sqlite3` "
"module."
msgstr ""
"Зверніться до документації SQLite щодо можливих значень для першого "
"аргументу та значення другого та третього аргументів залежно від першого. "
"Усі необхідні константи доступні в модулі :mod:`sqlite3`."

#: ../../library/sqlite3.rst:482
msgid ""
"This routine registers a callback. The callback is invoked for every *n* "
"instructions of the SQLite virtual machine. This is useful if you want to "
"get called from SQLite during long-running operations, for example to update "
"a GUI."
msgstr ""
"Ця процедура реєструє зворотний виклик. Зворотний виклик викликається для "
"кожних *n* інструкцій віртуальної машини SQLite. Це корисно, якщо ви хочете "
"отримати виклик із SQLite під час тривалих операцій, наприклад, щоб оновити "
"графічний інтерфейс."

#: ../../library/sqlite3.rst:487
msgid ""
"If you want to clear any previously installed progress handler, call the "
"method with :const:`None` for *handler*."
msgstr ""

#: ../../library/sqlite3.rst:490
msgid ""
"Returning a non-zero value from the handler function will terminate the "
"currently executing query and cause it to raise an :exc:`OperationalError` "
"exception."
msgstr ""
"Повернення ненульового значення з функції обробника призведе до завершення "
"запиту, що виконується, і викликання виключення :exc:`OperationalError`."

#: ../../library/sqlite3.rst:497
msgid ""
"Registers *trace_callback* to be called for each SQL statement that is "
"actually executed by the SQLite backend."
msgstr ""
"Реєструє *trace_callback* для кожного оператора SQL, який фактично "
"виконується серверною частиною SQLite."

#: ../../library/sqlite3.rst:500
msgid ""
"The only argument passed to the callback is the statement (as :class:`str`) "
"that is being executed. The return value of the callback is ignored. Note "
"that the backend does not only run statements passed to the :meth:`Cursor."
"execute` methods.  Other sources include the :ref:`transaction management "
"<sqlite3-controlling-transactions>` of the sqlite3 module and the execution "
"of triggers defined in the current database."
msgstr ""
"Єдиним аргументом, який передається зворотному виклику, є оператор (як :"
"class:`str`), який виконується. Повернене значення зворотного виклику "
"ігнорується. Зауважте, що бекенд виконує не лише оператори, передані "
"методам :meth:`Cursor.execute`. Інші джерела включають :ref:`керування "
"транзакціями <sqlite3-controlling-transactions>` модуля sqlite3 і виконання "
"тригерів, визначених у поточній базі даних."

#: ../../library/sqlite3.rst:508
msgid ""
"Passing :const:`None` as *trace_callback* will disable the trace callback."
msgstr ""
"Передача :const:`None` як *trace_callback* вимкне зворотний виклик "
"трасування."

#: ../../library/sqlite3.rst:511
msgid ""
"Exceptions raised in the trace callback are not propagated. As a development "
"and debugging aid, use :meth:`~sqlite3.enable_callback_tracebacks` to enable "
"printing tracebacks from exceptions raised in the trace callback."
msgstr ""
"Винятки, викликані зворотним викликом трасування, не поширюються. Як "
"допомога при розробці та налагодженні використовуйте :meth:`~sqlite3."
"enable_callback_tracebacks`, щоб увімкнути друк трасування з винятків, "
"викликаних у зворотному виклику трасування."

#: ../../library/sqlite3.rst:521
msgid ""
"This routine allows/disallows the SQLite engine to load SQLite extensions "
"from shared libraries.  SQLite extensions can define new functions, "
"aggregates or whole new virtual table implementations.  One well-known "
"extension is the fulltext-search extension distributed with SQLite."
msgstr ""
"Ця процедура дозволяє/забороняє механізму SQLite завантажувати розширення "
"SQLite зі спільних бібліотек. Розширення SQLite можуть визначати нові "
"функції, агрегати або зовсім нові реалізації віртуальних таблиць. Одним із "
"відомих розширень є розширення повнотекстового пошуку, що поширюється разом "
"із SQLite."

#: ../../library/sqlite3.rst:526 ../../library/sqlite3.rst:538
msgid "Loadable extensions are disabled by default. See [#f1]_."
msgstr "Завантажувані розширення вимкнено за умовчанням. Див. [#f1]_."

#: ../../library/sqlite3.rst:534
msgid ""
"This routine loads an SQLite extension from a shared library.  You have to "
"enable extension loading with :meth:`enable_load_extension` before you can "
"use this routine."
msgstr ""
"Ця процедура завантажує розширення SQLite із спільної бібліотеки. Ви повинні "
"ввімкнути завантаження розширення за допомогою :meth:"
"`enable_load_extension`, перш ніж ви зможете використовувати цю процедуру."

#: ../../library/sqlite3.rst:544
msgid ""
"You can change this attribute to a callable that accepts the cursor and the "
"original row as a tuple and will return the real result row.  This way, you "
"can implement more advanced ways of returning results, such  as returning an "
"object that can also access columns by name."
msgstr ""
"Ви можете змінити цей атрибут на виклик, який приймає курсор і оригінальний "
"рядок як кортеж і повертатиме справжній рядок результату. Таким чином ви "
"можете реалізувати більш просунуті способи повернення результатів, наприклад "
"повернення об’єкта, який також може отримати доступ до стовпців за назвою."

#: ../../library/sqlite3.rst:553
msgid ""
"If returning a tuple doesn't suffice and you want name-based access to "
"columns, you should consider setting :attr:`row_factory` to the highly-"
"optimized :class:`sqlite3.Row` type. :class:`Row` provides both index-based "
"and case-insensitive name-based access to columns with almost no memory "
"overhead. It will probably be better than your own custom dictionary-based "
"approach or even a db_row based solution."
msgstr ""
"Якщо повернення кортежу недостатньо, і ви бажаєте отримати доступ до "
"стовпців на основі імен, вам слід розглянути можливість налаштування :attr:"
"`row_factory` високооптимізованого типу :class:`sqlite3.Row`. :class:`Row` "
"забезпечує доступ до стовпців як на основі індексу, так і на основі імен без "
"урахування регістру майже без витрат пам’яті. Ймовірно, це буде краще, ніж "
"ваш власний підхід на основі словника або навіть рішення на основі db_row."

#: ../../library/sqlite3.rst:565
msgid ""
"Using this attribute you can control what objects are returned for the "
"``TEXT`` data type. By default, this attribute is set to :class:`str` and "
"the :mod:`sqlite3` module will return :class:`str` objects for ``TEXT``. If "
"you want to return :class:`bytes` instead, you can set it to :class:`bytes`."
msgstr ""
"Використовуючи цей атрибут, ви можете контролювати, які об’єкти повертаються "
"для типу даних ``ТЕКСТ``. За замовчуванням цей атрибут має значення :class:"
"`str`, а модуль :mod:`sqlite3` повертатиме об’єкти :class:`str` для "
"``TEXT``. Якщо замість цього ви хочете повернути :class:`bytes`, ви можете "
"встановити значення :class:`bytes`."

#: ../../library/sqlite3.rst:570
msgid ""
"You can also set it to any other callable that accepts a single bytestring "
"parameter and returns the resulting object."
msgstr ""
"Ви також можете встановити для нього будь-який інший виклик, який приймає "
"один параметр bytestring і повертає результуючий об’єкт."

#: ../../library/sqlite3.rst:573
msgid "See the following example code for illustration:"
msgstr "Перегляньте наведений нижче приклад коду для ілюстрації:"

#: ../../library/sqlite3.rst:580
msgid ""
"Returns the total number of database rows that have been modified, inserted, "
"or deleted since the database connection was opened."
msgstr ""
"Повертає загальну кількість рядків бази даних, які було змінено, вставлено "
"або видалено з моменту відкриття підключення до бази даних."

#: ../../library/sqlite3.rst:586
msgid ""
"Returns an iterator to dump the database in an SQL text format.  Useful when "
"saving an in-memory database for later restoration.  This function provides "
"the same capabilities as the :kbd:`.dump` command in the :program:`sqlite3` "
"shell."
msgstr ""
"Повертає ітератор для створення дампу бази даних у текстовому форматі SQL. "
"Корисно під час збереження бази даних у пам’яті для подальшого відновлення. "
"Ця функція надає ті самі можливості, що й команда :kbd:`.dump` в оболонці :"
"program:`sqlite3`."

#: ../../library/sqlite3.rst:591
msgid "Example::"
msgstr "Приклад::"

#: ../../library/sqlite3.rst:605
msgid ""
"This method makes a backup of an SQLite database even while it's being "
"accessed by other clients, or concurrently by the same connection.  The copy "
"will be written into the mandatory argument *target*, that must be another :"
"class:`Connection` instance."
msgstr ""
"Цей метод створює резервну копію бази даних SQLite, навіть коли до неї "
"звертаються інші клієнти або одночасно через те саме з’єднання. Копія буде "
"записана в обов’язковий аргумент *target*, який має бути іншим екземпляром :"
"class:`Connection`."

#: ../../library/sqlite3.rst:610
msgid ""
"By default, or when *pages* is either ``0`` or a negative integer, the "
"entire database is copied in a single step; otherwise the method performs a "
"loop copying up to *pages* pages at a time."
msgstr ""
"За замовчуванням або коли *pages* має значення ``0`` або ціле від’ємне "
"число, вся база даних копіюється за один крок; інакше метод виконує цикл, "
"копіюючи до *pages* сторінок за раз."

#: ../../library/sqlite3.rst:614
msgid ""
"If *progress* is specified, it must either be ``None`` or a callable object "
"that will be executed at each iteration with three integer arguments, "
"respectively the *status* of the last iteration, the *remaining* number of "
"pages still to be copied and the *total* number of pages."
msgstr ""
"Якщо вказано *прогрес*, він має бути ``None`` або об’єктом, що викликається, "
"який виконуватиметься на кожній ітерації з трьома цілими аргументами, "
"відповідно *статусом* останньої ітерації, *кількістю сторінок, що "
"залишилася* для копіювання та *загальна* кількість сторінок."

#: ../../library/sqlite3.rst:619
msgid ""
"The *name* argument specifies the database name that will be copied: it must "
"be a string containing either ``\"main\"``, the default, to indicate the "
"main database, ``\"temp\"`` to indicate the temporary database or the name "
"specified after the ``AS`` keyword in an ``ATTACH DATABASE`` statement for "
"an attached database."
msgstr ""
"Аргумент *name* визначає назву бази даних, яку буде скопійовано: це має бути "
"рядок, що містить або ``\"main\"``, за замовчуванням, для позначення "
"основної бази даних, ``\"temp\"`` для позначення тимчасової бази даних або "
"ім’я, указане після ключового слова ``AS`` в операторі ``ATTACH DATABASE`` "
"для приєднаної бази даних."

#: ../../library/sqlite3.rst:625
msgid ""
"The *sleep* argument specifies the number of seconds to sleep by between "
"successive attempts to backup remaining pages, can be specified either as an "
"integer or a floating point value."
msgstr ""
"Аргумент *sleep* визначає кількість секунд для сну між послідовними спробами "
"резервного копіювання сторінок, що залишилися, і може бути вказаний у "
"вигляді цілого числа або значення з плаваючою комою."

#: ../../library/sqlite3.rst:629
msgid "Example 1, copy an existing database into another::"
msgstr "Приклад 1, копіювання існуючої бази даних в іншу::"

#: ../../library/sqlite3.rst:643
msgid "Example 2, copy an existing database into a transient copy::"
msgstr "Приклад 2, копіювання існуючої бази даних у тимчасову копію::"

#: ../../library/sqlite3.rst:651
msgid "Availability: SQLite 3.6.11 or higher"
msgstr ""

#: ../../library/sqlite3.rst:659
msgid "Cursor Objects"
msgstr "Об'єкти курсора"

#: ../../library/sqlite3.rst:663
msgid "A :class:`Cursor` instance has the following attributes and methods."
msgstr "Екземпляр :class:`Cursor` має такі атрибути та методи."

#: ../../library/sqlite3.rst:670
msgid ""
"Executes an SQL statement. Values may be bound to the statement using :ref:"
"`placeholders <sqlite3-placeholders>`."
msgstr ""
"Виконує оператор SQL. Значення можуть бути прив’язані до оператора за "
"допомогою :ref:`placeholders <sqlite3-placeholders>`."

#: ../../library/sqlite3.rst:673
msgid ""
":meth:`execute` will only execute a single SQL statement. If you try to "
"execute more than one statement with it, it will raise a :exc:`.Warning`. "
"Use :meth:`executescript` if you want to execute multiple SQL statements "
"with one call."
msgstr ""

#: ../../library/sqlite3.rst:681
msgid ""
"Executes a :ref:`parameterized <sqlite3-placeholders>` SQL command against "
"all parameter sequences or mappings found in the sequence "
"*seq_of_parameters*. The :mod:`sqlite3` module also allows using an :term:"
"`iterator` yielding parameters instead of a sequence."
msgstr ""
"Виконує :ref:`параметризовану <sqlite3-placeholders>` команду SQL проти всіх "
"послідовностей параметрів або зіставлень, знайдених у послідовності "
"*seq_of_parameters*. Модуль :mod:`sqlite3` також дозволяє використовувати :"
"term:`iterator` вихідні параметри замість послідовності."

#: ../../library/sqlite3.rst:688
msgid "Here's a shorter example using a :term:`generator`:"
msgstr "Ось коротший приклад використання :term:`generator`:"

#: ../../library/sqlite3.rst:695
msgid ""
"This is a nonstandard convenience method for executing multiple SQL "
"statements at once. It issues a ``COMMIT`` statement first, then executes "
"the SQL script it gets as a parameter.  This method disregards :attr:"
"`isolation_level`; any transaction control must be added to *sql_script*."
msgstr ""
"Це нестандартний зручний метод для одночасного виконання кількох операторів "
"SQL. Спочатку він видає оператор ``COMMIT``, а потім виконує сценарій SQL, "
"який отримує як параметр. Цей метод ігнорує :attr:`isolation_level`; будь-"
"який контроль транзакцій має бути доданий до *sql_script*."

#: ../../library/sqlite3.rst:700
msgid "*sql_script* can be an instance of :class:`str`."
msgstr "*sql_script* може бути екземпляром :class:`str`."

#: ../../library/sqlite3.rst:709
msgid ""
"Fetches the next row of a query result set, returning a single sequence, or :"
"const:`None` when no more data is available."
msgstr ""
"Отримує наступний рядок із набору результатів запиту, повертаючи одну "
"послідовність або :const:`None`, якщо більше немає даних."

#: ../../library/sqlite3.rst:715
msgid ""
"Fetches the next set of rows of a query result, returning a list.  An empty "
"list is returned when no more rows are available."
msgstr ""
"Отримує наступний набір рядків результату запиту, повертаючи список. "
"Порожній список повертається, якщо більше немає рядків."

#: ../../library/sqlite3.rst:718
msgid ""
"The number of rows to fetch per call is specified by the *size* parameter. "
"If it is not given, the cursor's arraysize determines the number of rows to "
"be fetched. The method should try to fetch as many rows as indicated by the "
"size parameter. If this is not possible due to the specified number of rows "
"not being available, fewer rows may be returned."
msgstr ""
"Кількість рядків, які потрібно отримати за виклик, визначається параметром "
"*size*. Якщо його не вказано, розмір масиву курсору визначає кількість "
"рядків, які потрібно отримати. Метод повинен спробувати отримати стільки "
"рядків, скільки вказано параметром size. Якщо це неможливо через відсутність "
"зазначеної кількості рядків, може бути повернуто менше рядків."

#: ../../library/sqlite3.rst:724
msgid ""
"Note there are performance considerations involved with the *size* "
"parameter. For optimal performance, it is usually best to use the arraysize "
"attribute. If the *size* parameter is used, then it is best for it to retain "
"the same value from one :meth:`fetchmany` call to the next."
msgstr ""
"Зауважте, що з параметром *size* пов’язані міркування щодо продуктивності. "
"Для оптимальної продуктивності зазвичай найкраще використовувати атрибут "
"arraysize. Якщо використовується параметр *size*, то найкраще, щоб він "
"зберігав те саме значення від одного виклику :meth:`fetchmany` до наступного."

#: ../../library/sqlite3.rst:731
msgid ""
"Fetches all (remaining) rows of a query result, returning a list.  Note that "
"the cursor's arraysize attribute can affect the performance of this "
"operation. An empty list is returned when no rows are available."
msgstr ""
"Отримує всі (решту) рядки результату запиту, повертаючи список. Зауважте, що "
"атрибут arraysize курсора може вплинути на продуктивність цієї операції. "
"Якщо немає доступних рядків, повертається порожній список."

#: ../../library/sqlite3.rst:737
msgid "Close the cursor now (rather than whenever ``__del__`` is called)."
msgstr "Закрийте курсор зараз (а не під час кожного виклику ``__del__``)."

#: ../../library/sqlite3.rst:739
msgid ""
"The cursor will be unusable from this point forward; a :exc:"
"`ProgrammingError` exception will be raised if any operation is attempted "
"with the cursor."
msgstr ""
"Курсор стане непридатним для використання з цього моменту; виняток :exc:"
"`ProgrammingError` буде викликано, якщо будь-яка операція буде виконана з "
"курсором."

#: ../../library/sqlite3.rst:744 ../../library/sqlite3.rst:748
msgid "Required by the DB-API. Does nothing in :mod:`sqlite3`."
msgstr "Потрібний для DB-API. Нічого не робить у :mod:`sqlite3`."

#: ../../library/sqlite3.rst:752
msgid ""
"Although the :class:`Cursor` class of the :mod:`sqlite3` module implements "
"this attribute, the database engine's own support for the determination of "
"\"rows affected\"/\"rows selected\" is quirky."
msgstr ""
"Незважаючи на те, що клас :class:`Cursor` модуля :mod:`sqlite3` реалізує цей "
"атрибут, власна підтримка механізмом бази даних для визначення \"рядків, які "
"постраждали\"/\"рядків, які вибрано\", є дивною."

#: ../../library/sqlite3.rst:756
msgid ""
"For :meth:`executemany` statements, the number of modifications are summed "
"up into :attr:`rowcount`."
msgstr ""
"Для операторів :meth:`executemany` кількість модифікацій підсумовується в :"
"attr:`rowcount`."

#: ../../library/sqlite3.rst:759
msgid ""
"As required by the Python DB API Spec, the :attr:`rowcount` attribute \"is "
"-1 in case no ``executeXX()`` has been performed on the cursor or the "
"rowcount of the last operation is not determinable by the interface\". This "
"includes ``SELECT`` statements because we cannot determine the number of "
"rows a query produced until all rows were fetched."
msgstr ""
"Згідно зі специфікацією Python DB API, атрибут :attr:`rowcount` дорівнює -1, "
"якщо над курсором не було виконано ``executeXX()`` або кількість рядків "
"останньої операції не визначається інтерфейсом \". Це включає оператори "
"``SELECT``, оскільки ми не можемо визначити кількість рядків, створених "
"запитом, доки не буде вилучено всі рядки."

#: ../../library/sqlite3.rst:765
msgid ""
"With SQLite versions before 3.6.5, :attr:`rowcount` is set to 0 if you make "
"a ``DELETE FROM table`` without any condition."
msgstr ""

#: ../../library/sqlite3.rst:770
msgid ""
"This read-only attribute provides the row id of the last inserted row. It is "
"only updated after successful ``INSERT`` or ``REPLACE`` statements using "
"the :meth:`execute` method.  For other statements, after :meth:`executemany` "
"or :meth:`executescript`, or if the insertion failed, the value of "
"``lastrowid`` is left unchanged.  The initial value of ``lastrowid`` is :"
"const:`None`."
msgstr ""
"Цей атрибут лише для читання надає ідентифікатор останнього вставленого "
"рядка. Він оновлюється лише після успішних операторів ``INSERT`` або "
"``REPLACE`` за допомогою методу :meth:`execute`. Для інших операторів після :"
"meth:`executemany` або :meth:`executescript`, або якщо вставка не вдалася, "
"значення ``lastrowid`` залишається незмінним. Початкове значення "
"``lastrowid``: :const:`None`."

#: ../../library/sqlite3.rst:778
msgid "Inserts into ``WITHOUT ROWID`` tables are not recorded."
msgstr "Вставки в таблиці ``БЕЗ ROWID`` не записуються."

#: ../../library/sqlite3.rst:780
msgid "Added support for the ``REPLACE`` statement."
msgstr "Додано підтримку оператора REPLACE."

#: ../../library/sqlite3.rst:785
msgid ""
"Read/write attribute that controls the number of rows returned by :meth:"
"`fetchmany`. The default value is 1 which means a single row would be "
"fetched per call."
msgstr ""
"Атрибут читання/запису, який контролює кількість рядків, які повертає :meth:"
"`fetchmany`. Значення за замовчуванням дорівнює 1, що означає, що за виклик "
"буде отримано один рядок."

#: ../../library/sqlite3.rst:790
msgid ""
"This read-only attribute provides the column names of the last query. To "
"remain compatible with the Python DB API, it returns a 7-tuple for each "
"column where the last six items of each tuple are :const:`None`."
msgstr ""
"Цей атрибут лише для читання надає назви стовпців останнього запиту. Щоб "
"залишатися сумісним з API Python DB, він повертає 7-кортеж для кожного "
"стовпця, де останні шість елементів кожного кортежу є :const:`None`."

#: ../../library/sqlite3.rst:794
msgid "It is set for ``SELECT`` statements without any matching rows as well."
msgstr ""
"Він також встановлений для операторів ``SELECT`` без будь-яких відповідних "
"рядків."

#: ../../library/sqlite3.rst:798
msgid ""
"This read-only attribute provides the SQLite database :class:`Connection` "
"used by the :class:`Cursor` object.  A :class:`Cursor` object created by "
"calling :meth:`con.cursor() <Connection.cursor>` will have a :attr:"
"`connection` attribute that refers to *con*::"
msgstr ""
"Цей атрибут лише для читання надає базу даних SQLite :class:`Connection`, "
"яку використовує об’єкт :class:`Cursor`. Об’єкт :class:`Cursor`, створений "
"викликом :meth:`con.cursor() <Connection.cursor>`, матиме атрибут :attr:"
"`connection`, який посилається на *con*::"

#: ../../library/sqlite3.rst:811
msgid "Row Objects"
msgstr "Об'єкти рядка"

#: ../../library/sqlite3.rst:815
msgid ""
"A :class:`Row` instance serves as a highly optimized :attr:`~Connection."
"row_factory` for :class:`Connection` objects. It tries to mimic a tuple in "
"most of its features."
msgstr ""
"Екземпляр :class:`Row` служить високооптимізованою :attr:`~Connection."
"row_factory` для об’єктів :class:`Connection`. Він намагається імітувати "
"кортеж у більшості своїх функцій."

#: ../../library/sqlite3.rst:819
msgid ""
"It supports mapping access by column name and index, iteration, "
"representation, equality testing and :func:`len`."
msgstr ""
"Він підтримує відображення доступу за назвою та індексом стовпця, ітерацією, "
"представленням, перевіркою рівності та :func:`len`."

#: ../../library/sqlite3.rst:822
msgid ""
"If two :class:`Row` objects have exactly the same columns and their members "
"are equal, they compare equal."
msgstr ""
"Якщо два об’єкти :class:`Row` мають однакові стовпці, а їхні члени рівні, "
"вони порівнюються."

#: ../../library/sqlite3.rst:827
msgid ""
"This method returns a list of column names. Immediately after a query, it is "
"the first member of each tuple in :attr:`Cursor.description`."
msgstr ""
"Цей метод повертає список імен стовпців. Одразу після запиту він є першим "
"членом кожного кортежу в :attr:`Cursor.description`."

#: ../../library/sqlite3.rst:830
msgid "Added support of slicing."
msgstr "Додана підтримка нарізки."

#: ../../library/sqlite3.rst:833
msgid "Let's assume we initialize a table as in the example given above::"
msgstr ""
"Припустімо, що ми ініціалізуємо таблицю, як у наведеному вище прикладі:"

#: ../../library/sqlite3.rst:845
msgid "Now we plug :class:`Row` in::"
msgstr "Тепер ми підключаємо :class:`Row` до::"

#: ../../library/sqlite3.rst:877
msgid "Exceptions"
msgstr "Винятки"

#: ../../library/sqlite3.rst:881
msgid "A subclass of :exc:`Exception`."
msgstr ""

#: ../../library/sqlite3.rst:885
msgid ""
"The base class of the other exceptions in this module.  It is a subclass of :"
"exc:`Exception`."
msgstr ""
"Базовий клас інших винятків у цьому модулі. Це підклас :exc:`Exception`."

#: ../../library/sqlite3.rst:890
msgid "Exception raised for errors that are related to the database."
msgstr ""

#: ../../library/sqlite3.rst:894
msgid ""
"Exception raised when the relational integrity of the database is affected, "
"e.g. a foreign key check fails.  It is a subclass of :exc:`DatabaseError`."
msgstr ""
"Виняток виникає, коли порушується реляційна цілісність бази даних, "
"наприклад. не вдається перевірити зовнішній ключ. Це підклас :exc:"
"`DatabaseError`."

#: ../../library/sqlite3.rst:899
msgid ""
"Exception raised for programming errors, e.g. table not found or already "
"exists, syntax error in the SQL statement, wrong number of parameters "
"specified, etc.  It is a subclass of :exc:`DatabaseError`."
msgstr ""

#: ../../library/sqlite3.rst:905
msgid ""
"Exception raised for errors that are related to the database's operation and "
"not necessarily under the control of the programmer, e.g. an unexpected "
"disconnect occurs, the data source name is not found, a transaction could "
"not be processed, etc.  It is a subclass of :exc:`DatabaseError`."
msgstr ""

#: ../../library/sqlite3.rst:912
msgid ""
"Exception raised in case a method or database API was used which is not "
"supported by the database, e.g. calling the :meth:`~Connection.rollback` "
"method on a connection that does not support transaction or has transactions "
"turned off.  It is a subclass of :exc:`DatabaseError`."
msgstr ""

#: ../../library/sqlite3.rst:921
msgid "SQLite and Python types"
msgstr "Типи SQLite і Python"

#: ../../library/sqlite3.rst:925
msgid "Introduction"
msgstr "вступ"

#: ../../library/sqlite3.rst:927
msgid ""
"SQLite natively supports the following types: ``NULL``, ``INTEGER``, "
"``REAL``, ``TEXT``, ``BLOB``."
msgstr ""
"SQLite спочатку підтримує такі типи: ``NULL``, ``INTEGER``, ``REAL``, "
"``TEXT``, ``BLOB``."

#: ../../library/sqlite3.rst:930
msgid ""
"The following Python types can thus be sent to SQLite without any problem:"
msgstr ""
"Таким чином, такі типи Python можна без будь-яких проблем надсилати до "
"SQLite:"

#: ../../library/sqlite3.rst:933 ../../library/sqlite3.rst:950
msgid "Python type"
msgstr "Тип Python"

#: ../../library/sqlite3.rst:933 ../../library/sqlite3.rst:950
msgid "SQLite type"
msgstr "Тип SQLite"

#: ../../library/sqlite3.rst:935 ../../library/sqlite3.rst:952
msgid ":const:`None`"
msgstr ":const:`None`"

#: ../../library/sqlite3.rst:935 ../../library/sqlite3.rst:952
msgid "``NULL``"
msgstr "``NULL``"

#: ../../library/sqlite3.rst:937 ../../library/sqlite3.rst:954
msgid ":class:`int`"
msgstr ":class:`int`"

#: ../../library/sqlite3.rst:937 ../../library/sqlite3.rst:954
msgid "``INTEGER``"
msgstr "``ЦІЛЕ ЧИСЛО``"

#: ../../library/sqlite3.rst:939 ../../library/sqlite3.rst:956
msgid ":class:`float`"
msgstr ":class:`float`"

#: ../../library/sqlite3.rst:939 ../../library/sqlite3.rst:956
msgid "``REAL``"
msgstr "``РЕАЛЬНИЙ``"

#: ../../library/sqlite3.rst:941
msgid ":class:`str`"
msgstr ":class:`str`"

#: ../../library/sqlite3.rst:941 ../../library/sqlite3.rst:958
msgid "``TEXT``"
msgstr "``ТЕКСТ``"

#: ../../library/sqlite3.rst:943 ../../library/sqlite3.rst:961
msgid ":class:`bytes`"
msgstr ":class:`bytes`"

#: ../../library/sqlite3.rst:943 ../../library/sqlite3.rst:961
msgid "``BLOB``"
msgstr "``BLOB``"

#: ../../library/sqlite3.rst:947
msgid "This is how SQLite types are converted to Python types by default:"
msgstr "Ось як типи SQLite перетворюються на типи Python за замовчуванням:"

#: ../../library/sqlite3.rst:958
msgid "depends on :attr:`~Connection.text_factory`, :class:`str` by default"
msgstr ""
"залежить від :attr:`~Connection.text_factory`, :class:`str` за замовчуванням"

#: ../../library/sqlite3.rst:964
msgid ""
"The type system of the :mod:`sqlite3` module is extensible in two ways: you "
"can store additional Python types in an SQLite database via object "
"adaptation, and you can let the :mod:`sqlite3` module convert SQLite types "
"to different Python types via converters."
msgstr ""
"Система типів модуля :mod:`sqlite3` розширюється двома способами: ви можете "
"зберігати додаткові типи Python у базі даних SQLite за допомогою адаптації "
"об’єктів, і ви можете дозволити модулю :mod:`sqlite3` перетворювати типи "
"SQLite на інший Python. типів через конвертери."

#: ../../library/sqlite3.rst:971
msgid "Using adapters to store additional Python types in SQLite databases"
msgstr ""

#: ../../library/sqlite3.rst:973
msgid ""
"As described before, SQLite supports only a limited set of types natively. "
"To use other Python types with SQLite, you must **adapt** them to one of the "
"sqlite3 module's supported types for SQLite: one of NoneType, int, float, "
"str, bytes."
msgstr ""

#: ../../library/sqlite3.rst:978
msgid ""
"There are two ways to enable the :mod:`sqlite3` module to adapt a custom "
"Python type to one of the supported ones."
msgstr ""

#: ../../library/sqlite3.rst:983
msgid "Letting your object adapt itself"
msgstr "Дозвольте своєму об’єкту адаптуватися"

#: ../../library/sqlite3.rst:985
msgid ""
"This is a good approach if you write the class yourself. Let's suppose you "
"have a class like this::"
msgstr ""

#: ../../library/sqlite3.rst:992
msgid ""
"Now you want to store the point in a single SQLite column.  First you'll "
"have to choose one of the supported types to be used for representing the "
"point. Let's just use str and separate the coordinates using a semicolon. "
"Then you need to give your class a method ``__conform__(self, protocol)`` "
"which must return the converted value. The parameter *protocol* will be :"
"class:`PrepareProtocol`."
msgstr ""

#: ../../library/sqlite3.rst:1002
msgid "Registering an adapter callable"
msgstr "Реєстрація адаптера, що викликається"

#: ../../library/sqlite3.rst:1004
msgid ""
"The other possibility is to create a function that converts the type to the "
"string representation and register the function with :meth:"
"`register_adapter`."
msgstr ""

#: ../../library/sqlite3.rst:1009
msgid ""
"The :mod:`sqlite3` module has two default adapters for Python's built-in :"
"class:`datetime.date` and :class:`datetime.datetime` types.  Now let's "
"suppose we want to store :class:`datetime.datetime` objects not in ISO "
"representation, but as a Unix timestamp."
msgstr ""

#: ../../library/sqlite3.rst:1018
msgid "Converting SQLite values to custom Python types"
msgstr "Перетворення значень SQLite на спеціальні типи Python"

#: ../../library/sqlite3.rst:1020
msgid ""
"Writing an adapter lets you send custom Python types to SQLite. But to make "
"it really useful we need to make the Python to SQLite to Python roundtrip "
"work."
msgstr ""

#: ../../library/sqlite3.rst:1023
msgid "Enter converters."
msgstr ""

#: ../../library/sqlite3.rst:1025
msgid ""
"Let's go back to the :class:`Point` class. We stored the x and y coordinates "
"separated via semicolons as strings in SQLite."
msgstr ""
"Повернемося до класу :class:`Point`. Ми зберігали координати x і y, "
"розділені крапкою з комою, як рядки в SQLite."

#: ../../library/sqlite3.rst:1028
msgid ""
"First, we'll define a converter function that accepts the string as a "
"parameter and constructs a :class:`Point` object from it."
msgstr ""
"Спочатку ми визначимо функцію конвертера, яка приймає рядок як параметр і "
"створює з нього об’єкт :class:`Point`."

#: ../../library/sqlite3.rst:1033
msgid ""
"Converter functions **always** get called with a :class:`bytes` object, no "
"matter under which data type you sent the value to SQLite."
msgstr ""

#: ../../library/sqlite3.rst:1042
msgid ""
"Now you need to make the :mod:`sqlite3` module know that what you select "
"from the database is actually a point. There are two ways of doing this:"
msgstr ""

#: ../../library/sqlite3.rst:1045
msgid "Implicitly via the declared type"
msgstr ""

#: ../../library/sqlite3.rst:1047
msgid "Explicitly via the column name"
msgstr ""

#: ../../library/sqlite3.rst:1049
msgid ""
"Both ways are described in section :ref:`sqlite3-module-contents`, in the "
"entries for the constants :const:`PARSE_DECLTYPES` and :const:"
"`PARSE_COLNAMES`."
msgstr ""

#: ../../library/sqlite3.rst:1052
msgid "The following example illustrates both approaches."
msgstr ""

#: ../../library/sqlite3.rst:1058
msgid "Default adapters and converters"
msgstr "Стандартні адаптери та конвертери"

#: ../../library/sqlite3.rst:1060
msgid ""
"There are default adapters for the date and datetime types in the datetime "
"module. They will be sent as ISO dates/ISO timestamps to SQLite."
msgstr ""
"У модулі datetime є стандартні адаптери для типів date і datetime. Вони "
"будуть надіслані як дати ISO/мітки часу ISO до SQLite."

#: ../../library/sqlite3.rst:1063
msgid ""
"The default converters are registered under the name \"date\" for :class:"
"`datetime.date` and under the name \"timestamp\" for :class:`datetime."
"datetime`."
msgstr ""
"Перетворювачі за замовчуванням зареєстровані під назвою \"date\" для :class:"
"`datetime.date` і під назвою \"timestamp\" для :class:`datetime.datetime`."

#: ../../library/sqlite3.rst:1067
msgid ""
"This way, you can use date/timestamps from Python without any additional "
"fiddling in most cases. The format of the adapters is also compatible with "
"the experimental SQLite date/time functions."
msgstr ""
"Таким чином, у більшості випадків ви можете використовувати мітки дати/часу "
"з Python без будь-яких додаткових маніпуляцій. Формат адаптерів також "
"сумісний з експериментальними функціями дати/часу SQLite."

#: ../../library/sqlite3.rst:1071
msgid "The following example demonstrates this."
msgstr "Наступний приклад демонструє це."

#: ../../library/sqlite3.rst:1075
msgid ""
"If a timestamp stored in SQLite has a fractional part longer than 6 numbers, "
"its value will be truncated to microsecond precision by the timestamp "
"converter."
msgstr ""
"Якщо мітка часу, що зберігається в SQLite, має дробову частину, яка "
"перевищує 6 чисел, її значення буде скорочено до мікросекундної точності "
"конвертером міток часу."

#: ../../library/sqlite3.rst:1081
msgid ""
"The default \"timestamp\" converter ignores UTC offsets in the database and "
"always returns a naive :class:`datetime.datetime` object. To preserve UTC "
"offsets in timestamps, either leave converters disabled, or register an "
"offset-aware converter with :func:`register_converter`."
msgstr ""
"Конвертер \"міток часу\" за замовчуванням ігнорує зміщення UTC у базі даних "
"і завжди повертає простий об’єкт :class:`datetime.datetime`. Щоб зберегти "
"зміщення UTC у мітках часу, залиште конвертери вимкненими або зареєструйте "
"конвертер із зсувом за допомогою :func:`register_converter`."

#: ../../library/sqlite3.rst:1089
msgid "Controlling Transactions"
msgstr "Контроль транзакцій"

#: ../../library/sqlite3.rst:1091
msgid ""
"The underlying ``sqlite3`` library operates in ``autocommit`` mode by "
"default, but the Python :mod:`sqlite3` module by default does not."
msgstr ""
"Базова бібліотека ``sqlite3`` працює в режимі ``autocommit`` за "
"замовчуванням, але модуль Python :mod:`sqlite3` за замовчуванням не працює."

#: ../../library/sqlite3.rst:1094
msgid ""
"``autocommit`` mode means that statements that modify the database take "
"effect immediately.  A ``BEGIN`` or ``SAVEPOINT`` statement disables "
"``autocommit`` mode, and a ``COMMIT``, a ``ROLLBACK``, or a ``RELEASE`` that "
"ends the outermost transaction, turns ``autocommit`` mode back on."
msgstr ""
"Режим ``autocommit`` означає, що оператори, які змінюють базу даних, "
"набувають чинності негайно. Оператор ``BEGIN`` або ``SAVEPOINT`` вимикає "
"режим ``autocommit``, а ``COMMIT``, ``ROLLBACK`` або ``RELEASE``, які "
"завершують крайню транзакцію, повертає режим ``автокомітату`` знову "
"ввімкнено."

#: ../../library/sqlite3.rst:1099
msgid ""
"The Python :mod:`sqlite3` module by default issues a ``BEGIN`` statement "
"implicitly before a Data Modification Language (DML) statement (i.e. "
"``INSERT``/``UPDATE``/``DELETE``/``REPLACE``)."
msgstr ""
"Модуль Python :mod:`sqlite3` за замовчуванням видає оператор ``BEGIN`` "
"неявно перед оператором мови модифікації даних (DML) (тобто ``INSERT``/"
"``UPDATE``/``DELETE``/``REPLACE``)."

#: ../../library/sqlite3.rst:1103
msgid ""
"You can control which kind of ``BEGIN`` statements :mod:`sqlite3` implicitly "
"executes via the *isolation_level* parameter to the :func:`connect` call, or "
"via the :attr:`isolation_level` property of connections. If you specify no "
"*isolation_level*, a plain ``BEGIN`` is used, which is equivalent to "
"specifying ``DEFERRED``.  Other possible values are ``IMMEDIATE`` and "
"``EXCLUSIVE``."
msgstr ""
"Ви можете керувати тим, який тип операторів ``BEGIN`` :mod:`sqlite3` неявно "
"виконується через параметр *isolation_level* виклику :func:`connect` або "
"через властивість :attr:`isolation_level` підключень. Якщо ви не вкажете "
"*рівень_ізоляції*, використовується звичайний ``BEGIN``, що еквівалентно "
"вказуванню ``DEFERRED``. Інші можливі значення: ``IMMEDIATE`` і "
"``EXCLUSIVE``."

#: ../../library/sqlite3.rst:1110
msgid ""
"You can disable the :mod:`sqlite3` module's implicit transaction management "
"by setting :attr:`isolation_level` to ``None``.  This will leave the "
"underlying ``sqlite3`` library operating in ``autocommit`` mode.  You can "
"then completely control the transaction state by explicitly issuing "
"``BEGIN``, ``ROLLBACK``, ``SAVEPOINT``, and ``RELEASE`` statements in your "
"code."
msgstr ""
"Ви можете вимкнути неявне керування транзакціями модуля :mod:`sqlite3`, "
"встановивши для :attr:`isolation_level` значення ``None``. Це залишить "
"базову бібліотеку ``sqlite3`` працювати в режимі ``autocommit``. Потім ви "
"можете повністю контролювати стан транзакції, явно видаючи оператори "
"``BEGIN``, ``ROLLBACK``, ``SAVEPOINT`` і ``RELEASE`` у вашому коді."

#: ../../library/sqlite3.rst:1116
msgid ""
"Note that :meth:`~Cursor.executescript` disregards :attr:`isolation_level`; "
"any transaction control must be added explicitly."
msgstr ""
"Зауважте, що :meth:`~Cursor.executescript` не враховує :attr:"
"`isolation_level`; будь-який контроль транзакцій має бути доданий явно."

#: ../../library/sqlite3.rst:1119
msgid ""
":mod:`sqlite3` used to implicitly commit an open transaction before DDL "
"statements.  This is no longer the case."
msgstr ""
":mod:`sqlite3` використовується для неявної фіксації відкритої транзакції "
"перед операторами DDL. Це вже не так."

#: ../../library/sqlite3.rst:1125
msgid "Using :mod:`sqlite3` efficiently"
msgstr "Ефективне використання :mod:`sqlite3`"

#: ../../library/sqlite3.rst:1129
msgid "Using shortcut methods"
msgstr "Використання методів швидкого доступу"

#: ../../library/sqlite3.rst:1131
msgid ""
"Using the nonstandard :meth:`execute`, :meth:`executemany` and :meth:"
"`executescript` methods of the :class:`Connection` object, your code can be "
"written more concisely because you don't have to create the (often "
"superfluous) :class:`Cursor` objects explicitly. Instead, the :class:"
"`Cursor` objects are created implicitly and these shortcut methods return "
"the cursor objects. This way, you can execute a ``SELECT`` statement and "
"iterate over it directly using only a single call on the :class:`Connection` "
"object."
msgstr ""
"Використовуючи нестандартні методи :meth:`execute`, :meth:`executemany` і :"
"meth:`executescript` об’єкта :class:`Connection`, ваш код можна написати "
"стисло, оскільки вам не потрібно створювати (часто зайве) :class:`Cursor` "
"об’єкти явно. Натомість об’єкти :class:`Cursor` створюються неявно, і ці "
"методи швидкого доступу повертають об’єкти курсору. Таким чином, ви можете "
"виконати оператор ``SELECT`` і перейти до нього безпосередньо, "
"використовуючи лише один виклик об’єкта :class:`Connection`."

#: ../../library/sqlite3.rst:1143
msgid "Accessing columns by name instead of by index"
msgstr "Доступ до стовпців за назвою, а не за індексом"

#: ../../library/sqlite3.rst:1145
msgid ""
"One useful feature of the :mod:`sqlite3` module is the built-in :class:"
"`sqlite3.Row` class designed to be used as a row factory."
msgstr ""
"Однією з корисних функцій модуля :mod:`sqlite3` є вбудований клас :class:"
"`sqlite3.Row`, призначений для використання як фабрики рядків."

#: ../../library/sqlite3.rst:1148
msgid ""
"Rows wrapped with this class can be accessed both by index (like tuples) and "
"case-insensitively by name:"
msgstr ""
"Доступ до рядків, обернутих цим класом, можна отримати як за індексом (як "
"кортежі), так і за назвою без урахування регістру:"

#: ../../library/sqlite3.rst:1155
msgid "Using the connection as a context manager"
msgstr "Використання підключення як контекстного менеджера"

#: ../../library/sqlite3.rst:1157
msgid ""
"Connection objects can be used as context managers that automatically commit "
"or rollback transactions.  In the event of an exception, the transaction is "
"rolled back; otherwise, the transaction is committed:"
msgstr ""

#: ../../library/sqlite3.rst:1166
msgid "Footnotes"
msgstr "Виноски"

#: ../../library/sqlite3.rst:1167
msgid ""
"The sqlite3 module is not built with loadable extension support by default, "
"because some platforms (notably macOS) have SQLite libraries which are "
"compiled without this feature. To get loadable extension support, you must "
"pass ``--enable-loadable-sqlite-extensions`` to configure."
msgstr ""
