# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2025, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# 256c6f581e7306f8fe260875df9dd39f_33ba001, 2021
# alex alev <alex.alev@bk.ru>, 2021
# Daniil Kolesnikov, 2024
# Илья Панфилов, 2024
# Rafael Fontenelle <rffontenelle@gmail.com>, 2024
# Roustam Khamidoulline, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-01-03 14:16+0000\n"
"PO-Revision-Date: 2021-06-28 01:08+0000\n"
"Last-Translator: Roustam Khamidoulline, 2024\n"
"Language-Team: Russian (https://app.transifex.com/python-doc/teams/5390/"
"ru/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ru\n"
"Plural-Forms: nplurals=4; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<12 || n%100>14) ? 1 : n%10==0 || (n%10>=5 && n%10<=9) || "
"(n%100>=11 && n%100<=14)? 2 : 3);\n"

#: ../../library/json.rst:2
msgid ":mod:`!json` --- JSON encoder and decoder"
msgstr ":mod:`!json` --- Кодер и декодер JSON"

#: ../../library/json.rst:10
msgid "**Source code:** :source:`Lib/json/__init__.py`"
msgstr "**Исходный код:** :source:`Lib/json/__init__.py`"

#: ../../library/json.rst:14
msgid ""
"`JSON (JavaScript Object Notation) <https://json.org>`_, specified by :rfc:"
"`7159` (which obsoletes :rfc:`4627`) and by `ECMA-404 <https://ecma-"
"international.org/publications-and-standards/standards/ecma-404/>`_, is a "
"lightweight data interchange format inspired by `JavaScript <https://en."
"wikipedia.org/wiki/JavaScript>`_ object literal syntax (although it is not a "
"strict subset of JavaScript [#rfc-errata]_ )."
msgstr ""
"`JSON (нотация объектов JavaScript) <https://json.org>`_, указанный :rfc:"
"`7159` (который устарел :rfc:`4627`) и `ECMA-404 <https://ecma- "
"International.org/publications-and-standards/standards/ecma-404/>`_ — это "
"облегченный формат обмена данными, созданный на основе `JavaScript <https://"
"en.wikipedia.org/wiki/JavaScript>`_ синтаксиса объектных литералов. (хотя "
"это не строгое подмножество JavaScript [#rfc-ошибка]_ )."

#: ../../library/json.rst:22
msgid ""
"Be cautious when parsing JSON data from untrusted sources. A malicious JSON "
"string may cause the decoder to consume considerable CPU and memory "
"resources. Limiting the size of data to be parsed is recommended."
msgstr ""
"Будьте осторожны при анализе данных JSON из ненадежных источников. "
"Вредоносная строка JSON может привести к тому, что декодер будет потреблять "
"значительные ресурсы ЦП и памяти. Рекомендуется ограничить размер "
"анализируемых данных."

#: ../../library/json.rst:26
msgid ""
":mod:`json` exposes an API familiar to users of the standard library :mod:"
"`marshal` and :mod:`pickle` modules."
msgstr ""
":mod:`json` предоставляет API, знакомый пользователям модулей стандартной "
"библиотеки :mod:`marshal` и :mod:`pickle`."

#: ../../library/json.rst:29
msgid "Encoding basic Python object hierarchies::"
msgstr "Кодирование основных иерархий объектов Python:"

#: ../../library/json.rst:31
msgid ""
">>> import json\n"
">>> json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])\n"
"'[\"foo\", {\"bar\": [\"baz\", null, 1.0, 2]}]'\n"
">>> print(json.dumps(\"\\\"foo\\bar\"))\n"
"\"\\\"foo\\bar\"\n"
">>> print(json.dumps('\\u1234'))\n"
"\"\\u1234\"\n"
">>> print(json.dumps('\\\\'))\n"
"\"\\\\\"\n"
">>> print(json.dumps({\"c\": 0, \"b\": 0, \"a\": 0}, sort_keys=True))\n"
"{\"a\": 0, \"b\": 0, \"c\": 0}\n"
">>> from io import StringIO\n"
">>> io = StringIO()\n"
">>> json.dump(['streaming API'], io)\n"
">>> io.getvalue()\n"
"'[\"streaming API\"]'"
msgstr ""
">>> import json\n"
">>> json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])\n"
"'[\"foo\", {\"bar\": [\"baz\", null, 1.0, 2]}]'\n"
">>> print(json.dumps(\"\\\"foo\\bar\"))\n"
"\"\\\"foo\\bar\"\n"
">>> print(json.dumps('\\u1234'))\n"
"\"\\u1234\"\n"
">>> print(json.dumps('\\\\'))\n"
"\"\\\\\"\n"
">>> print(json.dumps({\"c\": 0, \"b\": 0, \"a\": 0}, sort_keys=True))\n"
"{\"a\": 0, \"b\": 0, \"c\": 0}\n"
">>> from io import StringIO\n"
">>> io = StringIO()\n"
">>> json.dump(['streaming API'], io)\n"
">>> io.getvalue()\n"
"'[\"streaming API\"]'"

#: ../../library/json.rst:48
msgid "Compact encoding::"
msgstr "Компактное кодирование::"

#: ../../library/json.rst:50
msgid ""
">>> import json\n"
">>> json.dumps([1, 2, 3, {'4': 5, '6': 7}], separators=(',', ':'))\n"
"'[1,2,3,{\"4\":5,\"6\":7}]'"
msgstr ""
">>> import json\n"
">>> json.dumps([1, 2, 3, {'4': 5, '6': 7}], separators=(',', ':'))\n"
"'[1,2,3,{\"4\":5,\"6\":7}]'"

#: ../../library/json.rst:54
msgid "Pretty printing::"
msgstr "Красивая печать::"

#: ../../library/json.rst:56
msgid ""
">>> import json\n"
">>> print(json.dumps({'6': 7, '4': 5}, sort_keys=True, indent=4))\n"
"{\n"
"    \"4\": 5,\n"
"    \"6\": 7\n"
"}"
msgstr ""
">>> import json\n"
">>> print(json.dumps({'6': 7, '4': 5}, sort_keys=True, indent=4))\n"
"{\n"
"    \"4\": 5,\n"
"    \"6\": 7\n"
"}"

#: ../../library/json.rst:63
msgid "Specializing JSON object encoding::"
msgstr "Специализация кодирования объектов JSON::"

#: ../../library/json.rst:65
msgid ""
">>> import json\n"
">>> def custom_json(obj):\n"
"...     if isinstance(obj, complex):\n"
"...         return {'__complex__': True, 'real': obj.real, 'imag': obj."
"imag}\n"
"...     raise TypeError(f'Cannot serialize object of {type(obj)}')\n"
"...\n"
">>> json.dumps(1 + 2j, default=custom_json)\n"
"'{\"__complex__\": true, \"real\": 1.0, \"imag\": 2.0}'"
msgstr ""
">>> import json\n"
">>> def custom_json(obj):\n"
"...     if isinstance(obj, complex):\n"
"...         return {'__complex__': True, 'real': obj.real, 'imag': obj."
"imag}\n"
"...     raise TypeError(f'Cannot serialize object of {type(obj)}')\n"
"...\n"
">>> json.dumps(1 + 2j, default=custom_json)\n"
"'{\"__complex__\": true, \"real\": 1.0, \"imag\": 2.0}'"

#: ../../library/json.rst:74
msgid "Decoding JSON::"
msgstr "Декодирование JSON::"

#: ../../library/json.rst:76
msgid ""
">>> import json\n"
">>> json.loads('[\"foo\", {\"bar\":[\"baz\", null, 1.0, 2]}]')\n"
"['foo', {'bar': ['baz', None, 1.0, 2]}]\n"
">>> json.loads('\"\\\\\"foo\\\\bar\"')\n"
"'\"foo\\x08ar'\n"
">>> from io import StringIO\n"
">>> io = StringIO('[\"streaming API\"]')\n"
">>> json.load(io)\n"
"['streaming API']"
msgstr ""
">>> import json\n"
">>> json.loads('[\"foo\", {\"bar\":[\"baz\", null, 1.0, 2]}]')\n"
"['foo', {'bar': ['baz', None, 1.0, 2]}]\n"
">>> json.loads('\"\\\\\"foo\\\\bar\"')\n"
"'\"foo\\x08ar'\n"
">>> from io import StringIO\n"
">>> io = StringIO('[\"streaming API\"]')\n"
">>> json.load(io)\n"
"['streaming API']"

#: ../../library/json.rst:86
msgid "Specializing JSON object decoding::"
msgstr "Специализируемое декодирование объектов JSON::"

#: ../../library/json.rst:88
msgid ""
">>> import json\n"
">>> def as_complex(dct):\n"
"...     if '__complex__' in dct:\n"
"...         return complex(dct['real'], dct['imag'])\n"
"...     return dct\n"
"...\n"
">>> json.loads('{\"__complex__\": true, \"real\": 1, \"imag\": 2}',\n"
"...     object_hook=as_complex)\n"
"(1+2j)\n"
">>> import decimal\n"
">>> json.loads('1.1', parse_float=decimal.Decimal)\n"
"Decimal('1.1')"
msgstr ""
">>> import json\n"
">>> def as_complex(dct):\n"
"...     if '__complex__' in dct:\n"
"...         return complex(dct['real'], dct['imag'])\n"
"...     return dct\n"
"...\n"
">>> json.loads('{\"__complex__\": true, \"real\": 1, \"imag\": 2}',\n"
"...     object_hook=as_complex)\n"
"(1+2j)\n"
">>> import decimal\n"
">>> json.loads('1.1', parse_float=decimal.Decimal)\n"
"Decimal('1.1')"

#: ../../library/json.rst:101
msgid "Extending :class:`JSONEncoder`::"
msgstr "Расширение :class:`JSONEncoder`::"

#: ../../library/json.rst:103
msgid ""
">>> import json\n"
">>> class ComplexEncoder(json.JSONEncoder):\n"
"...     def default(self, obj):\n"
"...         if isinstance(obj, complex):\n"
"...             return [obj.real, obj.imag]\n"
"...         # Let the base class default method raise the TypeError\n"
"...         return super().default(obj)\n"
"...\n"
">>> json.dumps(2 + 1j, cls=ComplexEncoder)\n"
"'[2.0, 1.0]'\n"
">>> ComplexEncoder().encode(2 + 1j)\n"
"'[2.0, 1.0]'\n"
">>> list(ComplexEncoder().iterencode(2 + 1j))\n"
"['[2.0', ', 1.0', ']']"
msgstr ""
">>> import json\n"
">>> class ComplexEncoder(json.JSONEncoder):\n"
"...     def default(self, obj):\n"
"...         if isinstance(obj, complex):\n"
"...             return [obj.real, obj.imag]\n"
"...         # Let the base class default method raise the TypeError\n"
"...         return super().default(obj)\n"
"...\n"
">>> json.dumps(2 + 1j, cls=ComplexEncoder)\n"
"'[2.0, 1.0]'\n"
">>> ComplexEncoder().encode(2 + 1j)\n"
"'[2.0, 1.0]'\n"
">>> list(ComplexEncoder().iterencode(2 + 1j))\n"
"['[2.0', ', 1.0', ']']"

#: ../../library/json.rst:119
msgid "Using :mod:`json.tool` from the shell to validate and pretty-print:"
msgstr ""
"Использование :mod:`json.tool` из оболочки для проверки и красивой печати:"

#: ../../library/json.rst:121
msgid ""
"$ echo '{\"json\":\"obj\"}' | python -m json.tool\n"
"{\n"
"    \"json\": \"obj\"\n"
"}\n"
"$ echo '{1.2:3.4}' | python -m json.tool\n"
"Expecting property name enclosed in double quotes: line 1 column 2 (char 1)"
msgstr ""
"$ echo '{\"json\":\"obj\"}' | python -m json.tool\n"
"{\n"
"    \"json\": \"obj\"\n"
"}\n"
"$ echo '{1.2:3.4}' | python -m json.tool\n"
"Expecting property name enclosed in double quotes: line 1 column 2 (char 1)"

#: ../../library/json.rst:130
msgid "See :ref:`json-commandline` for detailed documentation."
msgstr "Подробную документацию смотрите в :ref:`json-commandline`."

#: ../../library/json.rst:134
msgid ""
"JSON is a subset of `YAML <https://yaml.org/>`_ 1.2.  The JSON produced by "
"this module's default settings (in particular, the default *separators* "
"value) is also a subset of YAML 1.0 and 1.1.  This module can thus also be "
"used as a YAML serializer."
msgstr ""
"JSON — это подмножество `YAML <https://yaml.org/>`_ 1.2. JSON, создаваемый "
"настройками по умолчанию этого модуля (в частности, значением *разделителей* "
"по умолчанию), также является подмножеством YAML 1.0 и 1.1. Таким образом, "
"этот модуль также можно использовать в качестве сериализатора YAML."

#: ../../library/json.rst:141
msgid ""
"This module's encoders and decoders preserve input and output order by "
"default.  Order is only lost if the underlying containers are unordered."
msgstr ""
"Кодеры и декодеры этого модуля по умолчанию сохраняют порядок ввода и "
"вывода. Порядок теряется только в том случае, если базовые контейнеры "
"неупорядочены."

#: ../../library/json.rst:146
msgid "Basic Usage"
msgstr "Основное использование"

#: ../../library/json.rst:153
msgid ""
"Serialize *obj* as a JSON formatted stream to *fp* (a ``.write()``-"
"supporting :term:`file-like object`) using this :ref:`conversion table <py-"
"to-json-table>`."
msgstr ""
"Сериализуйте *obj* как поток в формате JSON в *fp* (файловый объект с "
"поддержкой ``.write()``), используя эту :ref:`таблицу преобразования <py-to-"
"json- таблица>`."

#: ../../library/json.rst:157
msgid ""
"If *skipkeys* is true (default: ``False``), then dict keys that are not of a "
"basic type (:class:`str`, :class:`int`, :class:`float`, :class:`bool`, "
"``None``) will be skipped instead of raising a :exc:`TypeError`."
msgstr ""
"Если *skipkeys* имеет значение true (по умолчанию: ``False``), тогда "
"диктуются ключи, которые не относятся к базовому типу (:class:`str`, :class:"
"`int`, :class:`float`, :class :`bool`, ``None``) будут пропущены вместо "
"возникновения :exc:`TypeError`."

#: ../../library/json.rst:161
msgid ""
"The :mod:`json` module always produces :class:`str` objects, not :class:"
"`bytes` objects. Therefore, ``fp.write()`` must support :class:`str` input."
msgstr ""
"Модуль :mod:`json` всегда создает объекты :class:`str`, а не объекты :class:"
"`bytes`. Следовательно, ``fp.write()`` должен поддерживать ввод :class:`str`."

#: ../../library/json.rst:165 ../../library/json.rst:442
msgid ""
"If *ensure_ascii* is true (the default), the output is guaranteed to have "
"all incoming non-ASCII characters escaped.  If *ensure_ascii* is false, "
"these characters will be output as-is."
msgstr ""
"Если *ensure_ascii* имеет значение true (по умолчанию), в выводе "
"гарантированно будут экранированы все входящие символы, отличные от ASCII. "
"Если *ensure_ascii* имеет значение false, эти символы будут выводиться как "
"есть."

#: ../../library/json.rst:169
msgid ""
"If *check_circular* is false (default: ``True``), then the circular "
"reference check for container types will be skipped and a circular reference "
"will result in a :exc:`RecursionError` (or worse)."
msgstr ""
"Если *check_circular* имеет значение false (по умолчанию: ``True``), то "
"циклическая проверка ссылок для типов контейнеров будет пропущена, а "
"циклическая ссылка приведет к ошибке :exc:`RecursionError` (или еще хуже)."

#: ../../library/json.rst:173
msgid ""
"If *allow_nan* is false (default: ``True``), then it will be a :exc:"
"`ValueError` to serialize out of range :class:`float` values (``nan``, "
"``inf``, ``-inf``) in strict compliance of the JSON specification. If "
"*allow_nan* is true, their JavaScript equivalents (``NaN``, ``Infinity``, ``-"
"Infinity``) will be used."
msgstr ""
"Если *allow_nan* имеет значение false (по умолчанию: ``True``), то это "
"будет :exc:`ValueError` для сериализации вне диапазона значений :class:"
"`float` (``nan``, ``inf` `, ``-inf``) в строгом соответствии со "
"спецификацией JSON. Если *allow_nan* имеет значение true, будут "
"использоваться их эквиваленты в JavaScript (``NaN``, ``Infinity``, ``-"
"Infinity``)."

#: ../../library/json.rst:179 ../../library/json.rst:461
msgid ""
"If *indent* is a non-negative integer or string, then JSON array elements "
"and object members will be pretty-printed with that indent level.  An indent "
"level of 0, negative, or ``\"\"`` will only insert newlines.  ``None`` (the "
"default) selects the most compact representation. Using a positive integer "
"indent indents that many spaces per level.  If *indent* is a string (such as "
"``\"\\t\"``), that string is used to indent each level."
msgstr ""
"Если *indent* является неотрицательным целым числом или строкой, то элементы "
"массива JSON и члены объекта будут красиво напечатаны с этим уровнем "
"отступа. Уровень отступа 0, отрицательный или ``\"\"`` будет вставлять "
"только новые строки. ``Нет`` (по умолчанию) выбирает наиболее компактное "
"представление. Использование положительного целочисленного отступа приводит "
"к отступу на такое количество пробелов на уровень. Если *indent* — это "
"строка (например, ``\"\\t\"``), эта строка используется для отступа каждого "
"уровня."

#: ../../library/json.rst:186 ../../library/json.rst:468
msgid "Allow strings for *indent* in addition to integers."
msgstr "Разрешить строки для *отступа* в дополнение к целым числам."

#: ../../library/json.rst:189 ../../library/json.rst:471
msgid ""
"If specified, *separators* should be an ``(item_separator, key_separator)`` "
"tuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and ``(',', "
"': ')`` otherwise.  To get the most compact JSON representation, you should "
"specify ``(',', ':')`` to eliminate whitespace."
msgstr ""
"Если указано, *разделители* должны быть кортежем ``(item_separator, "
"key_separator)``. По умолчанию используется ``(', ', ': ')``, если *indent* "
"равен ``None``, и ``(',', ': ')`` в противном случае. Чтобы получить "
"наиболее компактное представление JSON, вам следует указать ``(',', ':')`` "
"для устранения пробелов."

#: ../../library/json.rst:194 ../../library/json.rst:476
msgid "Use ``(',', ': ')`` as default if *indent* is not ``None``."
msgstr ""
"Используйте ``(',', ': ')`` по умолчанию, если *indent* не равен ``None``."

#: ../../library/json.rst:197 ../../library/json.rst:479
msgid ""
"If specified, *default* should be a function that gets called for objects "
"that can't otherwise be serialized.  It should return a JSON encodable "
"version of the object or raise a :exc:`TypeError`.  If not specified, :exc:"
"`TypeError` is raised."
msgstr ""
"Если указано, *default* должна быть функцией, которая вызывается для "
"объектов, которые иначе не могут быть сериализованы. Он должен возвращать "
"версию объекта, кодируемую JSON, или выдавать ошибку :exc:`TypeError`. Если "
"не указано, возникает :exc:`TypeError`."

#: ../../library/json.rst:202
msgid ""
"If *sort_keys* is true (default: ``False``), then the output of dictionaries "
"will be sorted by key."
msgstr ""
"Если *sort_keys* имеет значение true (по умолчанию: ``False``), то вывод "
"словарей будет отсортирован по ключу."

#: ../../library/json.rst:205
msgid ""
"To use a custom :class:`JSONEncoder` subclass (e.g. one that overrides the :"
"meth:`~JSONEncoder.default` method to serialize additional types), specify "
"it with the *cls* kwarg; otherwise :class:`JSONEncoder` is used."
msgstr ""
"Чтобы использовать собственный подкласс :class:`JSONEncoder` (например, тот, "
"который переопределяет метод :meth:`~JSONEncoder.default` для сериализации "
"дополнительных типов), укажите его с помощью *cls* kwarg; в противном случае "
"используется :class:`JSONEncoder`."

#: ../../library/json.rst:209 ../../library/json.rst:287
msgid ""
"All optional parameters are now :ref:`keyword-only <keyword-only_parameter>`."
msgstr ""
"Все необязательные параметры теперь :ref:`keyword-only <keyword-"
"only_parameter>`."

#: ../../library/json.rst:214
msgid ""
"Unlike :mod:`pickle` and :mod:`marshal`, JSON is not a framed protocol, so "
"trying to serialize multiple objects with repeated calls to :func:`dump` "
"using the same *fp* will result in an invalid JSON file."
msgstr ""
"В отличие от :mod:`pickle` и :mod:`marshal`, JSON не является фреймовым "
"протоколом, поэтому попытка сериализации нескольких объектов с повторными "
"вызовами :func:`dump` с использованием одного и того же *fp* приведет к "
"недопустимому JSON. файл."

#: ../../library/json.rst:223
msgid ""
"Serialize *obj* to a JSON formatted :class:`str` using this :ref:`conversion "
"table <py-to-json-table>`.  The arguments have the same meaning as in :func:"
"`dump`."
msgstr ""
"Сериализуйте *obj* в формат JSON :class:`str`, используя эту :ref:`таблицу "
"преобразования <py-to-json-table>`. Аргументы имеют то же значение, что и в :"
"func:`dump`."

#: ../../library/json.rst:229
msgid ""
"Keys in key/value pairs of JSON are always of the type :class:`str`. When a "
"dictionary is converted into JSON, all the keys of the dictionary are "
"coerced to strings. As a result of this, if a dictionary is converted into "
"JSON and then back into a dictionary, the dictionary may not equal the "
"original one. That is, ``loads(dumps(x)) != x`` if x has non-string keys."
msgstr ""
"Ключи в парах ключ/значение JSON всегда имеют тип :class:`str`. Когда "
"словарь преобразуется в JSON, все ключи словаря преобразуются в строки. В "
"результате, если словарь преобразуется в JSON, а затем обратно в словарь, "
"словарь может не совпадать с исходным. То есть ``loads(dumps(x)) != x``, "
"если x имеет нестроковые ключи."

#: ../../library/json.rst:238
msgid ""
"Deserialize *fp* (a ``.read()``-supporting :term:`text file` or :term:"
"`binary file` containing a JSON document) to a Python object using this :ref:"
"`conversion table <json-to-py-table>`."
msgstr ""
"Десериализовать *fp* (текстовый файл с поддержкой ``.read()`` или :term:"
"`двоичный файл`, содержащий документ JSON) в объект Python, используя эту :"
"ref:`таблицу преобразования <json -to-py-table>`."

#: ../../library/json.rst:242
msgid ""
"*object_hook* is an optional function that will be called with the result of "
"any object literal decoded (a :class:`dict`).  The return value of "
"*object_hook* will be used instead of the :class:`dict`.  This feature can "
"be used to implement custom decoders (e.g. `JSON-RPC <https://www.jsonrpc."
"org>`_ class hinting)."
msgstr ""
"*object_hook* — это необязательная функция, которая будет вызываться с "
"результатом любого декодированного литерала объекта (:class:`dict`). "
"Возвращаемое значение *object_hook* будет использоваться вместо :class:"
"`dict`. Эту функцию можно использовать для реализации пользовательских "
"декодеров (например, подсказка класса JSON-RPC <https://www.jsonrpc.org>_)."

#: ../../library/json.rst:248
msgid ""
"*object_pairs_hook* is an optional function that will be called with the "
"result of any object literal decoded with an ordered list of pairs.  The "
"return value of *object_pairs_hook* will be used instead of the :class:"
"`dict`.  This feature can be used to implement custom decoders.  If "
"*object_hook* is also defined, the *object_pairs_hook* takes priority."
msgstr ""
"*object_pairs_hook* — это необязательная функция, которая будет вызываться с "
"результатом любого литерала объекта, декодированного с помощью "
"упорядоченного списка пар. Возвращаемое значение *object_pairs_hook* будет "
"использоваться вместо :class:`dict`. Эту функцию можно использовать для "
"реализации пользовательских декодеров. Если также определен *object_hook*, "
"*object_pairs_hook* имеет приоритет."

#: ../../library/json.rst:254 ../../library/json.rst:358
msgid "Added support for *object_pairs_hook*."
msgstr "Добавлена ​​поддержка *object_pairs_hook*."

#: ../../library/json.rst:257 ../../library/json.rst:361
msgid ""
"*parse_float* is an optional function that will be called with the string of "
"every JSON float to be decoded.  By default, this is equivalent to "
"``float(num_str)``.  This can be used to use another datatype or parser for "
"JSON floats (e.g. :class:`decimal.Decimal`)."
msgstr ""
"*parse_float* — это необязательная функция, которая будет вызываться со "
"строкой каждого числа с плавающей запятой JSON, подлежащего декодированию. "
"По умолчанию это эквивалентно ``float(num_str)``. Это можно использовать для "
"использования другого типа данных или синтаксического анализатора для чисел "
"с плавающей запятой JSON (например, :class:`decimal.Decimal`)."

#: ../../library/json.rst:262 ../../library/json.rst:366
msgid ""
"*parse_int* is an optional function that will be called with the string of "
"every JSON int to be decoded.  By default, this is equivalent to "
"``int(num_str)``.  This can be used to use another datatype or parser for "
"JSON integers (e.g. :class:`float`)."
msgstr ""
"*parse_int* — это необязательная функция, которая будет вызываться со "
"строкой каждого целого числа JSON, подлежащего декодированию. По умолчанию "
"это эквивалентно ``int(num_str)``. Это можно использовать для использования "
"другого типа данных или синтаксического анализатора целых чисел JSON "
"(например, :class:`float`)."

#: ../../library/json.rst:267
msgid ""
"The default *parse_int* of :func:`int` now limits the maximum length of the "
"integer string via the interpreter's :ref:`integer string conversion length "
"limitation <int_max_str_digits>` to help avoid denial of service attacks."
msgstr ""
"Значение *parse_int* по умолчанию для :func:`int` теперь ограничивает "
"максимальную длину целочисленной строки посредством :ref:`ограничения длины "
"преобразования целочисленной строки интерпретатора <int_max_str_digits>`, "
"чтобы помочь избежать атак типа «отказ в обслуживании»."

#: ../../library/json.rst:273 ../../library/json.rst:371
msgid ""
"*parse_constant* is an optional function that will be called with one of the "
"following strings: ``'-Infinity'``, ``'Infinity'``, ``'NaN'``.  This can be "
"used to raise an exception if invalid JSON numbers are encountered."
msgstr ""
"*parse_constant* — это необязательная функция, которая будет вызываться с "
"одной из следующих строк: ``'-Infinity'``, ``'Infinity'``, ``'NaN'``. Это "
"можно использовать для создания исключения при обнаружении недопустимых "
"номеров JSON."

#: ../../library/json.rst:277
msgid "*parse_constant* doesn't get called on 'null', 'true', 'false' anymore."
msgstr ""
"*parse_constant* больше не вызывается для значений «null», «true», «false»."

#: ../../library/json.rst:280
msgid ""
"To use a custom :class:`JSONDecoder` subclass, specify it with the ``cls`` "
"kwarg; otherwise :class:`JSONDecoder` is used.  Additional keyword arguments "
"will be passed to the constructor of the class."
msgstr ""
"Чтобы использовать собственный подкласс :class:`JSONDecoder`, укажите его с "
"помощью ``cls`` kwarg; в противном случае используется :class:`JSONDecoder`. "
"Дополнительные аргументы ключевого слова будут переданы конструктору класса."

#: ../../library/json.rst:284 ../../library/json.rst:302
#: ../../library/json.rst:380
msgid ""
"If the data being deserialized is not a valid JSON document, a :exc:"
"`JSONDecodeError` will be raised."
msgstr ""
"Если десериализуемые данные не являются допустимым документом JSON, будет "
"выдано сообщение :exc:`JSONDecodeError`."

#: ../../library/json.rst:290
msgid ""
"*fp* can now be a :term:`binary file`. The input encoding should be UTF-8, "
"UTF-16 or UTF-32."
msgstr ""
"*fp* теперь может быть :term:`двоичным файлом`. Входная кодировка должна "
"быть UTF-8, UTF-16 или UTF-32."

#: ../../library/json.rst:296
msgid ""
"Deserialize *s* (a :class:`str`, :class:`bytes` or :class:`bytearray` "
"instance containing a JSON document) to a Python object using this :ref:"
"`conversion table <json-to-py-table>`."
msgstr ""
"Десериализовать *s* (экземпляр :class:`str`, :class:`bytes` или :class:"
"`bytearray`, содержащий документ JSON) в объект Python, используя эту :ref:"
"`таблицу преобразования <json-to-py -таблица>`."

#: ../../library/json.rst:300
msgid "The other arguments have the same meaning as in :func:`load`."
msgstr "Остальные аргументы имеют то же значение, что и в :func:`load`."

#: ../../library/json.rst:305
msgid ""
"*s* can now be of type :class:`bytes` or :class:`bytearray`. The input "
"encoding should be UTF-8, UTF-16 or UTF-32."
msgstr ""
"*s* теперь может иметь тип :class:`bytes` или :class:`bytearray`. Входная "
"кодировка должна быть UTF-8, UTF-16 или UTF-32."

#: ../../library/json.rst:309
msgid "The keyword argument *encoding* has been removed."
msgstr "Ключевое слово *encoding* было удалено."

#: ../../library/json.rst:314
msgid "Encoders and Decoders"
msgstr "Кодеры и декодеры"

#: ../../library/json.rst:318
msgid "Simple JSON decoder."
msgstr "Простой декодер JSON."

#: ../../library/json.rst:320
msgid "Performs the following translations in decoding by default:"
msgstr "По умолчанию выполняет следующие преобразования при декодировании:"

#: ../../library/json.rst:325 ../../library/json.rst:413
msgid "JSON"
msgstr "JSON"

#: ../../library/json.rst:325 ../../library/json.rst:413
msgid "Python"
msgstr "Python"

#: ../../library/json.rst:327 ../../library/json.rst:415
msgid "object"
msgstr "объект"

#: ../../library/json.rst:327 ../../library/json.rst:415
msgid "dict"
msgstr "словарь"

#: ../../library/json.rst:329 ../../library/json.rst:417
msgid "array"
msgstr "array"

#: ../../library/json.rst:329
msgid "list"
msgstr "список"

#: ../../library/json.rst:331 ../../library/json.rst:419
msgid "string"
msgstr "строка"

#: ../../library/json.rst:331 ../../library/json.rst:419
msgid "str"
msgstr "str"

#: ../../library/json.rst:333
msgid "number (int)"
msgstr "число (int)"

#: ../../library/json.rst:333
msgid "int"
msgstr "int"

#: ../../library/json.rst:335
msgid "number (real)"
msgstr "число (вещественное)"

#: ../../library/json.rst:335
msgid "float"
msgstr "float"

#: ../../library/json.rst:337 ../../library/json.rst:423
msgid "true"
msgstr "истина"

#: ../../library/json.rst:337 ../../library/json.rst:423
msgid "True"
msgstr "Истина"

#: ../../library/json.rst:339 ../../library/json.rst:425
msgid "false"
msgstr "ложь"

#: ../../library/json.rst:339 ../../library/json.rst:425
msgid "False"
msgstr "Ложь"

#: ../../library/json.rst:341 ../../library/json.rst:427
msgid "null"
msgstr "null"

#: ../../library/json.rst:341 ../../library/json.rst:427
msgid "None"
msgstr "None"

#: ../../library/json.rst:344
msgid ""
"It also understands ``NaN``, ``Infinity``, and ``-Infinity`` as their "
"corresponding ``float`` values, which is outside the JSON spec."
msgstr ""
"Он также понимает ``NaN``, ``Infinity`` и ``-Infinity`` как соответствующие "
"им значения ``float``, которые находятся за пределами спецификации JSON."

#: ../../library/json.rst:347
msgid ""
"*object_hook* is an optional function that will be called with the result of "
"every JSON object decoded and its return value will be used in place of the "
"given :class:`dict`.  This can be used to provide custom deserializations (e."
"g. to support `JSON-RPC <https://www.jsonrpc.org>`_ class hinting)."
msgstr ""
"*object_hook* — это необязательная функция, которая будет вызываться с "
"результатом каждого декодированного объекта JSON, и ее возвращаемое значение "
"будет использоваться вместо заданного :class:`dict`. Это можно использовать "
"для предоставления пользовательских десериализаций (например, для поддержки "
"подсказок классов `JSON-RPC <https://www.jsonrpc.org>`_)."

#: ../../library/json.rst:352
msgid ""
"*object_pairs_hook* is an optional function that will be called with the "
"result of every JSON object decoded with an ordered list of pairs.  The "
"return value of *object_pairs_hook* will be used instead of the :class:"
"`dict`.  This feature can be used to implement custom decoders.  If "
"*object_hook* is also defined, the *object_pairs_hook* takes priority."
msgstr ""
"*object_pairs_hook* — это необязательная функция, которая будет вызываться с "
"результатом каждого объекта JSON, декодированного с помощью упорядоченного "
"списка пар. Возвращаемое значение *object_pairs_hook* будет использоваться "
"вместо :class:`dict`. Эту функцию можно использовать для реализации "
"пользовательских декодеров. Если также определен *object_hook*, "
"*object_pairs_hook* имеет приоритет."

#: ../../library/json.rst:375
msgid ""
"If *strict* is false (``True`` is the default), then control characters will "
"be allowed inside strings.  Control characters in this context are those "
"with character codes in the 0--31 range, including ``'\\t'`` (tab), "
"``'\\n'``, ``'\\r'`` and ``'\\0'``."
msgstr ""
"Если *strict* имеет значение false (по умолчанию — True), то внутри строк "
"будут разрешены управляющие символы. Управляющие символы в этом контексте — "
"это символы с кодами символов в диапазоне 0–31, включая ``'\\t'`` "
"(табуляция), ``'\\n'``, ``'\\r'`` и ``'\\r'`` `'\\0'``."

#: ../../library/json.rst:383 ../../library/json.rst:484
msgid "All parameters are now :ref:`keyword-only <keyword-only_parameter>`."
msgstr "Все параметры теперь :ref:`keyword-only <keyword-only_parameter>`."

#: ../../library/json.rst:388
msgid ""
"Return the Python representation of *s* (a :class:`str` instance containing "
"a JSON document)."
msgstr ""
"Верните представление Python *s* (экземпляр :class:`str`, содержащий "
"документ JSON)."

#: ../../library/json.rst:391
msgid ""
":exc:`JSONDecodeError` will be raised if the given JSON document is not "
"valid."
msgstr ""
":exc:`JSONDecodeError` будет вызвано, если данный документ JSON "
"недействителен."

#: ../../library/json.rst:396
msgid ""
"Decode a JSON document from *s* (a :class:`str` beginning with a JSON "
"document) and return a 2-tuple of the Python representation and the index in "
"*s* where the document ended."
msgstr ""
"Декодируйте документ JSON из *s* (:class:`str`, начинающийся с документа "
"JSON) и верните 2-кортеж представления Python и индекс в *s*, где закончился "
"документ."

#: ../../library/json.rst:400
msgid ""
"This can be used to decode a JSON document from a string that may have "
"extraneous data at the end."
msgstr ""
"Это можно использовать для декодирования документа JSON из строки, которая "
"может содержать посторонние данные в конце."

#: ../../library/json.rst:406
msgid "Extensible JSON encoder for Python data structures."
msgstr "Расширяемый кодер JSON для структур данных Python."

#: ../../library/json.rst:408
msgid "Supports the following objects and types by default:"
msgstr "По умолчанию поддерживает следующие объекты и типы:"

#: ../../library/json.rst:417
msgid "list, tuple"
msgstr "список, кортеж"

#: ../../library/json.rst:421
msgid "int, float, int- & float-derived Enums"
msgstr "int, float, перечисления, производные от int и float"

#: ../../library/json.rst:421
msgid "number"
msgstr "число"

#: ../../library/json.rst:430
msgid "Added support for int- and float-derived Enum classes."
msgstr "Добавлена ​​поддержка классов Enum, производных от int и float."

#: ../../library/json.rst:433
msgid ""
"To extend this to recognize other objects, subclass and implement a :meth:"
"`~JSONEncoder.default` method with another method that returns a "
"serializable object for ``o`` if possible, otherwise it should call the "
"superclass implementation (to raise :exc:`TypeError`)."
msgstr ""
"Чтобы расширить это для распознавания других объектов, создайте подкласс и "
"реализуйте метод :meth:`~JSONEncoder.default` с другим методом, который "
"возвращает сериализуемый объект для ``o``, если это возможно, в противном "
"случае он должен вызвать реализацию суперкласса (чтобы поднять: exc:"
"`TypeError`)."

#: ../../library/json.rst:438
msgid ""
"If *skipkeys* is false (the default), a :exc:`TypeError` will be raised when "
"trying to encode keys that are not :class:`str`, :class:`int`, :class:"
"`float` or ``None``.  If *skipkeys* is true, such items are simply skipped."
msgstr ""
"Если *skipkeys* имеет значение false (по умолчанию), при попытке "
"закодировать ключи, которые не являются :class:`str`, :class:`int`, :class:"
"`float` или ``Нет``. Если *skipkeys* имеет значение true, такие элементы "
"просто пропускаются."

#: ../../library/json.rst:446
msgid ""
"If *check_circular* is true (the default), then lists, dicts, and custom "
"encoded objects will be checked for circular references during encoding to "
"prevent an infinite recursion (which would cause a :exc:`RecursionError`). "
"Otherwise, no such check takes place."
msgstr ""
"Если *check_circular* имеет значение true (по умолчанию), то списки, словари "
"и пользовательские закодированные объекты будут проверяться на наличие "
"циклических ссылок во время кодирования, чтобы предотвратить бесконечную "
"рекурсию (которая может вызвать ошибку :exc:`RecursionError`). В противном "
"случае такой проверки не происходит."

#: ../../library/json.rst:451
msgid ""
"If *allow_nan* is true (the default), then ``NaN``, ``Infinity``, and ``-"
"Infinity`` will be encoded as such.  This behavior is not JSON specification "
"compliant, but is consistent with most JavaScript based encoders and "
"decoders.  Otherwise, it will be a :exc:`ValueError` to encode such floats."
msgstr ""
"Если *allow_nan* имеет значение true (по умолчанию), то ``NaN``, "
"``Infinity`` и ``-Infinity`` будут закодированы как таковые. Такое поведение "
"не соответствует спецификации JSON, но совместимо с большинством "
"кодировщиков и декодеров на основе JavaScript. В противном случае это будет :"
"exc:`ValueError` для кодирования таких чисел с плавающей запятой."

#: ../../library/json.rst:457
msgid ""
"If *sort_keys* is true (default: ``False``), then the output of dictionaries "
"will be sorted by key; this is useful for regression tests to ensure that "
"JSON serializations can be compared on a day-to-day basis."
msgstr ""
"Если *sort_keys* имеет значение true (по умолчанию: ``False``), то вывод "
"словарей будет отсортирован по ключу; это полезно для регрессионных тестов, "
"чтобы гарантировать возможность ежедневного сравнения сериализаций JSON."

#: ../../library/json.rst:490
msgid ""
"Implement this method in a subclass such that it returns a serializable "
"object for *o*, or calls the base implementation (to raise a :exc:"
"`TypeError`)."
msgstr ""
"Реализуйте этот метод в подклассе так, чтобы он возвращал сериализуемый "
"объект для *o*, или вызывал базовую реализацию (чтобы вызвать :exc:"
"`TypeError`)."

#: ../../library/json.rst:494
msgid ""
"For example, to support arbitrary iterators, you could implement :meth:"
"`~JSONEncoder.default` like this::"
msgstr ""
"Например, для поддержки произвольных итераторов вы можете реализовать :meth:"
"`~JSONEncoder.default` следующим образом:"

#: ../../library/json.rst:497
msgid ""
"def default(self, o):\n"
"   try:\n"
"       iterable = iter(o)\n"
"   except TypeError:\n"
"       pass\n"
"   else:\n"
"       return list(iterable)\n"
"   # Let the base class default method raise the TypeError\n"
"   return super().default(o)"
msgstr ""
"def default(self, o):\n"
"   try:\n"
"       iterable = iter(o)\n"
"   except TypeError:\n"
"       pass\n"
"   else:\n"
"       return list(iterable)\n"
"   # Let the base class default method raise the TypeError\n"
"   return super().default(o)"

#: ../../library/json.rst:510
msgid ""
"Return a JSON string representation of a Python data structure, *o*.  For "
"example::"
msgstr ""
"Возвращает строковое представление JSON структуры данных Python, *o*. "
"Например::"

#: ../../library/json.rst:513
msgid ""
">>> json.JSONEncoder().encode({\"foo\": [\"bar\", \"baz\"]})\n"
"'{\"foo\": [\"bar\", \"baz\"]}'"
msgstr ""
">>> json.JSONEncoder().encode({\"foo\": [\"bar\", \"baz\"]})\n"
"'{\"foo\": [\"bar\", \"baz\"]}'"

#: ../../library/json.rst:519
msgid ""
"Encode the given object, *o*, and yield each string representation as "
"available.  For example::"
msgstr ""
"Закодируйте данный объект *o* и выдайте каждое доступное строковое "
"представление. Например::"

#: ../../library/json.rst:522
msgid ""
"for chunk in json.JSONEncoder().iterencode(bigobject):\n"
"    mysocket.write(chunk)"
msgstr ""
"for chunk in json.JSONEncoder().iterencode(bigobject):\n"
"    mysocket.write(chunk)"

#: ../../library/json.rst:527
msgid "Exceptions"
msgstr "Исключения"

#: ../../library/json.rst:531
msgid "Subclass of :exc:`ValueError` with the following additional attributes:"
msgstr "Подкласс :exc:`ValueError` со следующими дополнительными атрибутами:"

#: ../../library/json.rst:535
msgid "The unformatted error message."
msgstr "Неформатированное сообщение об ошибке."

#: ../../library/json.rst:539
msgid "The JSON document being parsed."
msgstr "Анализируемый документ JSON."

#: ../../library/json.rst:543
msgid "The start index of *doc* where parsing failed."
msgstr "Начальный индекс *doc*, синтаксический анализ которого не удался."

#: ../../library/json.rst:547
msgid "The line corresponding to *pos*."
msgstr "Строка, соответствующая *pos*."

#: ../../library/json.rst:551
msgid "The column corresponding to *pos*."
msgstr "Столбец, соответствующий *pos*."

#: ../../library/json.rst:557
msgid "Standard Compliance and Interoperability"
msgstr "Соответствие стандартам и совместимость"

#: ../../library/json.rst:559
msgid ""
"The JSON format is specified by :rfc:`7159` and by `ECMA-404 <https://ecma-"
"international.org/publications-and-standards/standards/ecma-404/>`_. This "
"section details this module's level of compliance with the RFC. For "
"simplicity, :class:`JSONEncoder` and :class:`JSONDecoder` subclasses, and "
"parameters other than those explicitly mentioned, are not considered."
msgstr ""
"Формат JSON определяется :rfc:`7159` и `ECMA-404 <https://ecma-international."
"org/publications-and-standards/standards/ecma-404/>`_. В этом разделе "
"подробно описан уровень соответствия этого модуля RFC. Для простоты "
"подклассы :class:`JSONEncoder` и :class:`JSONDecoder`, а также параметры, "
"отличные от явно упомянутых, не учитываются."

#: ../../library/json.rst:565
msgid ""
"This module does not comply with the RFC in a strict fashion, implementing "
"some extensions that are valid JavaScript but not valid JSON.  In particular:"
msgstr ""
"Этот модуль не строго соответствует RFC, реализуя некоторые расширения, "
"которые являются действительным JavaScript, но не действительным JSON. В "
"частности:"

#: ../../library/json.rst:568
msgid "Infinite and NaN number values are accepted and output;"
msgstr "Принимаются и выводятся бесконечные числовые значения и значения NaN;"

#: ../../library/json.rst:569
msgid ""
"Repeated names within an object are accepted, and only the value of the last "
"name-value pair is used."
msgstr ""
"Допускаются повторяющиеся имена внутри объекта, и используется только "
"значение последней пары имя-значение."

#: ../../library/json.rst:572
msgid ""
"Since the RFC permits RFC-compliant parsers to accept input texts that are "
"not RFC-compliant, this module's deserializer is technically RFC-compliant "
"under default settings."
msgstr ""
"Поскольку RFC позволяет RFC-совместимым анализаторам принимать входные "
"тексты, которые не соответствуют RFC, десериализатор этого модуля технически "
"совместим с RFC при настройках по умолчанию."

#: ../../library/json.rst:577
msgid "Character Encodings"
msgstr "Кодировки символов"

#: ../../library/json.rst:579
msgid ""
"The RFC requires that JSON be represented using either UTF-8, UTF-16, or "
"UTF-32, with UTF-8 being the recommended default for maximum "
"interoperability."
msgstr ""
"RFC требует, чтобы JSON был представлен с использованием UTF-8, UTF-16 или "
"UTF-32, при этом UTF-8 является рекомендуемым значением по умолчанию для "
"максимальной совместимости."

#: ../../library/json.rst:582
msgid ""
"As permitted, though not required, by the RFC, this module's serializer sets "
"*ensure_ascii=True* by default, thus escaping the output so that the "
"resulting strings only contain ASCII characters."
msgstr ""
"Как разрешено, хотя и не требуется RFC, сериализатор этого модуля "
"устанавливает *ensure_ascii=True* по умолчанию, таким образом экранируя "
"выходные данные, чтобы результирующие строки содержали только символы ASCII."

#: ../../library/json.rst:586
msgid ""
"Other than the *ensure_ascii* parameter, this module is defined strictly in "
"terms of conversion between Python objects and :class:`Unicode strings "
"<str>`, and thus does not otherwise directly address the issue of character "
"encodings."
msgstr ""
"За исключением параметра *ensure_ascii*, этот модуль определяется строго с "
"точки зрения преобразования между объектами Python и :class:`строками "
"Unicode <str>` и, таким образом, напрямую не решает проблему кодировок "
"символов."

#: ../../library/json.rst:591
msgid ""
"The RFC prohibits adding a byte order mark (BOM) to the start of a JSON "
"text, and this module's serializer does not add a BOM to its output. The RFC "
"permits, but does not require, JSON deserializers to ignore an initial BOM "
"in their input.  This module's deserializer raises a :exc:`ValueError` when "
"an initial BOM is present."
msgstr ""
"RFC запрещает добавление метки порядка байтов (BOM) в начало текста JSON, а "
"сериализатор этого модуля не добавляет спецификацию к своим выводам. RFC "
"разрешает, но не требует, чтобы десериализаторы JSON игнорировали исходную "
"спецификацию во входных данных. Десериализатор этого модуля выдает ошибку :"
"exc:`ValueError` при наличии исходной спецификации."

#: ../../library/json.rst:597
msgid ""
"The RFC does not explicitly forbid JSON strings which contain byte sequences "
"that don't correspond to valid Unicode characters (e.g. unpaired UTF-16 "
"surrogates), but it does note that they may cause interoperability problems. "
"By default, this module accepts and outputs (when present in the original :"
"class:`str`) code points for such sequences."
msgstr ""
"RFC явно не запрещает строки JSON, содержащие последовательности байтов, "
"которые не соответствуют допустимым символам Юникода (например, непарные "
"суррогаты UTF-16), но отмечает, что они могут вызвать проблемы "
"совместимости. По умолчанию этот модуль принимает и выводит (если они "
"присутствуют в исходном :class:`str`) кодовые точки для таких "
"последовательностей."

#: ../../library/json.rst:605
msgid "Infinite and NaN Number Values"
msgstr "Бесконечные и числовые значения NaN"

#: ../../library/json.rst:607
msgid ""
"The RFC does not permit the representation of infinite or NaN number values. "
"Despite that, by default, this module accepts and outputs ``Infinity``, ``-"
"Infinity``, and ``NaN`` as if they were valid JSON number literal values::"
msgstr ""
"RFC не разрешает представление бесконечных числовых значений или значений "
"NaN. Несмотря на это, по умолчанию этот модуль принимает и выводит "
"``Infinity``, ``-Infinity`` и ``NaN``, как если бы они были действительными "
"литеральными значениями числа JSON::"

#: ../../library/json.rst:611
msgid ""
">>> # Neither of these calls raises an exception, but the results are not "
"valid JSON\n"
">>> json.dumps(float('-inf'))\n"
"'-Infinity'\n"
">>> json.dumps(float('nan'))\n"
"'NaN'\n"
">>> # Same when deserializing\n"
">>> json.loads('-Infinity')\n"
"-inf\n"
">>> json.loads('NaN')\n"
"nan"
msgstr ""
">>> # Neither of these calls raises an exception, but the results are not "
"valid JSON\n"
">>> json.dumps(float('-inf'))\n"
"'-Infinity'\n"
">>> json.dumps(float('nan'))\n"
"'NaN'\n"
">>> # Same when deserializing\n"
">>> json.loads('-Infinity')\n"
"-inf\n"
">>> json.loads('NaN')\n"
"nan"

#: ../../library/json.rst:622
msgid ""
"In the serializer, the *allow_nan* parameter can be used to alter this "
"behavior.  In the deserializer, the *parse_constant* parameter can be used "
"to alter this behavior."
msgstr ""
"В сериализаторе для изменения этого поведения можно использовать параметр "
"*allow_nan*. В десериализаторе для изменения этого поведения можно "
"использовать параметр *parse_constant*."

#: ../../library/json.rst:628
msgid "Repeated Names Within an Object"
msgstr "Повторяющиеся имена внутри объекта"

#: ../../library/json.rst:630
msgid ""
"The RFC specifies that the names within a JSON object should be unique, but "
"does not mandate how repeated names in JSON objects should be handled.  By "
"default, this module does not raise an exception; instead, it ignores all "
"but the last name-value pair for a given name::"
msgstr ""
"RFC указывает, что имена внутри объекта JSON должны быть уникальными, но не "
"определяет, как следует обрабатывать повторяющиеся имена в объектах JSON. По "
"умолчанию этот модуль не вызывает исключения; вместо этого он игнорирует "
"все, кроме последней пары имя-значение для данного имени::"

#: ../../library/json.rst:635
msgid ""
">>> weird_json = '{\"x\": 1, \"x\": 2, \"x\": 3}'\n"
">>> json.loads(weird_json)\n"
"{'x': 3}"
msgstr ""
">>> weird_json = '{\"x\": 1, \"x\": 2, \"x\": 3}'\n"
">>> json.loads(weird_json)\n"
"{'x': 3}"

#: ../../library/json.rst:639
msgid "The *object_pairs_hook* parameter can be used to alter this behavior."
msgstr ""
"Параметр *object_pairs_hook* можно использовать для изменения этого "
"поведения."

#: ../../library/json.rst:643
msgid "Top-level Non-Object, Non-Array Values"
msgstr "Значения верхнего уровня, не являющиеся объектами и не массивами"

#: ../../library/json.rst:645
msgid ""
"The old version of JSON specified by the obsolete :rfc:`4627` required that "
"the top-level value of a JSON text must be either a JSON object or array "
"(Python :class:`dict` or :class:`list`), and could not be a JSON null, "
"boolean, number, or string value.  :rfc:`7159` removed that restriction, and "
"this module does not and has never implemented that restriction in either "
"its serializer or its deserializer."
msgstr ""
"Старая версия JSON, указанная устаревшим :rfc:`4627`, требовала, чтобы "
"значение верхнего уровня текста JSON было либо объектом JSON, либо массивом "
"(Python :class:`dict` или :class:`list`) и не может быть нулевым, "
"логическим, числовым или строковым значением JSON. :rfc:`7159` удалил это "
"ограничение, и этот модуль не реализовал и никогда не реализовал это "
"ограничение ни в своем сериализаторе, ни в своем десериализаторе."

#: ../../library/json.rst:652
msgid ""
"Regardless, for maximum interoperability, you may wish to voluntarily adhere "
"to the restriction yourself."
msgstr ""
"В любом случае, для максимальной совместимости вы можете добровольно "
"соблюдать это ограничение самостоятельно."

#: ../../library/json.rst:657
msgid "Implementation Limitations"
msgstr "Ограничения в реализации"

#: ../../library/json.rst:659
msgid "Some JSON deserializer implementations may set limits on:"
msgstr ""
"Некоторые реализации десериализатора JSON могут устанавливать ограничения на:"

#: ../../library/json.rst:661
msgid "the size of accepted JSON texts"
msgstr ""
"Некоторые реализации десериализатора JSON могут устанавливать ограничения на:"

#: ../../library/json.rst:662
msgid "the maximum level of nesting of JSON objects and arrays"
msgstr "максимальный уровень вложенности объектов и массивов JSON"

#: ../../library/json.rst:663
msgid "the range and precision of JSON numbers"
msgstr "диапазон и точность чисел JSON"

#: ../../library/json.rst:664
msgid "the content and maximum length of JSON strings"
msgstr "содержимое и максимальная длина строк JSON"

#: ../../library/json.rst:666
msgid ""
"This module does not impose any such limits beyond those of the relevant "
"Python datatypes themselves or the Python interpreter itself."
msgstr ""
"Этот модуль не накладывает никаких подобных ограничений, кроме ограничений "
"самих соответствующих типов данных Python или самого интерпретатора Python."

#: ../../library/json.rst:669
msgid ""
"When serializing to JSON, beware any such limitations in applications that "
"may consume your JSON.  In particular, it is common for JSON numbers to be "
"deserialized into IEEE 754 double precision numbers and thus subject to that "
"representation's range and precision limitations.  This is especially "
"relevant when serializing Python :class:`int` values of extremely large "
"magnitude, or when serializing instances of \"exotic\" numerical types such "
"as :class:`decimal.Decimal`."
msgstr ""
"При сериализации в JSON остерегайтесь любых подобных ограничений в "
"приложениях, которые могут использовать ваш JSON. В частности, числа JSON "
"обычно десериализуются в числа двойной точности IEEE 754 и, таким образом, "
"подвергаются ограничениям диапазона и точности этого представления. Это "
"особенно актуально при сериализации значений Python :class:`int` чрезвычайно "
"большой величины или при сериализации экземпляров «экзотических» числовых "
"типов, таких как :class:`decimal.Decimal`."

#: ../../library/json.rst:682
msgid "Command Line Interface"
msgstr "Интерфейс командной строки"

#: ../../library/json.rst:687
msgid "**Source code:** :source:`Lib/json/tool.py`"
msgstr "**Исходный код:** :source:`Lib/json/tool.py`"

#: ../../library/json.rst:691
msgid ""
"The :mod:`json.tool` module provides a simple command line interface to "
"validate and pretty-print JSON objects."
msgstr ""
"Модуль :mod:`json.tool` предоставляет простой интерфейс командной строки для "
"проверки и удобной печати объектов JSON."

#: ../../library/json.rst:694
msgid ""
"If the optional ``infile`` and ``outfile`` arguments are not specified, :"
"data:`sys.stdin` and :data:`sys.stdout` will be used respectively:"
msgstr ""
"Если необязательные аргументы infile и outfile не указаны, будут "
"использоваться :data:`sys.stdin` и :data:`sys.stdout` соответственно:"

#: ../../library/json.rst:697
msgid ""
"$ echo '{\"json\": \"obj\"}' | python -m json.tool\n"
"{\n"
"    \"json\": \"obj\"\n"
"}\n"
"$ echo '{1.2:3.4}' | python -m json.tool\n"
"Expecting property name enclosed in double quotes: line 1 column 2 (char 1)"
msgstr ""
"$ echo '{\"json\": \"obj\"}' | python -m json.tool\n"
"{\n"
"    \"json\": \"obj\"\n"
"}\n"
"$ echo '{1.2:3.4}' | python -m json.tool\n"
"Expecting property name enclosed in double quotes: line 1 column 2 (char 1)"

#: ../../library/json.rst:706
msgid ""
"The output is now in the same order as the input. Use the :option:`--sort-"
"keys` option to sort the output of dictionaries alphabetically by key."
msgstr ""
"Вывод теперь находится в том же порядке, что и ввод. Используйте опцию :"
"option:`--sort-keys` для сортировки вывода словарей в алфавитном порядке по "
"ключу."

#: ../../library/json.rst:713
msgid "Command line options"
msgstr "Параметры командной строки"

#: ../../library/json.rst:717
msgid "The JSON file to be validated or pretty-printed:"
msgstr "Файл JSON, который необходимо проверить или распечатать:"

#: ../../library/json.rst:719
msgid ""
"$ python -m json.tool mp_films.json\n"
"[\n"
"    {\n"
"        \"title\": \"And Now for Something Completely Different\",\n"
"        \"year\": 1971\n"
"    },\n"
"    {\n"
"        \"title\": \"Monty Python and the Holy Grail\",\n"
"        \"year\": 1975\n"
"    }\n"
"]"
msgstr ""
"$ python -m json.tool mp_films.json\n"
"[\n"
"    {\n"
"        \"title\": \"And Now for Something Completely Different\",\n"
"        \"year\": 1971\n"
"    },\n"
"    {\n"
"        \"title\": \"Monty Python and the Holy Grail\",\n"
"        \"year\": 1975\n"
"    }\n"
"]"

#: ../../library/json.rst:733
msgid "If *infile* is not specified, read from :data:`sys.stdin`."
msgstr "Если *infile* не указан, читайте из :data:`sys.stdin`."

#: ../../library/json.rst:737
msgid ""
"Write the output of the *infile* to the given *outfile*. Otherwise, write it "
"to :data:`sys.stdout`."
msgstr ""
"Запишите вывод *infile* в данный *outfile*. В противном случае запишите его "
"в :data:`sys.stdout`."

#: ../../library/json.rst:742
msgid "Sort the output of dictionaries alphabetically by key."
msgstr "Отсортируйте вывод словарей в алфавитном порядке по ключу."

#: ../../library/json.rst:748
msgid ""
"Disable escaping of non-ascii characters, see :func:`json.dumps` for more "
"information."
msgstr ""
"Отключите экранирование символов, отличных от ascii, для получения "
"дополнительной информации см. :func:`json.dumps`."

#: ../../library/json.rst:754
msgid "Parse every input line as separate JSON object."
msgstr "Анализируйте каждую строку ввода как отдельный объект JSON."

#: ../../library/json.rst:760
msgid "Mutually exclusive options for whitespace control."
msgstr "Взаимоисключающие параметры управления пробелами."

#: ../../library/json.rst:766
msgid "Show the help message."
msgstr "Показать справочное сообщение."

#: ../../library/json.rst:770
msgid "Footnotes"
msgstr "Сноски"

#: ../../library/json.rst:771
msgid ""
"As noted in `the errata for RFC 7159 <https://www.rfc-editor.org/"
"errata_search.php?rfc=7159>`_, JSON permits literal U+2028 (LINE SEPARATOR) "
"and U+2029 (PARAGRAPH SEPARATOR) characters in strings, whereas JavaScript "
"(as of ECMAScript Edition 5.1) does not."
msgstr ""
"Как отмечено в `ошибках для RFC 7159 <https://www.rfc-editor.org/"
"errata_search.php?rfc=7159>`_, JSON допускает буквальные U+2028 "
"(СТРОИТЕЛЬНЫЙ РАЗДЕЛИТЕЛЬ) и U+2029 (ПАРАГРАФНЫЙ РАЗДЕЛИТЕЛЬ). ) символов в "
"строках, тогда как JavaScript (начиная с ECMAScript Edition 5.1) этого не "
"делает."
