# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# tomo, 2024
# 石井 明久, 2024
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.13\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-06-21 14:14+0000\n"
"PO-Revision-Date: 2024-05-11 01:08+0000\n"
"Last-Translator: 石井 明久, 2024\n"
"Language-Team: Japanese (https://app.transifex.com/python-doc/teams/5390/"
"ja/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../using/ios.rst:5
msgid "Using Python on iOS"
msgstr "iOS で Python を使う"

#: ../../using/ios.rst:0
msgid "Authors"
msgstr "著者"

#: ../../using/ios.rst:8
msgid "Russell Keith-Magee (2024-03)"
msgstr "Russell Keith-Magee (2024-03)"

#: ../../using/ios.rst:10
msgid ""
"Python on iOS is unlike Python on desktop platforms. On a desktop platform, "
"Python is generally installed as a system resource that can be used by any "
"user of that computer. Users then interact with Python by running a :program:"
"`python` executable and entering commands at an interactive prompt, or by "
"running a Python script."
msgstr ""
"iOS における Pythonは、デスクトッププラットフォームにおける Python とは異なり"
"ます。 デスクトッププラットフォームでは、 Python は一般的にコンピューターのど"
"のユーザーでも使えるシステムリソースとしてインストールされます。そして、ユー"
"ザーは :program:`python` 実行可能ファイルを実行して対話型プロンプトにコマンド"
"を入力したり、 Python スクリプトを実行したりして、 Python を使用することがで"
"きるのです。"

#: ../../using/ios.rst:16
msgid ""
"On iOS, there is no concept of installing as a system resource. The only "
"unit of software distribution is an \"app\". There is also no console where "
"you could run a :program:`python` executable, or interact with a Python REPL."
msgstr ""
"iOS においては、システムリソースとしてのインストールという概念はありません。"
"ソフトウェア配布が可能なのは、 \"アプリ\" だけです。また、 :program:`python` "
"実行可能ファイルの実行したり、 Python の REPL を使用したりする、コンソールも"
"存在しません。"

#: ../../using/ios.rst:20
msgid ""
"As a result, the only way you can use Python on iOS is in embedded mode - "
"that is, by writing a native iOS application, and embedding a Python "
"interpreter using ``libPython``, and invoking Python code using the :ref:"
"`Python embedding API <embedding>`. The full Python interpreter, the "
"standard library, and all your Python code is then packaged as a standalone "
"bundle that can be distributed via the iOS App Store."
msgstr ""
"このため、 Python を iOS 上で使うただ一つの方法は、埋め込みモード (embedded "
"mode) 、つまり、ネイティブ iOS アプリケーションを書き、 ``libPython`` を使用"
"して Python インタープリターを埋め込み、そして :ref:`Python 埋め込み API "
"<embedding>` を使用して Python コードを呼び出すことです。 それにより、完全な "
"Python インタープリター、標準ライブラリ、 及び Python のコードが、 iOS App "
"Store を経由して配布可能なスタンドアローンなバンドルとしてパッケージ化されま"
"す。"

#: ../../using/ios.rst:27
msgid ""
"If you're looking to experiment for the first time with writing an iOS app "
"in Python, projects such as `BeeWare <https://beeware.org>`__ and `Kivy "
"<https://kivy.org>`__ will provide a much more approachable user experience. "
"These projects manage the complexities associated with getting an iOS "
"project running, so you only need to deal with the Python code itself."
msgstr ""
"もし、初めて iOS アプリを Python で書くことを試みているなら、 `BeeWare "
"<https://beeware.org>`__ や `Kivy <https://kivy.org>`__ といったプロジェクト"
"は、よりわかりやすいユーザー体験を提供するでしょう。これらのプロジェクトは "
"iOS プロジェクトを実行することに関連する複雑なことを管理するので、あなたは "
"Python のコードに集中するだけで良くなります。"

#: ../../using/ios.rst:34
msgid "Python at runtime on iOS"
msgstr "iOS ランタイムでの Python"

#: ../../using/ios.rst:37
msgid "Platform identification"
msgstr "プラットフォームの識別"

#: ../../using/ios.rst:39
msgid ""
"When executing on iOS, ``sys.platform`` will report as ``ios``. This value "
"will be returned on an iPhone or iPad, regardless of whether the app is "
"running on the simulator or a physical device."
msgstr ""
"iOS 上で実行している場合、 ``sys.platform`` は ``ios`` となります。アプリがシ"
"ミュレーターで実行されているか、物理デバイスで実行されているかにかかわらず、 "
"iPhone または iPad ではこの値となります。"

#: ../../using/ios.rst:43
msgid ""
"Information about the specific runtime environment, including the iOS "
"version, device model, and whether the device is a simulator, can be "
"obtained using :func:`platform.ios_ver()`. :func:`platform.system()` will "
"report ``iOS`` or ``iPadOS``, depending on the device."
msgstr ""
"iOS バージョンやデバイスモデル、デバイスがシミュレーターかどうかを含む、特定"
"のランタイムプラットフォームについての情報は、 :func:`platform.ios_ver()` を"
"使用して取得できます。 :func:`platform.system()` は、デバイスによって "
"``iOS`` または ``iPadOS`` を返します。"

#: ../../using/ios.rst:48
msgid ""
":func:`os.uname()` reports kernel-level details; it will report a name of "
"``Darwin``."
msgstr ""
":func:`os.uname()` は、 ``Darwin`` の名前など、カーネルレベルの詳細を返しま"
"す。"

#: ../../using/ios.rst:52
msgid "Standard library availability"
msgstr "標準ライブラリの利用可能性"

#: ../../using/ios.rst:54
msgid ""
"The Python standard library has some notable omissions and restrictions on "
"iOS. See the :ref:`API availability guide for iOS <iOS-availability>` for "
"details."
msgstr ""
"Python 標準ライブラリには、 iOS 上ではいくつかの重要な欠落や制限が存在しま"
"す。詳細は、 :ref:`iOS 用 API 利用可能性ガイド <iOS-availability>` を参照して"
"ください。"

#: ../../using/ios.rst:59
msgid "Binary extension modules"
msgstr "バイナリ拡張モジュール"

#: ../../using/ios.rst:61
msgid ""
"One notable difference about iOS as a platform is that App Store "
"distribution imposes hard requirements on the packaging of an application. "
"One of these requirements governs how binary extension modules are "
"distributed."
msgstr ""
"プラットフォームとしての iOS についての重要な違いの一つは、 App Store での配"
"布がアプリケーションのパッケージングに厳しい条件を課すということです。 これら"
"の条件の一つは、バイナリ拡張モジュールの配布方法を規定します。"

#: ../../using/ios.rst:65
msgid ""
"The iOS App Store requires that *all* binary modules in an iOS app must be "
"dynamic libraries, contained in a framework with appropriate metadata, "
"stored in the ``Frameworks`` folder of the packaged app. There can be only a "
"single binary per framework, and there can be no executable binary material "
"outside the ``Frameworks`` folder."
msgstr ""
"iOS App Store では、 iOS アプリの全てのバイナリモジュールが、パッケージ化され"
"たアプリの ``Frameworks`` フォルダに保存された、適切なメタデータ付きのフレー"
"ムワークに含まれる動的ライブラリである必要があります。フレームワークごとにバ"
"イナリは一つだけで、 ``Frameworks`` フォルダの外に実行可能バイナリデータを設"
"置することはできません。"

#: ../../using/ios.rst:71
msgid ""
"This conflicts with the usual Python approach for distributing binaries, "
"which allows a binary extension module to be loaded from any location on "
"``sys.path``. To ensure compliance with App Store policies, an iOS project "
"must post-process any Python packages, converting ``.so`` binary modules "
"into individual standalone frameworks with appropriate metadata and signing. "
"For details on how to perform this post-processing, see the guide for :ref:"
"`adding Python to your project <adding-ios>`."
msgstr ""
"これは、バイナリ拡張モジュールが ``sys.path`` 上のどの場所からでも読み込み可"
"能な、通常の Python のバイナリ配布のアプローチと衝突します。 確実に App "
"Store ポリシーに従うために、 iOS プロジェクトはいずれの Python パッケージに"
"も、 ``.so`` バイナリモジュールを、個別の、スタンドアローンで、適切なメタデー"
"タと署名付きのフレームワークに変換する後処理を行わなければなりません。どのよ"
"うに後処理を行うかの詳細は、 :ref:`プロジェクトに Python を追加する <adding-"
"ios>` のガイドを参照してください。"

#: ../../using/ios.rst:79
msgid ""
"To help Python discover binaries in their new location, the original ``.so`` "
"file on ``sys.path`` is replaced with a ``.fwork`` file. This file is a text "
"file containing the location of the framework binary, relative to the app "
"bundle. To allow the framework to resolve back to the original location, the "
"framework must contain a ``.origin`` file that contains the location of the "
"``.fwork`` file, relative to the app bundle."
msgstr ""
"Python が新しい場所にあるバイナリを見つけることを助けるために、 ``sys.path`` "
"にある元の ``.so`` ファイルは ``.fwork`` ファイルに置き換えられます。 この"
"ファイルは、アプリバンドルからのレームワークバイナリの相対パスを含むテキスト"
"ファイルです。フレームワークが元の場所に解決できるようにするためには、フレー"
"ムワークは、アプリバンドルからの ``.fwork`` ファイルの相対パスが含まれた、 "
"``.origin`` ファイルを含む必要があります。"

#: ../../using/ios.rst:86
msgid ""
"For example, consider the case of an import ``from foo.bar import _whiz``, "
"where ``_whiz`` is implemented with the binary module ``sources/foo/bar/"
"_whiz.abi3.so``, with ``sources`` being the location registered on ``sys."
"path``, relative to the application bundle. This module *must* be "
"distributed as ``Frameworks/foo.bar._whiz.framework/foo.bar._whiz`` "
"(creating the framework name from the full import path of the module), with "
"an ``Info.plist`` file in the ``.framework`` directory identifying the "
"binary as a framework. The ``foo.bar._whiz`` module would be represented in "
"the original location with a ``sources/foo/bar/_whiz.abi3.fwork`` marker "
"file, containing the path ``Frameworks/foo.bar._whiz/foo.bar._whiz``. The "
"framework would also contain ``Frameworks/foo.bar._whiz.framework/foo.bar."
"_whiz.origin``, containing the path to the ``.fwork`` file."
msgstr ""
"例えば、``from foo.bar import _whiz`` をインポートする場合を考えてみましょ"
"う。 ``_whiz`` がバイナリモジュール ``sources/foo/bar/_whiz.abi3.so`` で実装"
"されており、 ``sources`` のアプリケーションバンドルからの相対パスが ``sys."
"path`` に登録されています。このモジュールは ``Frameworks/foo.bar._whiz."
"framework/foo.bar._whiz`` (フレームワーク名はモジュールの完全なインポートパス"
"から命名されています) として、バイナリをフレームワークとして識別する ``Info."
"plist`` ファイルを ``.framework`` ディレクトリ内に設置して配布しなければなり"
"ません。 ``foo.bar._whiz`` モジュールは、元の場所で、 ``Frameworks/foo.bar."
"_whiz/foo.bar._whiz`` のパスを含む ``sources/foo/bar/_whiz.abi3.fwork`` マー"
"カーファイルに記述されます。 また、フレームワークは、 ``.fwork`` へのパスを含"
"む ``Frameworks/foo.bar._whiz.framework/foo.bar._whiz.origin`` も含まなければ"
"なりません。"

#: ../../using/ios.rst:99
msgid ""
"When running on iOS, the Python interpreter will install an :class:"
"`~importlib.machinery.AppleFrameworkLoader` that is able to read and import "
"``.fwork`` files. Once imported, the ``__file__`` attribute of the binary "
"module will report as the location of the ``.fwork`` file. However, the :"
"class:`~importlib.machinery.ModuleSpec` for the loaded module will report "
"the ``origin`` as the location of the binary in the framework folder."
msgstr ""
"iOS 上で実行している場合、 Python インタープリターは ``.fwork`` ファイルを読"
"み込んでインポートすることができる :class:`~importlib.machinery."
"AppleFrameworkLoader` をインストールします。インポートされると、バイナリモ"
"ジュールの ``__file__`` 属性は ``.fwork`` ファイルの場所を返します。一方、読"
"み込まれたモジュールの :class:`~importlib.machinery.ModuleSpec` はフレーム"
"ワークフォルダのバイナリの場所として ``origin`` を返します。"

#: ../../using/ios.rst:107
msgid "Compiler stub binaries"
msgstr "コンパイラスタブバイナリ"

#: ../../using/ios.rst:109
msgid ""
"Xcode doesn't expose explicit compilers for iOS; instead, it uses an "
"``xcrun`` script that resolves to a full compiler path (e.g., ``xcrun --sdk "
"iphoneos clang`` to get the ``clang`` for an iPhone device). However, using "
"this script poses two problems:"
msgstr ""
"Xcode は、 iOS 用の明示的なコンパイラーを提供していません。代わりに、完全なコ"
"ンパイラーのパスを解決する ``xcrun`` スクリプトを使用します (たとえば "
"``xcrun --sdk iphoneos clang`` は iPhone デバイス用の ``clang`` を取得しま"
"す) 。しかし、これは2つの問題を引き起こします: "

#: ../../using/ios.rst:114
msgid ""
"The output of ``xcrun`` includes paths that are machine specific, resulting "
"in a sysconfig module that cannot be shared between users; and"
msgstr ""
"``xcrun`` の出力はマシン固有のパスを含み、ユーザー間で共有できない sysconfig "
"モジュールとなります。"

#: ../../using/ios.rst:117
msgid ""
"It results in ``CC``/``CPP``/``LD``/``AR`` definitions that include spaces. "
"There is a lot of C ecosystem tooling that assumes that you can split a "
"command line at the first space to get the path to the compiler executable; "
"this isn't the case when using ``xcrun``."
msgstr ""
"これにより、 ``CC``/``CPP``/``LD``/``AR`` 定義にスペースが含まれることになり"
"ます。多くの C エコシステムツールが、最初のスペースでコマンドラインを分割し、"
"コンパイラー実行ファイルを取得できることを前提としています。しかし、 "
"``xcrun`` を使用する場合はそうではありません。"

#: ../../using/ios.rst:122
msgid ""
"To avoid these problems, Python provided stubs for these tools. These stubs "
"are shell script wrappers around the underingly ``xcrun`` tools, distributed "
"in a ``bin`` folder distributed alongside the compiled iOS framework. These "
"scripts are relocatable, and will always resolve to the appropriate local "
"system paths. By including these scripts in the bin folder that accompanies "
"a framework, the contents of the ``sysconfig`` module becomes useful for end-"
"users to compile their own modules. When compiling third-party Python "
"modules for iOS, you should ensure these stub binaries are on your path."
msgstr ""
"これらの問題を避けるため、 Python はこれらのツール用のスタブを提供しました。"
"これらのスタブは、コンパイルされた iOS フレームワークとともに配布される "
"``bin`` フォルダで配布される、基礎の ``xcrun`` ツールのシェルスクリプトラッ"
"パーです。これらのスクリプトは再配置可能で、常に適切なローカルシステムパスに"
"解決されます。これらのスクリプトをフレームワークを伴う bin フォルダーに含める"
"ことで、 ``sysconfig`` モジュールはエンドユーザーが自身のモジュールをコンパイ"
"ルするのに有用になります。iOS 用の サードパーティの Python モジュールをコンパ"
"イルするときは、これらのスタブバイナリがパス上にあることを確認するべきです。"

#: ../../using/ios.rst:132
msgid "Installing Python on iOS"
msgstr "iOS での Python のインストール"

#: ../../using/ios.rst:135
msgid "Tools for building iOS apps"
msgstr "iOS アプリビルド用のツール"

#: ../../using/ios.rst:137
msgid ""
"Building for iOS requires the use of Apple's Xcode tooling. It is strongly "
"recommended that you use the most recent stable release of Xcode. This will "
"require the use of the most (or second-most) recently released macOS "
"version, as Apple does not maintain Xcode for older macOS versions. The "
"Xcode Command Line Tools are not sufficient for iOS development; you need a "
"*full* Xcode install."
msgstr ""
"iOS 向けのビルドには、 Apple の Xcode のツールを使用します。Xcode の最新の安"
"定リリースを使用することを強く推奨します。Apple は古い macOS のバージョン向け"
"には Xcode をメンテナンスしないため、これには最も (または二番目に) 最近にリ"
"リースされた macOS のバージョンが必要です。 Xcode コマンドラインツールは iOS "
"開発には不十分であり、完全な Xcode のインストールが必要です。"

#: ../../using/ios.rst:144
msgid ""
"If you want to run your code on the iOS simulator, you'll also need to "
"install an iOS Simulator Platform. You should be prompted to select an iOS "
"Simulator Platform when you first run Xcode. Alternatively, you can add an "
"iOS Simulator Platform by selecting from the Platforms tab of the Xcode "
"Settings panel."
msgstr ""
"iOS シミュレーター上でコードを実行したい場合は、 iOS シミュレータープラット"
"フォーム (iOS Simulator Platform) もインストールする必要があります。 Xcode を"
"初めて実行したとき、 iOS シミュレータープラットフォームを選択するプロンプトが"
"表示されるはずです。代わりに、 Xcode の Settings パネルの Platform タブから "
"iOS Simulator Platform を選択して追加することもできます。"

#: ../../using/ios.rst:152
msgid "Adding Python to an iOS project"
msgstr "iOS プロジェクトに Python を追加する"

#: ../../using/ios.rst:154
msgid ""
"Python can be added to any iOS project, using either Swift or Objective C. "
"The following examples will use Objective C; if you are using Swift, you may "
"find a library like `PythonKit <https://github.com/pvieito/PythonKit>`__ to "
"be helpful."
msgstr ""
"Python は、 Swift または Objective-C を使って、どの iOS プロジェクトにでも追"
"加できます。以下の例では、 Objective-C を使用しています。 Swift を使う場合"
"は、 `PythonKit <https://github.com/pvieito/PythonKit>`__ のようなライブラリ"
"が役に立つかもしれません。"

#: ../../using/ios.rst:159
msgid "To add Python to an iOS Xcode project:"
msgstr "Python を iOS Xcode プロジェクトに追加するには:"

#: ../../using/ios.rst:161
msgid ""
"Build or obtain a Python ``XCFramework``. See the instructions in :source:"
"`iOS/README.rst` (in the CPython source distribution) for details on how to "
"build a Python ``XCFramework``. At a minimum, you will need a build that "
"supports ``arm64-apple-ios``, plus one of either ``arm64-apple-ios-"
"simulator`` or ``x86_64-apple-ios-simulator``."
msgstr ""
"Python の ``XCFramework`` をビルドまたは取得します。 Python の "
"``XCFramework`` をビルドする方法の詳細は、 :source:`iOS/README.rst` (CPython "
"のソースコードにあります) の説明を参照してください。最低でも、 ``arm64-apple-"
"ios`` に加えて ``arm64-apple-ios-simulator`` または ``x86_64-apple-ios-"
"simulator`` のどちらかをサポートするビルドが必要です。"

#: ../../using/ios.rst:167
msgid ""
"Drag the ``XCframework`` into your iOS project. In the following "
"instructions, we'll assume you've dropped the ``XCframework`` into the root "
"of your project; however, you can use any other location that you want by "
"adjusting paths as needed."
msgstr ""
"``XCframework`` を iOS プロジェクトにドラッグします。以降の説明では、 プロ"
"ジェクトのルートに ``XCframework`` を設置したものと仮定しますが、パスを必要に"
"応じて調整することで、他の場所を使用することも出来ます。"

#: ../../using/ios.rst:172
msgid ""
"Drag the ``iOS/Resources/dylib-Info-template.plist`` file into your project, "
"and ensure it is associated with the app target."
msgstr ""
"``iOS/Resources/dylib-Info-template.plist`` ファイルをプロジェクトにドラッグ"
"し、それがアプリのターゲットに関連付けられていることを確認します。"

#: ../../using/ios.rst:175
msgid ""
"Add your application code as a folder in your Xcode project. In the "
"following instructions, we'll assume that your user code is in a folder "
"named ``app`` in the root of your project; you can use any other location by "
"adjusting paths as needed. Ensure that this folder is associated with your "
"app target."
msgstr ""
"アプリケーションのコードを、 Xcode プロジェクトにフォルダーとして追加します。"
"以降の説明では、 プロジェクトのルートに ``app`` という名前のユーザーコードが"
"入ったフォルダを設置したものと仮定しますが、パスを必要に応じて調整すること"
"で、他の場所を使用することも出来ます。フォルダがアプリのターゲットに関連付け"
"られていることを確認してください。"

#: ../../using/ios.rst:181
msgid ""
"Select the app target by selecting the root node of your Xcode project, then "
"the target name in the sidebar that appears."
msgstr ""
"Xcode プロジェクトのルートノードを選択することで、アプリのターゲットを選択し"
"てください。すると、ターゲット名がサイドバーに現れるはずです。"

#: ../../using/ios.rst:184
msgid ""
"In the \"General\" settings, under \"Frameworks, Libraries and Embedded "
"Content\", add ``Python.xcframework``, with \"Embed & Sign\" selected."
msgstr ""
"\"General\" の設定の \"Frameworks, Libraries and Embedded Content\" に、 "
"\"Embed & Sign\" を選択して ``Python.xcframework`` を追加してください。"

#: ../../using/ios.rst:187
msgid "In the \"Build Settings\" tab, modify the following:"
msgstr "\"Build Settings\" タブで、次の項目を修正してください:"

#: ../../using/ios.rst:189
msgid "Build Options"
msgstr "Build Options"

#: ../../using/ios.rst:191
msgid "User Script Sandboxing: No"
msgstr "User Script Sandboxing: No"

#: ../../using/ios.rst:192
msgid "Enable Testability: Yes"
msgstr "Enable Testability: Yes"

#: ../../using/ios.rst:194
msgid "Search Paths"
msgstr "Search Paths"

#: ../../using/ios.rst:196
msgid "Framework Search Paths: ``$(PROJECT_DIR)``"
msgstr "Framework Search Paths: ``$(PROJECT_DIR)``"

#: ../../using/ios.rst:197
msgid ""
"Header Search Paths: ``\"$(BUILT_PRODUCTS_DIR)/Python.framework/Headers\"``"
msgstr ""
"Header Search Paths: ``\"$(BUILT_PRODUCTS_DIR)/Python.framework/Headers\"``"

#: ../../using/ios.rst:199
msgid "Apple Clang - Warnings - All languages"
msgstr "Apple Clang - Warnings - All languages"

#: ../../using/ios.rst:201
msgid "Quoted Include In Framework Header: No"
msgstr "Quoted Include In Framework Header: No"

#: ../../using/ios.rst:203
msgid ""
"Add a build step that copies the Python standard library into your app. In "
"the \"Build Phases\" tab, add a new \"Run Script\" build step *before* the "
"\"Embed Frameworks\" step, but *after* the \"Copy Bundle Resources\" step. "
"Name the step \"Install Target Specific Python Standard Library\", disable "
"the \"Based on dependency analysis\" checkbox, and set the script content to:"
msgstr ""
"Python の標準ライブラリをアプリにコピーするビルドステップを追加します。 "
"\"Build Phases\" タブで、新しい \"Run Script\" ビルドステップを、 \"Embed "
"Frameworks\" ステップの前に追加してください。ステップの名前は、 \"Install "
"Target Specific Python Standard Library\" にして、 \"Based on dependency "
"analysis\" のチェックボックスを外し、スクリプトの内容を次のように設定してくだ"
"さい:"

#: ../../using/ios.rst:222
msgid ""
"Note that the name of the simulator \"slice\" in the XCframework may be "
"different, depending the CPU architectures your ``XCFramework`` supports."
msgstr ""
"XCframework のシミュレーター \"slice\" の名前は、 ``XCFramework`` がサポート"
"する CPU アーキテクチャによって異なる可能性があることに注意してください。 "

#: ../../using/ios.rst:225
msgid ""
"Add a second build step that processes the binary extension modules in the "
"standard library into \"Framework\" format. Add a \"Run Script\" build step "
"*directly after* the one you added in step 8, named \"Prepare Python Binary "
"Modules\". It should also have \"Based on dependency analysis\" unchecked, "
"with the following script content:"
msgstr ""
"標準ライブラリのバイナリ拡張モジュールをフレームワーク形式に処理する、二つ目"
"のビルドステップを追加します。手順 8 で追加したものの直後に、  \"Prepare "
"Python Binary Modules\" という名前の \"Run Script\" ビルドステップを追加して"
"ください。 \"Based on dependency analysis\" のチェックを外して、以下のスクリ"
"プトの内容も追加する必要もあります。"

#: ../../using/ios.rst:281
msgid ""
"Add Objective C code to initialize and use a Python interpreter in embedded "
"mode. You should ensure that:"
msgstr ""
"Python インタープリターを埋め込みモードで初期化・使用する Objective C コード"
"を追加します。次のことを確認する必要があります:"

#: ../../using/ios.rst:284
msgid ":c:member:`UTF-8 mode <PyPreConfig.utf8_mode>` is *enabled*;"
msgstr ":c:member:`UTF-8 mode <PyPreConfig.utf8_mode>` が有効になっていること"

#: ../../using/ios.rst:285
msgid ":c:member:`Buffered stdio <PyConfig.buffered_stdio>` is *disabled*;"
msgstr ""
":c:member:`Buffered stdio <PyConfig.buffered_stdio>` が無効になっていること"

#: ../../using/ios.rst:286
msgid ":c:member:`Writing bytecode <PyConfig.write_bytecode>` is *disabled*;"
msgstr ""
":c:member:`Writing bytecode <PyConfig.write_bytecode>` が無効になっていること"

#: ../../using/ios.rst:287
msgid ""
":c:member:`Signal handlers <PyConfig.install_signal_handlers>` are *enabled*;"
msgstr ""
":c:member:`Signal handlers <PyConfig.install_signal_handlers>` が有効になって"
"いること"

#: ../../using/ios.rst:288
msgid ""
"``PYTHONHOME`` for the interpreter is configured to point at the ``python`` "
"subfolder of your app's bundle; and"
msgstr ""
"インタープリターの ``PYTHONHOME`` がアプリのバンドルの ``python`` サブフォル"
"ダに設定されていること"

#: ../../using/ios.rst:290
msgid "The ``PYTHONPATH`` for the interpreter includes:"
msgstr "インタープリターの ``PYTHONPATH`` が次の項目を含むこと:"

#: ../../using/ios.rst:292
msgid "the ``python/lib/python3.X`` subfolder of your app's bundle,"
msgstr "アプリのバンドルの ``python/lib/python3.X`` サブフォルダ"

#: ../../using/ios.rst:293
msgid ""
"the ``python/lib/python3.X/lib-dynload`` subfolder of your app's bundle, and"
msgstr "アプリのバンドルの ``python/lib/python3.X/lib-dynload`` サブフォルダ"

#: ../../using/ios.rst:294
msgid "the ``app`` subfolder of your app's bundle"
msgstr "アプリのバンドルの ``app`` サブフォルダ"

#: ../../using/ios.rst:296
msgid ""
"Your app's bundle location can be determined using ``[[NSBundle mainBundle] "
"resourcePath]``."
msgstr ""
"アプリのバンドルの場所は ``[[NSBundle mainBundle] resourcePath]`` を用いて取"
"得できます。"

#: ../../using/ios.rst:299
msgid ""
"Steps 8, 9 and 10 of these instructions assume that you have a single folder "
"of pure Python application code, named ``app``. If you have third-party "
"binary modules in your app, some additional steps will be required:"
msgstr ""
"これらの手順 8, 9, 10 は ``app`` という名前のただ一つの純粋な Python アプリ"
"ケーションのコードのフォルダがあることを前提としています。もしサードパーティ"
"のバイナリモジュールがアプリに含まれる場合は、いくつかの追加の手順が必要です:"

#: ../../using/ios.rst:303
msgid ""
"You need to ensure that any folders containing third-party binaries are "
"either associated with the app target, or copied in as part of step 8. Step "
"8 should also purge any binaries that are not appropriate for the platform a "
"specific build is targeting (i.e., delete any device binaries if you're "
"building an app targeting the simulator)."
msgstr ""
"サードパーティのバイナリを含むフォルダが、アプリのターゲットに関連付けられて"
"いる、または手順 8 の一部としてコピーされていることを確認する必要があります。"
"手順 8 では、特定のビルドがターゲットとするプラットフォームに適切でないバイナ"
"リを取り除く(つまり、もしシミュレーターをターゲットとするアプリをビルドしてい"
"る場合は、デバイスバイナリを削除する)ことも必要です。"

#: ../../using/ios.rst:309
msgid ""
"Any folders that contain third-party binaries must be processed into "
"framework form by step 9. The invocation of ``install_dylib`` that processes "
"the ``lib-dynload`` folder can be copied and adapted for this purpose."
msgstr ""
"サードパーティのバイナリを含むフォルダは、手順 9 でフレームワークに処理されな"
"ければなりません。 ``lib-dynload`` フォルダを処理する ``install_dylib`` の呼"
"び出しは、このためにコピー・変更することができます。"

#: ../../using/ios.rst:313
msgid ""
"If you're using a separate folder for third-party packages, ensure that "
"folder is included as part of the ``PYTHONPATH`` configuration in step 10."
msgstr ""
"サードパーティパッケージのフォルダを分離している場合は、手順 10 でそのフォル"
"ダが ``PYTHONPATH`` 環境設定の一部に含まれていることを確認してください。"
