# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2024, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.12\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-05-10 22:50-0300\n"
"PO-Revision-Date: 2021-06-28 00:54+0000\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: pt_PT\n"
"Language-Team: Portuguese (Portugal) (https://app.transifex.com/python-"
"doc/teams/5390/pt_PT/)\n"
"Plural-Forms: nplurals=3; plural=(n == 0 || n == 1) ? 0 : n != 0 && n % "
"1000000 == 0 ? 1 : 2;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../../library/ast.rst:2
msgid ":mod:`!ast` --- Abstract Syntax Trees"
msgstr ""

#: ../../library/ast.rst:14
msgid "**Source code:** :source:`Lib/ast.py`"
msgstr ""

#: ../../library/ast.rst:18
msgid ""
"The :mod:`ast` module helps Python applications to process trees of the "
"Python abstract syntax grammar.  The abstract syntax itself might change "
"with each Python release; this module helps to find out programmatically "
"what the current grammar looks like."
msgstr ""

#: ../../library/ast.rst:23
msgid ""
"An abstract syntax tree can be generated by passing "
":data:`ast.PyCF_ONLY_AST` as a flag to the :func:`compile` built-in "
"function, or using the :func:`parse` helper provided in this module.  The"
" result will be a tree of objects whose classes all inherit from "
":class:`ast.AST`.  An abstract syntax tree can be compiled into a Python "
"code object using the built-in :func:`compile` function."
msgstr ""

#: ../../library/ast.rst:33
msgid "Abstract Grammar"
msgstr ""

#: ../../library/ast.rst:35
msgid "The abstract grammar is currently defined as follows:"
msgstr ""

#: ../../library/ast.rst:42
msgid "Node classes"
msgstr ""

#: ../../library/ast.rst:46
msgid ""
"This is the base of all AST node classes.  The actual node classes are "
"derived from the :file:`Parser/Python.asdl` file, which is reproduced "
":ref:`above <abstract-grammar>`.  They are defined in the :mod:`!_ast` C "
"module and re-exported in :mod:`ast`."
msgstr ""

#: ../../library/ast.rst:51
msgid ""
"There is one class defined for each left-hand side symbol in the abstract"
" grammar (for example, :class:`ast.stmt` or :class:`ast.expr`).  In "
"addition, there is one class defined for each constructor on the right-"
"hand side; these classes inherit from the classes for the left-hand side "
"trees.  For example, :class:`ast.BinOp` inherits from :class:`ast.expr`."
"  For production rules with alternatives (aka \"sums\"), the left-hand "
"side class is abstract: only instances of specific constructor nodes are "
"ever created."
msgstr ""

#: ../../library/ast.rst:64
msgid ""
"Each concrete class has an attribute :attr:`!_fields` which gives the "
"names of all child nodes."
msgstr ""

#: ../../library/ast.rst:67
msgid ""
"Each instance of a concrete class has one attribute for each child node, "
"of the type as defined in the grammar.  For example, :class:`ast.BinOp` "
"instances have an attribute :attr:`left` of type :class:`ast.expr`."
msgstr ""

#: ../../library/ast.rst:71
msgid ""
"If these attributes are marked as optional in the grammar (using a "
"question mark), the value might be ``None``.  If the attributes can have "
"zero-or-more values (marked with an asterisk), the values are represented"
" as Python lists.  All possible attributes must be present and have valid"
" values when compiling an AST with :func:`compile`."
msgstr ""

#: ../../library/ast.rst:79
msgid ""
"The :attr:`!_field_types` attribute on each concrete class is a "
"dictionary mapping field names (as also listed in :attr:`_fields`) to "
"their types."
msgstr ""

#: ../../library/ast.rst:94
msgid ""
"Instances of :class:`ast.expr` and :class:`ast.stmt` subclasses have "
":attr:`lineno`, :attr:`col_offset`, :attr:`end_lineno`, and "
":attr:`end_col_offset` attributes.  The :attr:`lineno` and "
":attr:`end_lineno` are the first and last line numbers of source text "
"span (1-indexed so the first line is line 1) and the :attr:`col_offset` "
"and :attr:`end_col_offset` are the corresponding UTF-8 byte offsets of "
"the first and last tokens that generated the node. The UTF-8 offset is "
"recorded because the parser uses UTF-8 internally."
msgstr ""

#: ../../library/ast.rst:103
msgid ""
"Note that the end positions are not required by the compiler and are "
"therefore optional. The end offset is *after* the last symbol, for "
"example one can get the source segment of a one-line expression node "
"using ``source_line[node.col_offset : node.end_col_offset]``."
msgstr ""

#: ../../library/ast.rst:108
msgid "The constructor of a class :class:`ast.T` parses its arguments as follows:"
msgstr ""

#: ../../library/ast.rst:110
msgid ""
"If there are positional arguments, there must be as many as there are "
"items in :attr:`T._fields`; they will be assigned as attributes of these "
"names."
msgstr ""

#: ../../library/ast.rst:112
msgid ""
"If there are keyword arguments, they will set the attributes of the same "
"names to the given values."
msgstr ""

#: ../../library/ast.rst:115
msgid ""
"For example, to create and populate an :class:`ast.UnaryOp` node, you "
"could use ::"
msgstr ""

#: ../../library/ast.rst:121
msgid ""
"If a field that is optional in the grammar is omitted from the "
"constructor, it defaults to ``None``. If a list field is omitted, it "
"defaults to the empty list. If a field of type :class:`!ast.expr_context`"
" is omitted, it defaults to :class:`Load() <ast.Load>`. If any other "
"field is omitted, a :exc:`DeprecationWarning` is raised and the AST node "
"will not have this field. In Python 3.15, this condition will raise an "
"error."
msgstr ""

#: ../../library/ast.rst:130
msgid "Class :class:`ast.Constant` is now used for all constants."
msgstr ""

#: ../../library/ast.rst:134
msgid ""
"Simple indices are represented by their value, extended slices are "
"represented as tuples."
msgstr ""

#: ../../library/ast.rst:139
msgid ""
"Old classes :class:`!ast.Num`, :class:`!ast.Str`, :class:`!ast.Bytes`, "
":class:`!ast.NameConstant` and :class:`!ast.Ellipsis` are still "
"available, but they will be removed in future Python releases.  In the "
"meantime, instantiating them will return an instance of a different "
"class."
msgstr ""

#: ../../library/ast.rst:146
msgid ""
"Old classes :class:`!ast.Index` and :class:`!ast.ExtSlice` are still "
"available, but they will be removed in future Python releases. In the "
"meantime, instantiating them will return an instance of a different "
"class."
msgstr ""

#: ../../library/ast.rst:153
msgid ""
"Previous versions of Python allowed the creation of AST nodes that were "
"missing required fields. Similarly, AST node constructors allowed "
"arbitrary keyword arguments that were set as attributes of the AST node, "
"even if they did not match any of the fields of the AST node. This "
"behavior is deprecated and will be removed in Python 3.15."
msgstr ""

#: ../../library/ast.rst:160
msgid ""
"The descriptions of the specific node classes displayed here were "
"initially adapted from the fantastic `Green Tree Snakes "
"<https://greentreesnakes.readthedocs.io/en/latest/>`__ project and all "
"its contributors."
msgstr ""

#: ../../library/ast.rst:169
msgid "Root nodes"
msgstr ""

#: ../../library/ast.rst:173
msgid ""
"A Python module, as with :ref:`file input <file-input>`. Node type "
"generated by :func:`ast.parse` in the default ``\"exec\"`` *mode*."
msgstr ""

#: ../../library/ast.rst:176
msgid "*body* is a :class:`list` of the module's :ref:`ast-statements`."
msgstr ""

#: ../../library/ast.rst:178
msgid ""
"*type_ignores* is a :class:`list` of the module's type ignore comments; "
"see :func:`ast.parse` for more details."
msgstr ""

#: ../../library/ast.rst:194
msgid ""
"A single Python :ref:`expression input <expression-input>`. Node type "
"generated by :func:`ast.parse` when *mode* is ``\"eval\"``."
msgstr ""

#: ../../library/ast.rst:197
msgid ""
"*body* is a single node, one of the :ref:`expression types <ast-"
"expressions>`."
msgstr ""

#: ../../library/ast.rst:209
msgid ""
"A single :ref:`interactive input <interactive>`, like in :ref:`tut-"
"interac`. Node type generated by :func:`ast.parse` when *mode* is "
"``\"single\"``."
msgstr ""

#: ../../library/ast.rst:212
msgid "*body* is a :class:`list` of :ref:`statement nodes <ast-statements>`."
msgstr ""

#: ../../library/ast.rst:231
msgid ""
"A representation of an old-style type comments for functions, as Python "
"versions prior to 3.5 didn't support :pep:`484` annotations. Node type "
"generated by :func:`ast.parse` when *mode* is ``\"func_type\"``."
msgstr ""

#: ../../library/ast.rst:235
msgid "Such type comments would look like this::"
msgstr ""

#: ../../library/ast.rst:241
msgid ""
"*argtypes* is a :class:`list` of :ref:`expression nodes <ast-"
"expressions>`."
msgstr ""

#: ../../library/ast.rst:243
msgid "*returns* is a single :ref:`expression node <ast-expressions>`."
msgstr ""

#: ../../library/ast.rst:261
msgid "Literals"
msgstr ""

#: ../../library/ast.rst:265
msgid ""
"A constant value. The ``value`` attribute of the ``Constant`` literal "
"contains the Python object it represents. The values represented can be "
"simple types such as a number, string or ``None``, but also immutable "
"container types (tuples and frozensets) if all of their elements are "
"constant."
msgstr ""

#: ../../library/ast.rst:279
msgid ""
"Node representing a single formatting field in an f-string. If the string"
" contains a single formatting field and nothing else the node can be "
"isolated otherwise it appears in :class:`JoinedStr`."
msgstr ""

#: ../../library/ast.rst:283
msgid ""
"``value`` is any expression node (such as a literal, a variable, or a "
"function call)."
msgstr ""

#: ../../library/ast.rst:285
msgid "``conversion`` is an integer:"
msgstr ""

#: ../../library/ast.rst:287
msgid "-1: no formatting"
msgstr ""

#: ../../library/ast.rst:288
msgid "115: ``!s`` string formatting"
msgstr ""

#: ../../library/ast.rst:289
msgid "114: ``!r`` repr formatting"
msgstr ""

#: ../../library/ast.rst:290
msgid "97: ``!a`` ascii formatting"
msgstr ""

#: ../../library/ast.rst:292
msgid ""
"``format_spec`` is a :class:`JoinedStr` node representing the formatting "
"of the value, or ``None`` if no format was specified. Both ``conversion``"
" and ``format_spec`` can be set at the same time."
msgstr ""

#: ../../library/ast.rst:299
msgid ""
"An f-string, comprising a series of :class:`FormattedValue` and "
":class:`Constant` nodes."
msgstr ""

#: ../../library/ast.rst:327
msgid ""
"A list or tuple. ``elts`` holds a list of nodes representing the "
"elements. ``ctx`` is :class:`Store` if the container is an assignment "
"target (i.e. ``(x,y)=something``), and :class:`Load` otherwise."
msgstr ""

#: ../../library/ast.rst:353
msgid "A set. ``elts`` holds a list of nodes representing the set's elements."
msgstr ""

#: ../../library/ast.rst:368
msgid ""
"A dictionary. ``keys`` and ``values`` hold lists of nodes representing "
"the keys and the values respectively, in matching order (what would be "
"returned when calling :code:`dictionary.keys()` and "
":code:`dictionary.values()`)."
msgstr ""

#: ../../library/ast.rst:372
msgid ""
"When doing dictionary unpacking using dictionary literals the expression "
"to be expanded goes in the ``values`` list, with a ``None`` at the "
"corresponding position in ``keys``."
msgstr ""

#: ../../library/ast.rst:390
msgid "Variables"
msgstr ""

#: ../../library/ast.rst:394
msgid ""
"A variable name. ``id`` holds the name as a string, and ``ctx`` is one of"
" the following types."
msgstr ""

#: ../../library/ast.rst:402
msgid ""
"Variable references can be used to load the value of a variable, to "
"assign a new value to it, or to delete it. Variable references are given "
"a context to distinguish these cases."
msgstr ""

#: ../../library/ast.rst:432
msgid ""
"A ``*var`` variable reference. ``value`` holds the variable, typically a "
":class:`Name` node. This type must be used when building a :class:`Call` "
"node with ``*args``."
msgstr ""

#: ../../library/ast.rst:456
msgid "Expressions"
msgstr ""

#: ../../library/ast.rst:460
msgid ""
"When an expression, such as a function call, appears as a statement by "
"itself with its return value not used or stored, it is wrapped in this "
"container. ``value`` holds one of the other nodes in this section, a "
":class:`Constant`, a :class:`Name`, a :class:`Lambda`, a :class:`Yield` "
"or :class:`YieldFrom` node."
msgstr ""

#: ../../library/ast.rst:478
msgid ""
"A unary operation. ``op`` is the operator, and ``operand`` any expression"
" node."
msgstr ""

#: ../../library/ast.rst:487
msgid ""
"Unary operator tokens. :class:`Not` is the ``not`` keyword, "
":class:`Invert` is the ``~`` operator."
msgstr ""

#: ../../library/ast.rst:501
msgid ""
"A binary operation (like addition or division). ``op`` is the operator, "
"and ``left`` and ``right`` are any expression nodes."
msgstr ""

#: ../../library/ast.rst:528
msgid "Binary operator tokens."
msgstr ""

#: ../../library/ast.rst:533
msgid ""
"A boolean operation, 'or' or 'and'. ``op`` is :class:`Or` or "
":class:`And`. ``values`` are the values involved. Consecutive operations "
"with the same operator, such as ``a or b or c``, are collapsed into one "
"node with several values."
msgstr ""

#: ../../library/ast.rst:538
msgid "This doesn't include ``not``, which is a :class:`UnaryOp`."
msgstr ""

#: ../../library/ast.rst:554
msgid "Boolean operator tokens."
msgstr ""

#: ../../library/ast.rst:559
msgid ""
"A comparison of two or more values. ``left`` is the first value in the "
"comparison, ``ops`` the list of operators, and ``comparators`` the list "
"of values after the first element in the comparison."
msgstr ""

#: ../../library/ast.rst:588
msgid "Comparison operator tokens."
msgstr ""

#: ../../library/ast.rst:593
msgid ""
"A function call. ``func`` is the function, which will often be a "
":class:`Name` or :class:`Attribute` object. Of the arguments:"
msgstr ""

#: ../../library/ast.rst:596
msgid "``args`` holds a list of the arguments passed by position."
msgstr ""

#: ../../library/ast.rst:597
msgid ""
"``keywords`` holds a list of :class:`.keyword` objects representing "
"arguments passed by keyword."
msgstr ""

#: ../../library/ast.rst:600
msgid ""
"The ``args`` and ``keywords`` arguments are optional and default to empty"
" lists."
msgstr ""

#: ../../library/ast.rst:623
msgid ""
"A keyword argument to a function call or class definition. ``arg`` is a "
"raw string of the parameter name, ``value`` is a node to pass in."
msgstr ""

#: ../../library/ast.rst:629
msgid ""
"An expression such as ``a if b else c``. Each field holds a single node, "
"so in the following example, all three are :class:`Name` nodes."
msgstr ""

#: ../../library/ast.rst:644
msgid ""
"Attribute access, e.g. ``d.keys``. ``value`` is a node, typically a "
":class:`Name`. ``attr`` is a bare string giving the name of the "
"attribute, and ``ctx`` is :class:`Load`, :class:`Store` or :class:`Del` "
"according to how the attribute is acted on."
msgstr ""

#: ../../library/ast.rst:661
msgid ""
"A named expression. This AST node is produced by the assignment "
"expressions operator (also known as the walrus operator). As opposed to "
"the :class:`Assign` node in which the first argument can be multiple "
"nodes, in this case both ``target`` and ``value`` must be single nodes."
msgstr ""

#: ../../library/ast.rst:677
msgid "Subscripting"
msgstr ""

#: ../../library/ast.rst:681
msgid ""
"A subscript, such as ``l[1]``. ``value`` is the subscripted object "
"(usually sequence or mapping). ``slice`` is an index, slice or key. It "
"can be a :class:`Tuple` and contain a :class:`Slice`. ``ctx`` is "
":class:`Load`, :class:`Store` or :class:`Del` according to the action "
"performed with the subscript."
msgstr ""

#: ../../library/ast.rst:705
msgid ""
"Regular slicing (on the form ``lower:upper`` or ``lower:upper:step``). "
"Can occur only inside the *slice* field of :class:`Subscript`, either "
"directly or as an element of :class:`Tuple`."
msgstr ""

#: ../../library/ast.rst:722
msgid "Comprehensions"
msgstr ""

#: ../../library/ast.rst:729
msgid ""
"List and set comprehensions, generator expressions, and dictionary "
"comprehensions. ``elt`` (or ``key`` and ``value``) is a single node "
"representing the part that will be evaluated for each item."
msgstr ""

#: ../../library/ast.rst:733
msgid "``generators`` is a list of :class:`comprehension` nodes."
msgstr ""

#: ../../library/ast.rst:781
msgid ""
"One ``for`` clause in a comprehension. ``target`` is the reference to use"
" for each element - typically a :class:`Name` or :class:`Tuple` node. "
"``iter`` is the object to iterate over. ``ifs`` is a list of test "
"expressions: each ``for`` clause can have multiple ``ifs``."
msgstr ""

#: ../../library/ast.rst:786
msgid ""
"``is_async`` indicates a comprehension is asynchronous (using an ``async "
"for`` instead of ``for``). The value is an integer (0 or 1)."
msgstr ""

#: ../../library/ast.rst:851
msgid "Statements"
msgstr ""

#: ../../library/ast.rst:855
msgid ""
"An assignment. ``targets`` is a list of nodes, and ``value`` is a single "
"node."
msgstr ""

#: ../../library/ast.rst:857
msgid ""
"Multiple nodes in ``targets`` represents assigning the same value to "
"each. Unpacking is represented by putting a :class:`Tuple` or "
":class:`List` within ``targets``."
msgstr ""

#: ../../library/ast.rst:863 ../../library/ast.rst:1154
#: ../../library/ast.rst:1348 ../../library/ast.rst:1877
msgid ""
"``type_comment`` is an optional string with the type annotation as a "
"comment."
msgstr ""

#: ../../library/ast.rst:891
msgid ""
"An assignment with a type annotation. ``target`` is a single node and can"
" be a :class:`Name`, a :class:`Attribute` or a :class:`Subscript`. "
"``annotation`` is the annotation, such as a :class:`Constant` or "
":class:`Name` node. ``value`` is a single optional node. ``simple`` is a "
"boolean integer set to True for a :class:`Name` node in ``target`` that "
"do not appear in between parenthesis and are hence pure names and not "
"expressions."
msgstr ""

#: ../../library/ast.rst:942
msgid ""
"Augmented assignment, such as ``a += 1``. In the following example, "
"``target`` is a :class:`Name` node for ``x`` (with the :class:`Store` "
"context), ``op`` is :class:`Add`, and ``value`` is a :class:`Constant` "
"with value for 1."
msgstr ""

#: ../../library/ast.rst:947
msgid ""
"The ``target`` attribute cannot be of class :class:`Tuple` or "
":class:`List`, unlike the targets of :class:`Assign`."
msgstr ""

#: ../../library/ast.rst:963
msgid ""
"A ``raise`` statement. ``exc`` is the exception object to be raised, "
"normally a :class:`Call` or :class:`Name`, or ``None`` for a standalone "
"``raise``. ``cause`` is the optional part for ``y`` in ``raise x from "
"y``."
msgstr ""

#: ../../library/ast.rst:979
msgid ""
"An assertion. ``test`` holds the condition, such as a :class:`Compare` "
"node. ``msg`` holds the failure message."
msgstr ""

#: ../../library/ast.rst:994
msgid ""
"Represents a ``del`` statement. ``targets`` is a list of nodes, such as "
":class:`Name`, :class:`Attribute` or :class:`Subscript` nodes."
msgstr ""

#: ../../library/ast.rst:1011
msgid "A ``pass`` statement."
msgstr ""

#: ../../library/ast.rst:1023
msgid ""
"A :ref:`type alias <type-aliases>` created through the :keyword:`type` "
"statement. ``name`` is the name of the alias, ``type_params`` is a list "
"of :ref:`type parameters <ast-type-params>`, and ``value`` is the value "
"of the type alias."
msgstr ""

#: ../../library/ast.rst:1039
msgid ""
"Other statements which are only applicable inside functions or loops are "
"described in other sections."
msgstr ""

#: ../../library/ast.rst:1043
msgid "Imports"
msgstr ""

#: ../../library/ast.rst:1047
msgid "An import statement. ``names`` is a list of :class:`alias` nodes."
msgstr ""

#: ../../library/ast.rst:1063
msgid ""
"Represents ``from x import y``. ``module`` is a raw string of the 'from' "
"name, without any leading dots, or ``None`` for statements such as ``from"
" . import foo``. ``level`` is an integer holding the level of the "
"relative import (0 means absolute import)."
msgstr ""

#: ../../library/ast.rst:1084
msgid ""
"Both parameters are raw strings of the names. ``asname`` can be ``None`` "
"if the regular name is to be used."
msgstr ""

#: ../../library/ast.rst:1100
msgid "Control flow"
msgstr ""

#: ../../library/ast.rst:1103
msgid ""
"Optional clauses such as ``else`` are stored as an empty list if they're "
"not present."
msgstr ""

#: ../../library/ast.rst:1108
msgid ""
"An ``if`` statement. ``test`` holds a single node, such as a "
":class:`Compare` node. ``body`` and ``orelse`` each hold a list of nodes."
msgstr ""

#: ../../library/ast.rst:1111
msgid ""
"``elif`` clauses don't have a special representation in the AST, but "
"rather appear as extra :class:`If` nodes within the ``orelse`` section of"
" the previous one."
msgstr ""

#: ../../library/ast.rst:1145
msgid ""
"A ``for`` loop. ``target`` holds the variable(s) the loop assigns to, as "
"a single :class:`Name`, :class:`Tuple`, :class:`List`, :class:`Attribute`"
" or :class:`Subscript` node. ``iter`` holds the item to be looped over, "
"again as a single node. ``body`` and ``orelse`` contain lists of nodes to"
" execute. Those in ``orelse`` are executed if the loop finishes normally,"
" rather than via a ``break`` statement."
msgstr ""

#: ../../library/ast.rst:1179
msgid ""
"A ``while`` loop. ``test`` holds the condition, such as a "
":class:`Compare` node."
msgstr ""

#: ../../library/ast.rst:1205
msgid "The ``break`` and ``continue`` statements."
msgstr ""

#: ../../library/ast.rst:1238
msgid ""
"``try`` blocks. All attributes are list of nodes to execute, except for "
"``handlers``, which is a list of :class:`ExceptHandler` nodes."
msgstr ""

#: ../../library/ast.rst:1283
msgid ""
"``try`` blocks which are followed by ``except*`` clauses. The attributes "
"are the same as for :class:`Try` but the :class:`ExceptHandler` nodes in "
"``handlers`` are interpreted as ``except*`` blocks rather then "
"``except``."
msgstr ""

#: ../../library/ast.rst:1312
msgid ""
"A single ``except`` clause. ``type`` is the exception type it will match,"
" typically a :class:`Name` node (or ``None`` for a catch-all ``except:`` "
"clause). ``name`` is a raw string for the name to hold the exception, or "
"``None`` if the clause doesn't have ``as foo``. ``body`` is a list of "
"nodes."
msgstr ""

#: ../../library/ast.rst:1343
msgid ""
"A ``with`` block. ``items`` is a list of :class:`withitem` nodes "
"representing the context managers, and ``body`` is the indented block "
"inside the context."
msgstr ""

#: ../../library/ast.rst:1353
msgid ""
"A single context manager in a ``with`` block. ``context_expr`` is the "
"context manager, often a :class:`Call` node. ``optional_vars`` is a "
":class:`Name`, :class:`Tuple` or :class:`List` for the ``as foo`` part, "
"or ``None`` if that isn't used."
msgstr ""

#: ../../library/ast.rst:1384
msgid "Pattern matching"
msgstr ""

#: ../../library/ast.rst:1389
msgid ""
"A ``match`` statement. ``subject`` holds the subject of the match (the "
"object that is being matched against the cases) and ``cases`` contains an"
" iterable of :class:`match_case` nodes with the different cases."
msgstr ""

#: ../../library/ast.rst:1397
msgid ""
"A single case pattern in a ``match`` statement. ``pattern`` contains the "
"match pattern that the subject will be matched against. Note that the "
":class:`AST` nodes produced for patterns differ from those produced for "
"expressions, even when they share the same syntax."
msgstr ""

#: ../../library/ast.rst:1402
msgid ""
"The ``guard`` attribute contains an expression that will be evaluated if "
"the pattern matches the subject."
msgstr ""

#: ../../library/ast.rst:1405
msgid ""
"``body`` contains a list of nodes to execute if the pattern matches and "
"the result of evaluating the guard expression is true."
msgstr ""

#: ../../library/ast.rst:1446
msgid ""
"A match literal or value pattern that compares by equality. ``value`` is "
"an expression node. Permitted value nodes are restricted as described in "
"the match statement documentation. This pattern succeeds if the match "
"subject is equal to the evaluated value."
msgstr ""

#: ../../library/ast.rst:1474
msgid ""
"A match literal pattern that compares by identity. ``value`` is the "
"singleton to be compared against: ``None``, ``True``, or ``False``. This "
"pattern succeeds if the match subject is the given constant."
msgstr ""

#: ../../library/ast.rst:1500
msgid ""
"A match sequence pattern. ``patterns`` contains the patterns to be "
"matched against the subject elements if the subject is a sequence. "
"Matches a variable length sequence if one of the subpatterns is a "
"``MatchStar`` node, otherwise matches a fixed length sequence."
msgstr ""

#: ../../library/ast.rst:1532
msgid ""
"Matches the rest of the sequence in a variable length match sequence "
"pattern. If ``name`` is not ``None``, a list containing the remaining "
"sequence elements is bound to that name if the overall sequence pattern "
"is successful."
msgstr ""

#: ../../library/ast.rst:1573
msgid ""
"A match mapping pattern. ``keys`` is a sequence of expression nodes. "
"``patterns`` is a corresponding sequence of pattern nodes. ``rest`` is an"
" optional name that can be specified to capture the remaining mapping "
"elements. Permitted key expressions are restricted as described in the "
"match statement documentation."
msgstr ""

#: ../../library/ast.rst:1579
msgid ""
"This pattern succeeds if the subject is a mapping, all evaluated key "
"expressions are present in the mapping, and the value corresponding to "
"each key matches the corresponding subpattern. If ``rest`` is not "
"``None``, a dict containing the remaining mapping elements is bound to "
"that name if the overall mapping pattern is successful."
msgstr ""

#: ../../library/ast.rst:1620
msgid ""
"A match class pattern. ``cls`` is an expression giving the nominal class "
"to be matched. ``patterns`` is a sequence of pattern nodes to be matched "
"against the class defined sequence of pattern matching attributes. "
"``kwd_attrs`` is a sequence of additional attributes to be matched "
"(specified as keyword arguments in the class pattern), ``kwd_patterns`` "
"are the corresponding patterns (specified as keyword values in the class "
"pattern)."
msgstr ""

#: ../../library/ast.rst:1627
msgid ""
"This pattern succeeds if the subject is an instance of the nominated "
"class, all positional patterns match the corresponding class-defined "
"attributes, and any specified keyword attributes match their "
"corresponding pattern."
msgstr ""

#: ../../library/ast.rst:1631
msgid ""
"Note: classes may define a property that returns self in order to match a"
" pattern node against the instance being matched. Several builtin types "
"are also matched that way, as described in the match statement "
"documentation."
msgstr ""

#: ../../library/ast.rst:1682
msgid ""
"A match \"as-pattern\", capture pattern or wildcard pattern. ``pattern`` "
"contains the match pattern that the subject will be matched against. If "
"the pattern is ``None``, the node represents a capture pattern (i.e a "
"bare name) and will always succeed."
msgstr ""

#: ../../library/ast.rst:1687
msgid ""
"The ``name`` attribute contains the name that will be bound if the "
"pattern is successful. If ``name`` is ``None``, ``pattern`` must also be "
"``None`` and the node represents the wildcard pattern."
msgstr ""

#: ../../library/ast.rst:1724
msgid ""
"A match \"or-pattern\". An or-pattern matches each of its subpatterns in "
"turn to the subject, until one succeeds. The or-pattern is then deemed to"
" succeed. If none of the subpatterns succeed the or-pattern fails. The "
"``patterns`` attribute contains a list of match pattern nodes that will "
"be matched against the subject."
msgstr ""

#: ../../library/ast.rst:1758
msgid "Type parameters"
msgstr ""

#: ../../library/ast.rst:1760
msgid ""
":ref:`Type parameters <type-params>` can exist on classes, functions, and"
" type aliases."
msgstr ""

#: ../../library/ast.rst:1765
msgid ""
"A :class:`typing.TypeVar`. *name* is the name of the type variable. "
"*bound* is the bound or constraints, if any. If *bound* is a "
":class:`Tuple`, it represents constraints; otherwise it represents the "
"bound. *default_value* is the default value; if the :class:`!TypeVar` has"
" no default, this attribute will be set to ``None``."
msgstr ""

#: ../../library/ast.rst:1790 ../../library/ast.rst:1825
#: ../../library/ast.rst:1857
msgid "Added the *default_value* parameter."
msgstr ""

#: ../../library/ast.rst:1795
msgid ""
"A :class:`typing.ParamSpec`. *name* is the name of the parameter "
"specification. *default_value* is the default value; if the "
":class:`!ParamSpec` has no default, this attribute will be set to "
"``None``."
msgstr ""

#: ../../library/ast.rst:1830
msgid ""
"A :class:`typing.TypeVarTuple`. *name* is the name of the type variable "
"tuple. *default_value* is the default value; if the "
":class:`!TypeVarTuple` has no default, this attribute will be set to "
"``None``."
msgstr ""

#: ../../library/ast.rst:1861
msgid "Function and class definitions"
msgstr ""

#: ../../library/ast.rst:1865
msgid "A function definition."
msgstr ""

#: ../../library/ast.rst:1867
msgid "``name`` is a raw string of the function name."
msgstr ""

#: ../../library/ast.rst:1868
msgid "``args`` is an :class:`arguments` node."
msgstr ""

#: ../../library/ast.rst:1869
msgid "``body`` is the list of nodes inside the function."
msgstr ""

#: ../../library/ast.rst:1870
msgid ""
"``decorator_list`` is the list of decorators to be applied, stored "
"outermost first (i.e. the first in the list will be applied last)."
msgstr ""

#: ../../library/ast.rst:1872
msgid "``returns`` is the return annotation."
msgstr ""

#: ../../library/ast.rst:1873 ../../library/ast.rst:2037
msgid "``type_params`` is a list of :ref:`type parameters <ast-type-params>`."
msgstr ""

#: ../../library/ast.rst:1879 ../../library/ast.rst:2064
#: ../../library/ast.rst:2075
msgid "Added ``type_params``."
msgstr ""

#: ../../library/ast.rst:1885
msgid ""
"``lambda`` is a minimal function definition that can be used inside an "
"expression. Unlike :class:`FunctionDef`, ``body`` holds a single node."
msgstr ""

#: ../../library/ast.rst:1904
msgid "The arguments for a function."
msgstr ""

#: ../../library/ast.rst:1906
msgid ""
"``posonlyargs``, ``args`` and ``kwonlyargs`` are lists of :class:`arg` "
"nodes."
msgstr ""

#: ../../library/ast.rst:1907
msgid ""
"``vararg`` and ``kwarg`` are single :class:`arg` nodes, referring to the "
"``*args, **kwargs`` parameters."
msgstr ""

#: ../../library/ast.rst:1909
msgid ""
"``kw_defaults`` is a list of default values for keyword-only arguments. "
"If one is ``None``, the corresponding argument is required."
msgstr ""

#: ../../library/ast.rst:1911
msgid ""
"``defaults`` is a list of default values for arguments that can be passed"
" positionally. If there are fewer defaults, they correspond to the last n"
" arguments."
msgstr ""

#: ../../library/ast.rst:1918
msgid ""
"A single argument in a list. ``arg`` is a raw string of the argument "
"name; ``annotation`` is its annotation, such as a :class:`Name` node."
msgstr ""

#: ../../library/ast.rst:1923
msgid ""
"``type_comment`` is an optional string with the type annotation as a "
"comment"
msgstr ""

#: ../../library/ast.rst:1965
msgid "A ``return`` statement."
msgstr ""

#: ../../library/ast.rst:1979
msgid ""
"A ``yield`` or ``yield from`` expression. Because these are expressions, "
"they must be wrapped in a :class:`Expr` node if the value sent back is "
"not used."
msgstr ""

#: ../../library/ast.rst:2002
msgid ""
"``global`` and ``nonlocal`` statements. ``names`` is a list of raw "
"strings."
msgstr ""

#: ../../library/ast.rst:2027
msgid "A class definition."
msgstr ""

#: ../../library/ast.rst:2029
msgid "``name`` is a raw string for the class name"
msgstr ""

#: ../../library/ast.rst:2030
msgid "``bases`` is a list of nodes for explicitly specified base classes."
msgstr ""

#: ../../library/ast.rst:2031
msgid ""
"``keywords`` is a list of :class:`.keyword` nodes, principally for "
"'metaclass'. Other keywords will be passed to the metaclass, as per "
"`PEP-3115 <https://peps.python.org/pep-3115/>`_."
msgstr ""

#: ../../library/ast.rst:2034
msgid ""
"``body`` is a list of nodes representing the code within the class "
"definition."
msgstr ""

#: ../../library/ast.rst:2036
msgid "``decorator_list`` is a list of nodes, as in :class:`FunctionDef`."
msgstr ""

#: ../../library/ast.rst:2068
msgid "Async and await"
msgstr ""

#: ../../library/ast.rst:2072
msgid ""
"An ``async def`` function definition. Has the same fields as "
":class:`FunctionDef`."
msgstr ""

#: ../../library/ast.rst:2081
msgid ""
"An ``await`` expression. ``value`` is what it waits for. Only valid in "
"the body of an :class:`AsyncFunctionDef`."
msgstr ""

#: ../../library/ast.rst:2105
msgid ""
"``async for`` loops and ``async with`` context managers. They have the "
"same fields as :class:`For` and :class:`With`, respectively. Only valid "
"in the body of an :class:`AsyncFunctionDef`."
msgstr ""

#: ../../library/ast.rst:2110
msgid ""
"When a string is parsed by :func:`ast.parse`, operator nodes (subclasses "
"of :class:`ast.operator`, :class:`ast.unaryop`, :class:`ast.cmpop`, "
":class:`ast.boolop` and :class:`ast.expr_context`) on the returned tree "
"will be singletons. Changes to one will be reflected in all other "
"occurrences of the same value (e.g. :class:`ast.Add`)."
msgstr ""

#: ../../library/ast.rst:2118
msgid ":mod:`ast` Helpers"
msgstr ""

#: ../../library/ast.rst:2120
msgid ""
"Apart from the node classes, the :mod:`ast` module defines these utility "
"functions and classes for traversing abstract syntax trees:"
msgstr ""

#: ../../library/ast.rst:2125
msgid ""
"Parse the source into an AST node.  Equivalent to ``compile(source, "
"filename, mode, flags=FLAGS_VALUE, optimize=optimize)``, where "
"``FLAGS_VALUE`` is ``ast.PyCF_ONLY_AST`` if ``optimize <= 0`` and "
"``ast.PyCF_OPTIMIZED_AST`` otherwise."
msgstr ""

#: ../../library/ast.rst:2130
msgid ""
"If ``type_comments=True`` is given, the parser is modified to check and "
"return type comments as specified by :pep:`484` and :pep:`526`. This is "
"equivalent to adding :data:`ast.PyCF_TYPE_COMMENTS` to the flags passed "
"to :func:`compile()`.  This will report syntax errors for misplaced type "
"comments.  Without this flag, type comments will be ignored, and the "
"``type_comment`` field on selected AST nodes will always be ``None``.  In"
" addition, the locations of ``# type: ignore`` comments will be returned "
"as the ``type_ignores`` attribute of :class:`Module` (otherwise it is "
"always an empty list)."
msgstr ""

#: ../../library/ast.rst:2140
msgid ""
"In addition, if ``mode`` is ``'func_type'``, the input syntax is modified"
" to correspond to :pep:`484` \"signature type comments\", e.g. ``(str, "
"int) -> List[str]``."
msgstr ""

#: ../../library/ast.rst:2144
msgid ""
"Setting ``feature_version`` to a tuple ``(major, minor)`` will result in "
"a \"best-effort\" attempt to parse using that Python version's grammar. "
"For example, setting ``feature_version=(3, 9)`` will attempt to disallow "
"parsing of :keyword:`match` statements. Currently ``major`` must equal to"
" ``3``. The lowest supported version is ``(3, 7)`` (and this may increase"
" in future Python versions); the highest is ``sys.version_info[0:2]``. "
"\"Best-effort\" attempt means there is no guarantee that the parse (or "
"success of the parse) is the same as when run on the Python version "
"corresponding to ``feature_version``."
msgstr ""

#: ../../library/ast.rst:2154
msgid ""
"If source contains a null character (``\\0``), :exc:`ValueError` is "
"raised."
msgstr ""

#: ../../library/ast.rst:2157
msgid ""
"Note that successfully parsing source code into an AST object doesn't "
"guarantee that the source code provided is valid Python code that can be "
"executed as the compilation step can raise further :exc:`SyntaxError` "
"exceptions. For instance, the source ``return 42`` generates a valid AST "
"node for a return statement, but it cannot be compiled alone (it needs to"
" be inside a function node)."
msgstr ""

#: ../../library/ast.rst:2164
msgid ""
"In particular, :func:`ast.parse` won't do any scoping checks, which the "
"compilation step does."
msgstr ""

#: ../../library/ast.rst:2168
msgid ""
"It is possible to crash the Python interpreter with a sufficiently "
"large/complex string due to stack depth limitations in Python's AST "
"compiler."
msgstr ""

#: ../../library/ast.rst:2172
msgid "Added ``type_comments``, ``mode='func_type'`` and ``feature_version``."
msgstr ""

#: ../../library/ast.rst:2175
msgid ""
"The minimum supported version for ``feature_version`` is now ``(3, 7)``. "
"The ``optimize`` argument was added."
msgstr ""

#: ../../library/ast.rst:2182
msgid ""
"Unparse an :class:`ast.AST` object and generate a string with code that "
"would produce an equivalent :class:`ast.AST` object if parsed back with "
":func:`ast.parse`."
msgstr ""

#: ../../library/ast.rst:2187
msgid ""
"The produced code string will not necessarily be equal to the original "
"code that generated the :class:`ast.AST` object (without any compiler "
"optimizations, such as constant tuples/frozensets)."
msgstr ""

#: ../../library/ast.rst:2192
msgid ""
"Trying to unparse a highly complex expression would result with "
":exc:`RecursionError`."
msgstr ""

#: ../../library/ast.rst:2200
msgid ""
"Evaluate an expression node or a string containing only a Python literal "
"or container display.  The string or node provided may only consist of "
"the following Python literal structures: strings, bytes, numbers, tuples,"
" lists, dicts, sets, booleans, ``None`` and ``Ellipsis``."
msgstr ""

#: ../../library/ast.rst:2205
msgid ""
"This can be used for evaluating strings containing Python values without "
"the need to parse the values oneself.  It is not capable of evaluating "
"arbitrarily complex expressions, for example involving operators or "
"indexing."
msgstr ""

#: ../../library/ast.rst:2210
msgid ""
"This function had been documented as \"safe\" in the past without "
"defining what that meant. That was misleading. This is specifically "
"designed not to execute Python code, unlike the more general "
":func:`eval`. There is no namespace, no name lookups, or ability to call "
"out. But it is not free from attack: A relatively small input can lead to"
" memory exhaustion or to C stack exhaustion, crashing the process. There "
"is also the possibility for excessive CPU consumption denial of service "
"on some inputs. Calling it on untrusted data is thus not recommended."
msgstr ""

#: ../../library/ast.rst:2220
msgid ""
"It is possible to crash the Python interpreter due to stack depth "
"limitations in Python's AST compiler."
msgstr ""

#: ../../library/ast.rst:2223
msgid ""
"It can raise :exc:`ValueError`, :exc:`TypeError`, :exc:`SyntaxError`, "
":exc:`MemoryError` and :exc:`RecursionError` depending on the malformed "
"input."
msgstr ""

#: ../../library/ast.rst:2227
msgid "Now allows bytes and set literals."
msgstr ""

#: ../../library/ast.rst:2230
msgid "Now supports creating empty sets with ``'set()'``."
msgstr ""

#: ../../library/ast.rst:2233
msgid "For string inputs, leading spaces and tabs are now stripped."
msgstr ""

#: ../../library/ast.rst:2239
msgid ""
"Return the docstring of the given *node* (which must be a "
":class:`FunctionDef`, :class:`AsyncFunctionDef`, :class:`ClassDef`, or "
":class:`Module` node), or ``None`` if it has no docstring. If *clean* is "
"true, clean up the docstring's indentation with :func:`inspect.cleandoc`."
msgstr ""

#: ../../library/ast.rst:2245
msgid ":class:`AsyncFunctionDef` is now supported."
msgstr ""

#: ../../library/ast.rst:2251
msgid ""
"Get source code segment of the *source* that generated *node*. If some "
"location information (:attr:`~ast.AST.lineno`, "
":attr:`~ast.AST.end_lineno`, :attr:`~ast.AST.col_offset`, or "
":attr:`~ast.AST.end_col_offset`) is missing, return ``None``."
msgstr ""

#: ../../library/ast.rst:2255
msgid ""
"If *padded* is ``True``, the first line of a multi-line statement will be"
" padded with spaces to match its original position."
msgstr ""

#: ../../library/ast.rst:2263
msgid ""
"When you compile a node tree with :func:`compile`, the compiler expects "
":attr:`~ast.AST.lineno` and :attr:`~ast.AST.col_offset` attributes for "
"every node that supports them.  This is rather tedious to fill in for "
"generated nodes, so this helper adds these attributes recursively where "
"not already set, by setting them to the values of the parent node.  It "
"works recursively starting at *node*."
msgstr ""

#: ../../library/ast.rst:2272
msgid ""
"Increment the line number and end line number of each node in the tree "
"starting at *node* by *n*. This is useful to \"move code\" to a different"
" location in a file."
msgstr ""

#: ../../library/ast.rst:2279
msgid ""
"Copy source location (:attr:`~ast.AST.lineno`, "
":attr:`~ast.AST.col_offset`, :attr:`~ast.AST.end_lineno`, and "
":attr:`~ast.AST.end_col_offset`) from *old_node* to *new_node* if "
"possible, and return *new_node*."
msgstr ""

#: ../../library/ast.rst:2286
msgid ""
"Yield a tuple of ``(fieldname, value)`` for each field in "
"``node._fields`` that is present on *node*."
msgstr ""

#: ../../library/ast.rst:2292
msgid ""
"Yield all direct child nodes of *node*, that is, all fields that are "
"nodes and all items of fields that are lists of nodes."
msgstr ""

#: ../../library/ast.rst:2298
msgid ""
"Recursively yield all descendant nodes in the tree starting at *node* "
"(including *node* itself), in no specified order.  This is useful if you "
"only want to modify nodes in place and don't care about the context."
msgstr ""

#: ../../library/ast.rst:2305
msgid ""
"A node visitor base class that walks the abstract syntax tree and calls a"
" visitor function for every node found.  This function may return a value"
" which is forwarded by the :meth:`visit` method."
msgstr ""

#: ../../library/ast.rst:2309
msgid ""
"This class is meant to be subclassed, with the subclass adding visitor "
"methods."
msgstr ""

#: ../../library/ast.rst:2314
msgid ""
"Visit a node.  The default implementation calls the method called "
":samp:`self.visit_{classname}` where *classname* is the name of the node "
"class, or :meth:`generic_visit` if that method doesn't exist."
msgstr ""

#: ../../library/ast.rst:2320
msgid "This visitor calls :meth:`visit` on all children of the node."
msgstr ""

#: ../../library/ast.rst:2322
msgid ""
"Note that child nodes of nodes that have a custom visitor method won't be"
" visited unless the visitor calls :meth:`generic_visit` or visits them "
"itself."
msgstr ""

#: ../../library/ast.rst:2328
msgid "Handles all constant nodes."
msgstr ""

#: ../../library/ast.rst:2330
msgid ""
"Don't use the :class:`NodeVisitor` if you want to apply changes to nodes "
"during traversal.  For this a special visitor exists "
"(:class:`NodeTransformer`) that allows modifications."
msgstr ""

#: ../../library/ast.rst:2336
msgid ""
"Methods :meth:`!visit_Num`, :meth:`!visit_Str`, :meth:`!visit_Bytes`, "
":meth:`!visit_NameConstant` and :meth:`!visit_Ellipsis` are deprecated "
"now and will not be called in future Python versions.  Add the "
":meth:`visit_Constant` method to handle all constant nodes."
msgstr ""

#: ../../library/ast.rst:2344
msgid ""
"A :class:`NodeVisitor` subclass that walks the abstract syntax tree and "
"allows modification of nodes."
msgstr ""

#: ../../library/ast.rst:2347
msgid ""
"The :class:`NodeTransformer` will walk the AST and use the return value "
"of the visitor methods to replace or remove the old node.  If the return "
"value of the visitor method is ``None``, the node will be removed from "
"its location, otherwise it is replaced with the return value.  The return"
" value may be the original node in which case no replacement takes place."
msgstr ""

#: ../../library/ast.rst:2353
msgid ""
"Here is an example transformer that rewrites all occurrences of name "
"lookups (``foo``) to ``data['foo']``::"
msgstr ""

#: ../../library/ast.rst:2365
msgid ""
"Keep in mind that if the node you're operating on has child nodes you "
"must either transform the child nodes yourself or call the "
":meth:`~ast.NodeVisitor.generic_visit` method for the node first."
msgstr ""

#: ../../library/ast.rst:2369
msgid ""
"For nodes that were part of a collection of statements (that applies to "
"all statement nodes), the visitor may also return a list of nodes rather "
"than just a single node."
msgstr ""

#: ../../library/ast.rst:2373
msgid ""
"If :class:`NodeTransformer` introduces new nodes (that weren't part of "
"original tree) without giving them location information (such as "
":attr:`~ast.AST.lineno`), :func:`fix_missing_locations` should be called "
"with the new sub-tree to recalculate the location information::"
msgstr ""

#: ../../library/ast.rst:2381
msgid "Usually you use the transformer like this::"
msgstr ""

#: ../../library/ast.rst:2388
msgid ""
"Return a formatted dump of the tree in *node*.  This is mainly useful for"
" debugging purposes.  If *annotate_fields* is true (by default), the "
"returned string will show the names and the values for fields. If "
"*annotate_fields* is false, the result string will be more compact by "
"omitting unambiguous field names.  Attributes such as line numbers and "
"column offsets are not dumped by default.  If this is wanted, "
"*include_attributes* can be set to true."
msgstr ""

#: ../../library/ast.rst:2396
msgid ""
"If *indent* is a non-negative integer or string, then the tree will be "
"pretty-printed with that indent level.  An indent level of 0, negative, "
"or ``\"\"`` will only insert newlines.  ``None`` (the default) selects "
"the single line representation. Using a positive integer indent indents "
"that many spaces per level.  If *indent* is a string (such as "
"``\"\\t\"``), that string is used to indent each level."
msgstr ""

#: ../../library/ast.rst:2403
msgid ""
"If *show_empty* is ``False`` (the default), empty lists and fields that "
"are ``None`` will be omitted from the output."
msgstr ""

#: ../../library/ast.rst:2406
msgid "Added the *indent* option."
msgstr ""

#: ../../library/ast.rst:2409
msgid "Added the *show_empty* option."
msgstr ""

#: ../../library/ast.rst:2443
msgid "Compiler Flags"
msgstr ""

#: ../../library/ast.rst:2445
msgid ""
"The following flags may be passed to :func:`compile` in order to change "
"effects on the compilation of a program:"
msgstr ""

#: ../../library/ast.rst:2450
msgid ""
"Enables support for top-level ``await``, ``async for``, ``async with`` "
"and async comprehensions."
msgstr ""

#: ../../library/ast.rst:2457
msgid ""
"Generates and returns an abstract syntax tree instead of returning a "
"compiled code object."
msgstr ""

#: ../../library/ast.rst:2462
msgid ""
"The returned AST is optimized according to the *optimize* argument in "
":func:`compile` or :func:`ast.parse`."
msgstr ""

#: ../../library/ast.rst:2469
msgid ""
"Enables support for :pep:`484` and :pep:`526` style type comments (``# "
"type: <type>``, ``# type: ignore <stuff>``)."
msgstr ""

#: ../../library/ast.rst:2478
msgid "Command-Line Usage"
msgstr ""

#: ../../library/ast.rst:2482
msgid ""
"The :mod:`ast` module can be executed as a script from the command line. "
"It is as simple as:"
msgstr ""

#: ../../library/ast.rst:2489
msgid "The following options are accepted:"
msgstr ""

#: ../../library/ast.rst:2495
msgid "Show the help message and exit."
msgstr ""

#: ../../library/ast.rst:2500
msgid ""
"Specify what kind of code must be compiled, like the *mode* argument in "
":func:`parse`."
msgstr ""

#: ../../library/ast.rst:2505
msgid "Don't parse type comments."
msgstr ""

#: ../../library/ast.rst:2509
msgid "Include attributes such as line numbers and column offsets."
msgstr ""

#: ../../library/ast.rst:2514
msgid "Indentation of nodes in AST (number of spaces)."
msgstr ""

#: ../../library/ast.rst:2516
msgid ""
"If :file:`infile` is specified its contents are parsed to AST and dumped "
"to stdout.  Otherwise, the content is read from stdin."
msgstr ""

#: ../../library/ast.rst:2522
msgid ""
"`Green Tree Snakes <https://greentreesnakes.readthedocs.io/>`_, an "
"external documentation resource, has good details on working with Python "
"ASTs."
msgstr ""

#: ../../library/ast.rst:2525
msgid ""
"`ASTTokens <https://asttokens.readthedocs.io/en/latest/user-guide.html>`_"
" annotates Python ASTs with the positions of tokens and text in the "
"source code that generated them. This is helpful for tools that make "
"source code transformations."
msgstr ""

#: ../../library/ast.rst:2530
msgid ""
"`leoAst.py <https://leo-editor.github.io/leo-editor/appendices.html"
"#leoast-py>`_ unifies the token-based and parse-tree-based views of "
"python programs by inserting two-way links between tokens and ast nodes."
msgstr ""

#: ../../library/ast.rst:2535
msgid ""
"`LibCST <https://libcst.readthedocs.io/>`_ parses code as a Concrete "
"Syntax Tree that looks like an ast tree and keeps all formatting details."
" It's useful for building automated refactoring (codemod) applications "
"and linters."
msgstr ""

#: ../../library/ast.rst:2540
msgid ""
"`Parso <https://parso.readthedocs.io>`_ is a Python parser that supports "
"error recovery and round-trip parsing for different Python versions (in "
"multiple Python versions). Parso is also able to list multiple syntax "
"errors in your Python file."
msgstr ""

#: ../../library/ast.rst:59
msgid "? (question mark)"
msgstr ""

#: ../../library/ast.rst:59 ../../library/ast.rst:60
msgid "in AST grammar"
msgstr ""

#: ../../library/ast.rst:60
msgid "* (asterisk)"
msgstr ""

#~ msgid ":mod:`ast` --- Abstract Syntax Trees"
#~ msgstr ""

#~ msgid ""
#~ "Each concrete class has an attribute "
#~ ":attr:`_fields` which gives the names of"
#~ " all child nodes."
#~ msgstr ""

#~ msgid "or the more compact ::"
#~ msgstr ""

#~ msgid ""
#~ "When creating a ``Call`` node, ``args``"
#~ " and ``keywords`` are required, but "
#~ "they can be empty lists."
#~ msgstr ""

#~ msgid ""
#~ "A :class:`typing.TypeVar`. ``name`` is the "
#~ "name of the type variable. ``bound`` "
#~ "is the bound or constraints, if "
#~ "any. If ``bound`` is a :class:`Tuple`,"
#~ " it represents constraints; otherwise it"
#~ " represents the bound."
#~ msgstr ""

#~ msgid ""
#~ "A :class:`typing.ParamSpec`. ``name`` is the"
#~ " name of the parameter specification."
#~ msgstr ""

#~ msgid ""
#~ "A :class:`typing.TypeVarTuple`. ``name`` is "
#~ "the name of the type variable "
#~ "tuple."
#~ msgstr ""

#~ msgid ""
#~ "Parse the source into an AST node."
#~ "  Equivalent to ``compile(source, filename, "
#~ "mode, ast.PyCF_ONLY_AST)``."
#~ msgstr ""

#~ msgid ""
#~ "Setting ``feature_version`` to a tuple "
#~ "``(major, minor)`` will result in a "
#~ "\"best-effort\" attempt to parse using"
#~ " that Python version's grammar. For "
#~ "example, setting ``feature_version=(3, 9)`` "
#~ "will attempt to disallow parsing of "
#~ ":keyword:`match` statements. Currently ``major`` "
#~ "must equal to ``3``. The lowest "
#~ "supported version is ``(3, 4)`` (and "
#~ "this may increase in future Python "
#~ "versions); the highest is "
#~ "``sys.version_info[0:2]``. \"Best-effort\" attempt"
#~ " means there is no guarantee that "
#~ "the parse (or success of the "
#~ "parse) is the same as when run "
#~ "on the Python version corresponding to"
#~ " ``feature_version``."
#~ msgstr ""

